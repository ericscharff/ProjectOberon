<HTML>
<HEAD>
<TITLE>The Gfx Howto</TITLE>
</HEAD>
<BODY>
<H1 ALIGN=CENTER>The Gfx Howto</H1>
This document describes typical usage patterns of the Gfx library, organized as a hierarchical
sets of questions and answers. Its goal is to serve as an easily accessable resource on how to
use Gfx in practice. I've tried to come up with questions (and answers) that might arise in
everyday life. If you cannot find your question or a satisfying answer, suggest an update to
<A HREF="mailto://oswald@inf.ethz.ch">oswald@inf.ethz.ch</A>.
<HR>
<OL>
<LI><A HREF="#Gfx">Gfx</A></LI>
<LI><A HREF="#Contexts">Contexts</A></LI>
<LI><A HREF="#Graphics">Vector Graphics</A></LI>
<LI><A HREF="#Attributes">Graphical Attributes</A></LI>
<LI><A HREF="#Text">Text</A></LI>
<LI><A HREF="#Coordinates">Coordinate Systems</A></LI>
<LI><A HREF="#Bitmaps">Bitmaps</A></LI>
<LI><A HREF="#Clipping">Clipping</A></LI>
<LI><A HREF="#Paths">Paths</A></LI>
<LI><A HREF="#Next">What next?</A></LI>
</OL>
<HR>
<OL>
<LI><A NAME="Gfx">Gfx</A>
<OL>
<LI><A HREF="#Gfx.1">What is Gfx?</A></LI>
<LI><A HREF="#Gfx.2">Who uses Gfx?</A></LI>
<LI><A HREF="#Gfx.3">What can I use it for?</A></LI>
<LI><A HREF="#Gfx.4">Where do I get Gfx?</A></LI>
<LI><A HREF="#Gfx.5">Does Gfx require any other packages or files?</A></LI>
<LI><A HREF="#Gfx.6">Is there any example code available?</A></LI>
</OL>
</LI>
<P>
<LI><A NAME="Contexts">Contexts</A>
<OL>
<LI><A HREF="#Contexts.1">What is a context?</A></LI>
<LI><A HREF="#Contexts.2">What kinds of contexts do exist?</A></LI>
<LI><A HREF="#Contexts.3">How do I create a context for drawing to the screen?</A></LI>
<LI><A HREF="#Contexts.4">How do I create a context for drawing to a bitmap?</A></LI>
<LI><A HREF="#Contexts.5">How do I create a context for printing my graphics?</A></LI>
<LI><A HREF="#Contexts.6">How do I create Postscript and EPS files?</A></LI>
</OL>
</LI>
<P>
<LI><A NAME="Graphics">Vector Graphics</A>
<OL>
<LI><A HREF="#Graphics.1">How do I draw a line?</A></LI>
<LI><A HREF="#Graphics.2">How do I draw a rectangle?</A></LI>
<LI><A HREF="#Graphics.3">How do I draw circles and ellipses?</A></LI>
<LI><A HREF="#Graphics.4">What are paths?</A></LI>
<LI><A HREF="#Graphics.5">What are subpaths and why are they needed?</A></LI>
<LI><A HREF="#Graphics.6">How do I specify a path?</A></LI>
<LI><A HREF="#Graphics.7">What's the difference between Enter/Exit and Enter0/Exit0?</A></LI>
<LI><A HREF="#Graphics.8">What to do if I don't know initial and terminal directions of a closed subpath?</A></LI>
<LI><A HREF="#Graphics.9">Why do arcs have so many parameters?</A></LI>
<LI><A HREF="#Graphics.10">How are self-intersecting paths treated?</A></LI>
<LI><A HREF="#Graphics.11">What path modes do exist?</A></LI>
<LI><A HREF="#Graphics.12">What can I use recorded paths for?</A></LI>
</OL>
</LI>
<P>
<LI><A NAME="Attributes">Graphical Attributes</A>
<OL>
<LI><A HREF="#Attributes.1">How do I set the current stroke and fill colors?</A></LI>
<LI><A HREF="#Attributes.2">How do I change the current stroke and fill patterns?</A></LI>
<LI><A HREF="#Attributes.3">How do I draw dashed curves?</A></LI>
<LI><A HREF="#Attributes.4">How do I change the current line width?</A></LI>
<LI><A HREF="#Attributes.5">How do I change the current line cap style?</A></LI>
<LI><A HREF="#Attributes.6">How do I change the current line join style?</A></LI>
<LI><A HREF="#Attributes.7">How do I control the quality of arc and bezier approximation?</A></LI>
<LI><A HREF="#Attributes.8">Why doesn't Gfx let me change attributes within a path?</A></LI>
</OL>
</LI>
<P>
<LI><A NAME="Text">Text</A>
<OL>
<LI><A HREF="#Text.1">How do I display a string?</A></LI>
<LI><A HREF="#Text.2">How can I set the current point manually?</A></LI>
<LI><A HREF="#Text.3">How do I change the current font?</A></LI>
<LI><A HREF="#Text.4">How do I change the current text color?</A></LI>
<LI><A HREF="#Text.5">Can I convert characters to paths?</A></LI>
<LI><A HREF="#Text.6">How can I center a caption?</A></LI>
<LI><A HREF="#Text.7">Can I use my huge collection of TrueType fonts?</A></LI>
<LI><A HREF="#Text.8">How about my Type1 fonts?</A></LI>
</OL>
</LI>
<P>
<LI><A NAME="Coordinates">Coordinate Systems</A>
<OL>
<LI><A HREF="#Coordinates.1">Where is the coordinate origin of a context?</A></LI>
<LI><A HREF="#Coordinates.2">How can I move the current coordinate origin?</A></LI>
<LI><A HREF="#Coordinates.3">What is the default unit of a context?</A></LI>
<LI><A HREF="#Coordinates.4">How do I scale the current coordinate system?</A></LI>
<LI><A HREF="#Coordinates.5">How do I rotate the current coordinate system?</A></LI>
<LI><A HREF="#Coordinates.6">Can I specify other transformations to the current coordinate system?</A></LI>
<LI><A HREF="#Coordinates.7">How can I undo the changes I've made to the current coordinate system?</A></LI>
<LI><A HREF="#Coordinates.8">How can I return to the original coordinate system?</A></LI>
<LI><A HREF="#Coordinates.9">What are the dimensions of a device pixel?</A></LI>
</OL>
</LI>
<P>
<LI><A NAME="Bitmaps">Bitmaps</A>
<OL>
<LI><A HREF="#Bitmaps.1">Why can't I just draw Oberon pictures?</A></LI>
<LI><A HREF="#Bitmaps.2">What are bitmap formats?</A></LI>
<LI><A HREF="#Bitmaps.3">Can I define my own bitmap formats?</A></LI>
<LI><A HREF="#Bitmaps.4">What is a blend operator?</A></LI>
<LI><A HREF="#Bitmaps.5">Can I define custom blend operators?</A></LI>
<LI><A HREF="#Bitmaps.6">What is a filter?</A></LI>
<LI><A HREF="#Bitmaps.7">And I can define custom filters, too?</A></LI>
<LI><A HREF="#Bitmaps.8">I'd still like to use existing Oberon pictures. How?</A></LI>
<LI><A HREF="#Bitmaps.9">And while we're at it, how about Oberon patterns?</A></LI>
<LI><A HREF="#Bitmaps.10">How can I integrate my images in XYZ format into Gfx?</A></LI>
</OL>
</LI>
<P>
<LI><A NAME="Clipping">Clipping</A>
<OL>
<LI><A HREF="#Clipping.1">What is the initial clipping region of a context?</A></LI>
<LI><A HREF="#Clipping.2">How do I change a context's default clipping region?</A></LI>
<LI><A HREF="#Clipping.3">How do I convert a gadget mask to a clipping region?</A></LI>
<LI><A HREF="#Clipping.4">How can I change the current clipping region?</A></LI>
<LI><A HREF="#Clipping.5">How can I undo the changes I've made to the current clipping region?</A></LI>
<LI><A HREF="#Clipping.6">How can I return the the clipping region to its initial state?</A></LI>
</OL>
</LI>
<P>
<LI><A NAME="Paths">Paths</A>
<OL>
<LI><A HREF="#Paths.1">How can I access the elements in the current path?</A></LI>
<LI><A HREF="#Paths.2">How to calculate bounding box and length of path?</A></LI>
<LI><A HREF="#Paths.3">How can I modify a recorded path?</A></LI>
<LI><A HREF="#Paths.4">How to render an edited path?</A></LI>
</OL>
</LI>
<P>
<LI><A NAME="Next">What next?</A>
<OL>
<LI><A HREF="#Next.1">Are there other sources of information?</A></LI>
<LI><A HREF="#Next.2">Who do I report bugs and suggestions to?</A></LI>
<LI><A HREF="#Next.3">How can I contribute to Gfx?</A></LI>
</OL>
</LI>
</OL>

<HR>
<H2 ALIGN=CENTER>Gfx</H2>

<H3><A NAME="Gfx.1">What is Gfx?</A></H3>
Gfx is a set of modules for rendering two-dimensional graphics using high-level operations. Applications
use procedures operating on a <EM>context</EM> structure to describe the shapes that they wish to draw.
The context fulfills these requests e.g. by modifying pixels on a raster display or by appending text to a
page description that is being gathered in a file. Gfx currently runs on Oberon System 3.

<H3><A NAME="Gfx.2">Who uses Gfx?</A></H3>
The first application to use Gfx was Leonardo, the graphics editor provided as part of the System 3
distribution. In fact, Gfx was developed as an integral part of Leonardo but is now also available to
other applications.
<P>
Another project using Gfx is a PDF viewer that has been developed by Marcel B&ouml;siger during
a semester project.

<H3><A NAME="Gfx.3">What can I use it for?</A></H3>
Producing graphical output in a device independent manner. Drawing complex vector graphics. Drawing
scaled and rotated bitmaps and text. Gfx should be suitable for producing any non-trivial graphical output.

<H3><A NAME="Gfx.4">Where do I get Gfx?</A></H3>
Since Leonardo is part of all System 3 distributions, you might already have Gfx installed. The most current
release is available at the <A HREF="ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/Contrib/Gfx/"
>ETH FTP server</A>.

<H3><A NAME="Gfx.5">Does Gfx require any other packages or files?</A></H3>
Gfx runs on top of the basic Oberon system. However, you might consider installing the
<A HREF="ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/Contrib/Metafonts/"
>Metafont</A> packages containing outlines for Oberon fonts and the
<A HREF="ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/Contrib/OpenType/"
>OpenType</A> package for Oberon System 3 as well. 

<H3><A NAME="Gfx.6">Is there any example code available?</A></H3>
The Gfx distribution contains two modules which will usually never be imported by clients.
<UL>
<LI><STRONG>GfxTest</STRONG> contains a set of commands which use most features of Gfx
and produce output on a variety of different contexts.</LI>
<LI><STRONG>GfxDemo</STRONG> demonstrates how to use Gfx within the System 3 display
hierarchy.</LI>
</UL>

<HR>
<H2 ALIGN=CENTER>Contexts</H2>

<H3><A NAME="Contexts.1">What is a context?</A></H3>
When speaking about Gfx, a context is an abstract heap object of type <STRONG>Gfx.Context</STRONG>.
Contexts maintain a set of state variables and a set of methods for changing these state variables
and for rendering graphical shapes. To get some physical output you need to instance a concrete
extension of <STRONG>Gfx.Context</STRONG>.

<H3><A NAME="Contexts.2">What kinds of contexts do exist?</A></H3>
The current distribution includes the following concrete context types:
<UL>
<LI><STRONG>GfxDisplay.Context</STRONG> renders graphics on the Oberon display.</LI>
<LI><STRONG>GfxBuffer.Context</STRONG> renders graphics into a Gfx bitmap.</LI>
<LI><STRONG>GfxPrinter.Context</STRONG> renders graphics on the Oberon printer.</LI>
<LI><STRONG>GfxPS.Context</STRONG> creates Postscript and EPS files that, when interpreted
by a Postscript interpreter, draw what has been rendered with the context.</LI>
</UL>

<H3><A NAME="Contexts.3">How do I create a context for drawing to the screen?</A></H3>
<PRE>
  VAR ctxt: GfxDisplay.Context;
  NEW(ctxt); GfxDisplay.Init(ctxt, llx, lly, urx, ury);
</PRE>

<H3><A NAME="Contexts.4">How do I create a context for drawing to a bitmap?</A></H3>
<PRE>
  VAR ctxt: GfxBuffer.Context; map: GfxMaps.Map;
  NEW(map); GfxMaps.Create(map, width, height, format);
  NEW(ctxt); GfxBuffer.Init(ctxt, map);
</PRE>

<H3><A NAME="Contexts.5">How do I create a context for printing my graphics?</A></H3>
<PRE>
  VAR ctxt: GfxPrinter.Context;
  Printer.Open(...);
  NEW(ctxt); GfxPrinter.Init(ctxt);
</PRE>

<H3><A NAME="Contexts.6">How do I create Postscript and EPS files?</A></H3>
<PRE>
  VAR ctxt: GfxPS.Context;
  NEW(ctxt);
  
  (* Postscript file: *)
  GfxPS.Init(ctxt, FALSE, FALSE, GfxPS.A4W, GfxPS.A4H, border, border, border, border, 600);
  GfxPS.Open(ctxt, Files.New("out.ps"));
  ....
  GfxPS.ShowPage(ctxt);
  GfxPS.Close(ctxt)
  
  (* EPS file: *)
  GfxPS.InitEPS(ctxt, FALSE, 600);
  GfxPS.Open(ctxt, Files.New("out.eps"));
  ...
  GfxPS.Close(ctxt)
</PRE>

<HR>
<H2 ALIGN=CENTER>Vector Graphics</H2>

<H3><A NAME="Graphics.1">How do I draw a line?</A></H3>
The easiest way to stroke a line from <EM>(x0, y0)</EM> to <EM>(x1, y1)</EM> is
<PRE>  Gfx.DrawLine(ctxt, x0, y0, x1, y1, {Gfx.Stroke})</PRE>

<H3><A NAME="Graphics.2">How do I draw a rectangle?</A></H3>
To stroke a rectangle, call
<PRE>  Gfx.DrawRect(ctxt, x0, y0, x1, y1, {Gfx.Stroke})</PRE>
with <EM>(x0, y0)</EM> and <EM>(x1, y1)</EM> marking two opposite corners of the rectangle.
For drawing a filled rectangle, set the <EM>mode</EM> parameter to <STRONG>Gfx.Fill</STRONG>.
You can include both <STRONG>Gfx.Stroke</STRONG> and <STRONG>Gfx.Fill</STRONG> in
the <EM>mode</EM> parameter, in which case the rectangle will be first filled and then outlined.

<H3><A NAME="Graphics.3">How do I draw circles and ellipses?</A></H3>
To stroke a circle or an axis-aligned ellipse, call one of
<PRE>
  Gfx.DrawCircle(ctxt, x, y, r, {Gfx.Stroke})
  Gfx.DrawEllipse(ctxt, x, y, rx, ry, {Gfx.Stroke})
</PRE>
where the center of the circle or ellipse is at <EM>(x, y)</EM>, the circle radius is <EM>r</EM>
and the ellipse half-radii are <EM>rx</EM> and <EM>ry</EM>. If you want the circle or ellipse
to be filled then include <STRONG>Gfx.Fill</STRONG> in the <EM>mode</EM> parameter.

<H3><A NAME="Graphics.4">What are paths?</A></H3>
Paths are generalizations of primitive shapes such as lines, rectangles, circles, and ellipses. With paths
you can describe triangles, rings, etc. A path consists of any number of subpaths, each of which in turn
consisting of a connected sequence of lines, elliptical arcs and cubic B&eacute;zier curves. You can stroke
a path, fill its interior, or do both at the same time. You can even restrict future rendering operations
to the interior of a path or morph a path into something else.

<H3><A NAME="Graphics.5">What are subpaths and why are they needed?</A></H3>
A subpath is a connected sequence of lines, elliptical arcs and cubic B&eacute;zier curves. It starts at
one point (its entry point) and ends at another (its exit point). Entry and exit point may of course be
coincident. Although most paths consists of exactly one subpath, shapes that include holes can only
be specified by several subpaths. E.g. a ring is most easily specified by a subpath describing an outer
ring (consisting of a 360&deg; counter-clockwise arc) and another subpath describing an inner ring
(consisting of a 360&deg; clockwise arc with smaller radius).

<H3><A NAME="Graphics.6">How do I specify a path?</A></H3>
A line could be rendered using
<PRE>
  Gfx.Begin(ctxt, {Gfx.Stroke});
  Gfx.Enter0(ctxt, x0, y0);
  Gfx.LineTo(ctxt, x1, y1);
  Gfx.Exit0(ctxt);
  Gfx.End(ctxt);
</PRE>
It's important to know that first you have to begin a current path in the rendering mode of your
choice (in our case to stroke the path). Then you can repeatedly render subpaths by entering a
subpath, appending curve elements to it and exiting it again. The end point of each curve
element becomes the new current point of the path and serves as the starting point of the
next element. Don't forget to end the current path or some pending draw operations might
never be executed.

<H3><A NAME="Graphics.7">What's the difference between Enter/Exit and Enter0/Exit0?</A></H3>
The former are needed for properly rendering closed paths. They each expect an additional
direction vector <EM>(dx, dy)</EM>. When rendering closed paths (especially when rendering
thick lines), supply the direction of the last subpath curve just before it gets to the entry/exit
point to <STRONG>Enter</STRONG> and the direction of the first subpath curve just after the
entry/exit point to <STRONG>Exit</STRONG>. As an example, let's render a unit square:
<PRE>
  Gfx.Begin(ctxt, {Gfx.Stroke});
  Gfx.Enter(ctxt, 0, 0, 0, -1);
  Gfx.LineTo(ctxt, 1, 0); Gfx.LineTo(ctxt, 1, 1); Gfx.LineTo(ctxt, 0, 1); Gfx.LineTo(ctxt, 0, 0);
  Gfx.Exit(ctxt, 0, 0, 1, 0);
  Gfx.End(ctxt);
</PRE>
Because the last line goes from <EM>(0, 1)</EM> to <EM>(0, 0)</EM>, its direction is
<EM>(0, -1)</EM>, which we pass to <STRONG>Enter</STRONG>. Similarly, the first
line goes from <EM>(0, 0)</EM> to <EM>(1, 0)</EM>, therefore we pass its direction
<EM>(1, 0)</EM> to <STRONG>Exit</STRONG>. Specifying closed subpaths in this
manner makes sure that there are no artifacts caused by missing join styles at the
shared entry/exit point.
<P>
As you might already have guessed, <STRONG>Enter0</STRONG> and
<STRONG>Exit0</STRONG> are just abbreviated calls which set <EM>(dx, dy)</EM>
to <EM>(0, 0)</EM>, which indicates to Gfx that the current subpath is not closed.

<H3><A NAME="Graphics.8">What to do if I don't know initial and terminal directions of a closed subpath?</A></H3>
You'll find that most of the time it's rather easy to figure out the direction vectors needed
for <STRONG>Enter</STRONG> and <STRONG>Exit</STRONG>. If for once it isn't, you might try the
following pattern:
<PRE>
  Gfx.Begin(ctxt, {Gfx.Record});
  Gfx.Enter0(ctxt, x, y); .... ; Gfx.Exit0(ctxt, x, y);
  Gfx.End(ctxt);
  GfxPaths.Close(ctxt.path);
  Gfx.Render(ctxt, {...});
</PRE>
What this does is record the path without direction vectors (as if it weren't closed) and
then calling <STRONG>GfxPaths.Close</STRONG>, which automatically sets the correct
directions at subpath ends if a subpath has a common entry/exit point. Then you can render
the (now hopefully closed) path in the mode you originally wanted to render it.

<H3><A NAME="Graphics.9">Why do arcs have so many parameters?</A></H3>
The huge number of parameters for elliptic arcs might be scary at first but you'll find that
they offer a maximum of flexibility. The three points <EM>(x0, y0), (x1, y1)</EM> and
<EM>(x2, y2)</EM> define an ellipse having its center at <EM>(x0, y0)</EM>. The other
two points are endpoints of so called <EM>conjugate diameter pairs</EM>. Assuming
<EM>(x0, y0) = (0, 0)</EM>, if <EM>(x1, y1) = (A </EM>sin<EM>(t), B </EM>sin<EM>(t + d))</EM>
then <EM>(x2, y2) = (A </EM>cos<EM>(t), B </EM>cos<EM>(t + d))</EM>.
Another (maybe a bit more comprehensive) way of explaining conjugate diameter pairs
is to imagine a parallelogram centered at <EM>(x0, y0)</EM> and spanned by the vectors
from <EM>(x0, y0)</EM> to <EM>(x1, y1)</EM> and <EM>(x2, y2)</EM>. The ellipse fits
into the parallelogram and touches it in the middle of its sides, two of which are located
at <EM>(x1, y1)</EM> and <EM>(x2, y2)</EM>..
<P>
If the current point of the path is not on the ellipse, a line from the current point to its
projection onto the ellipse boundary is rendered. From the projection of the current
point on the ellipse boundary, the ellipse is traversed until the projection of the end
coordinates onto the ellipse is reached. If the end point does not lie on the ellipse, a
line is drawn from the current point on the ellipse to the end point.
<P>
If the cross product of the conjugate diameter pair vectors is positive, the arc is traversed
in clockwise order, if it is negative, the traversal is in counter-clockwise order.
<P>
Example 1: a unit circle
<PRE>
  Gfx.Enter(ctxt, 1, 0, 0, 1);
  Gfx.ArcTo(ctxt, 1, 0, 0, 0, 1, 0, 0, 1);
  Gfx.Exit(ctxt, 0, 1);
</PRE>
<P>
Example 2: a semi-ellipse from <EM>(-2, 0)</EM> to <EM>(2, 0)</EM> through
<EM>(0, 1)</EM> (note that it has to run counter-clockwise):
<PRE>
  Gfx.Enter(ctxt, -2, 0, 0, 1);
  Gfx.ArcTo(ctxt, 2, 0, 0, 0, -2, 0, 0, 1);
  Gfx.Exit(ctxt, 0, -1);
</PRE>
<P>
Example 3: a circular arc on the unit circle from 45&deg; to 135&deg;:
<PRE>
  Gfx.Enter(ctxt, 0.7071, 0.7071, -1, 1);
  Gfx.ArcTo(ctxt, -0.7071, 0.7071, 0, 0, 1, 0, 0, 1);
  Gfx.Exit(ctxt, -1, -1);
</PRE>

<H3><A NAME="Graphics.10">How are self-intersecting paths treated?</A></H3>
When using self-intersecting paths for filling and clipping, it's not inherently clear
which points are part of the path interior and which aren't. Imagine drawing
a ray originating at a point in question and examine its intersections with the path.
Value each intersection as +1 if the path crosses the ray from right to left and as
-1 if the path crosses the ray from left to right.
<UL>
<LI>With the non-zero winding rule (used by default), the point is considered inside if
the sum of all intersection values is not zero.</LI>
<LI>With the even-odd rule (which is applied if the current drawing mode includes
<STRONG>Gfx.EvenOdd</STRONG>), the point is considered inside if the sum of all
intersection values is odd.</LI>
</UL>

<H3><A NAME="Graphics.11">What path modes do exist?</A></H3>
When beginning a new path with <STRONG>Gfx.Begin</STRONG> or when rendering
the current path with <STRONG>Gfx.Render</STRONG>, a <EM>mode</EM> parameter
describes how the path should be rendered. The drawing mode is a set which contains at
least one of the following elements:
<UL>
<LI><STRONG>Gfx.Record</STRONG> requests that the path should be recorded in the
<EM>path</EM> field of the context.</LI>
<LI><STRONG>Gfx.Stroke</STRONG> requests that the path be stroked using the current
graphical attributes in the context.</LI>
<LI><STRONG>Gfx.Fill</STRONG> requests that the path be filled using the current graphical
attributes in the context.</LI>
<LI><STRONG>Gfx.Clip</STRONG> requests that the current clipping path is to be intersected
with the rendered path, reducing the area which can be drawn to.</LI>
<LI><STRONG>Gfx.EvenOdd</STRONG> activates the even-odd rule for computing the interior
of self-intersecting paths. If <STRONG>Gfx.EvenOdd</STRONG> is omitted, the non-zero
winding rule is used.</LI>
<LI><STRONG>Gfx.InPath</STRONG> is included in the drawing mode when
<STRONG>Gfx.Begin</STRONG> is called and removed when <STRONG>Gfx.End</STRONG>
is called. Never set or clear this yourself.</LI>
<LI><STRONG>Gfx.InSubpath</STRONG> is included in the drawing mode when
<STRONG>Gfx.Enter</STRONG> is called and removed when <STRONG>Gfx.Exit</STRONG>
is called. Never set or clear this yourself.</LI>
</UL>

<H3><A NAME="Graphics.12">What can I use recorded paths for?</A></H3>
Since you usually use Gfx because you want to render graphics, it may not be obvious
why you should be content with just recording paths. However, it is sometimes
necessary to modify the current path before calling <STRONG>Gfx.Render</STRONG>
to render it.
<UL>
<LI><STRONG>Gfx.Flatten</STRONG> replaces all arcs and B&eacute;zier curves in the
path by an approximation using straight lines. The quality of the approximation depends
on the current value of the context's <EM>flatness</EM> attribute.</LI>
<LI><STRONG>Gfx.Outline</STRONG> replaces the current path by a path that outlines
the current path. If you later fill the outlined path, you get the same result as if you
had stroked the original path. Of course you might have other things in mind about
what to do with the outlined path first. <EM>Note:</EM> This only works if the current
line width is larger than zero. For line width zero, the current path is replaced by
a series of dashes if a dash pattern is active.</LI>
<LI>If the directions at shared entry/exit points of closed subpaths are unknown,
calling <STRONG>GfxPaths.Close</STRONG> sets them to their correct values.</LI>
</UL>

<HR>
<H2 ALIGN=CENTER>Graphical Attributes</H2>

<H3><A NAME="Attributes.1">How do I set the current stroke and fill colors?</A></H3>
Gfx manages two current colors at once, one for stroking and one for filling paths,
which are both set to black whenever <STRONG>Gfx.Reset</STRONG> is called.
To set the current stroke color to red and the current fill color to white, call
<PRE>
  Gfx.SetStrokeColor(ctxt, Gfx.Red);
  Gfx.SetFillColor(ctxt, Gfx.White);
</PRE>
For convenience, the following colors are already defined in Gfx: black, white, red,
green, blue, cyan, magenta, yellow and three shades of grey. Of course other colors
may be defined as well, since a color is represented as a record type with three fields
holding values for red, green and blue.

<H3><A NAME="Attributes.2">How do I change the current stroke and fill patterns?</A></H3>
A Gfx pattern is defined as a Gfx bitmap and a pin point for anchoring the pattern origin.
A pattern must be instantiated with <STRONG>Gfx.NewPattern</STRONG>, please don't
initialize patterns yourself. After a pattern has been instantiated, you can pass it to
<STRONG>Gfx.SetStrokePattern</STRONG> or <STRONG>Gfx.SetFillPattern</STRONG>.
To turn pattern stroking and filling off again, pass a NIL value (which is also the default
value for both patterns).
If the bitmap used for defining the pattern doesn't contain any color components (i.e.
is a pure alpha bitmap), the current stroke and fill colors are used (not the color associated
with the bitmap). Patterns do not undergo any transformations, they are always drawn
in the default coordinate system.
<P>
The following example shows how to fill a rectangle in green using the standard Oberon
pattern 2 (consisting of many small dots):
<PRE>
  VAR map: GfxMaps.Map; pat: Gfx.Pattern;
  NEW(map); GfxPictures.PatternToMap(2, map);
  pat := Gfx.NewPattern(ctxt, map, 0, 0);
  Gfx.SetFillColor(ctxt, Gfx.Green);
  Gfx.SetFillPattern(ctxt, pat);
  Gfx.DrawRect(ctxt, 10, 10, 80, 60, {Gfx.Fill});
</PRE>

<H3><A NAME="#Attributes.3">How do I draw dashed curves?</A></H3>
All curves are rendered in one continuous stroke by default. You can change this
by passing a dash pattern to <STRONG>Gfx.SetDashPattern</STRONG>. A dash
pattern consists of several pairs of numbers. The first number of each pair
holds the length of a visible part (a dash), whereas the second holds the distance
from the end of the current dash to the start of the next dash. Another parameter
called the dash phase is used as an initial offset into the pattern at the entry point
of a subpath, which can be useful for slightly adjusting an already defined pattern.
<P>
Let's define a simple dash-dot pattern:
<PRE>
  VAR p: ARRAY 4 OF REAL;
  p[0] := 4; p[1] := 2; p[2] := 1; p[3] := 2;
  Gfx.SetDashPattern(ctxt, p, 4, 0);
</PRE>
Here follows a simple dash pattern that starts in the middle of a dash:
<PRE>
  VAR p: ARRAY 2 OF REAL;
  p[0] := 10; p[1] := 10;
  Gfx.SetDashPattern(ctxt, p, 2, 5);
</PRE>
Dash lengths and phase are in current user coordinates, i.e. they are subject to
the current transformation.

<H3><A NAME="Attributes.4">How do I change the current line width?</A></H3>
Use <STRONG>Gfx.SetLineWidth</STRONG> to set the line width to any positive real
number. The current transformation at the time a path is begun is applied to the line
width before any rendering. If the resulting width is smaller than a device pixel, a
hairline is drawn, which is the thinnest line that can be rendered on any device.
To render lines as thinly as possible you should therefore set the line width to zero.
However, to achieve consistent line widths on all output devices you should choose
a non-zero value. The default line width is one, which corresponds to one display pixel
in the default coordinate system.
<P>
When the current line width exceeds one device pixel, curves are rendered by offsetting
the curve by half the line width from each side of the path and filling the resulting area
(or any equivalent method that a specific implementation chooses). The question is now:
what happens at the entry and exit points of a subpath? Answer: a line cap style is rendered.
And what happens when there is a corner in a subpath because two consecutive lines have
different directions? Answer: a line join style is drawn.

<H3><A NAME="Attributes.5">How do I change the current line cap style?</A></H3>
Use <STRONG>Gfx.SetCapStyle</STRONG> to set the current cap style. The current cap
style is a procedure variable in the context that has a somewhat complicated interface.
Fortunately, the most common kinds of cap style are already predefined in Gfx:
<UL>
<LI><STRONG>Gfx.ButtCap</STRONG> just cuts the line off at its start/end point along
a straight line that passes through the point and is perpendicular to the curve direction
at that point.</LI>
<LI><STRONG>Gfx.RoundCap</STRONG> ends curves with a semicircle. It's as if the curve
had been drawn with a round brush whose diameter matches the current line width.</LI>
<LI><STRONG>Gfx.SquareCap</STRONG> ends curves with half a square. It's as if the curve
had been drawn with a square brush whose side length matches the current line width.</LI>
</UL>
Contexts use butt caps by default and whenever they have been reset. If you need to define
a custom cap style, refer to the interface of module <STRONG>Gfx</STRONG> for details.

<H3><A NAME="Attributes.6">How do I change the current line join style?</A></H3>
Use <STRONG>Gfx.SetJoinStyle</STRONG>. Like with cap styles, Gfx offers a selection
of predefined join styles:
<UL>
<LI><STRONG>Gfx.BevelJoin</STRONG> cuts off the outer corner of two lines meeting
in an angle along a straight line. Not very aesthetic.</LI>
<LI><STRONG>Gfx.RoundJoin</STRONG> replaces the corner by a circular arc that
smoothly joins the outer edges of the lines.</LI>
<LI><STRONG>Gfx.MiterJoin</STRONG> makes the outer edges at a corner continue
until they intersect and fills the interior.</LI>
</UL>
Miter joins look natural and can be rendered reasonably quick and are therefore chosen
as default join style. However, if the angle between two lines becomes very small, the
intersection of their outer edges can be very far away from the original path. It would
be better to use a threshold angle and render bevel joins in these cases. For this reason,
contexts maintain a <EM>style limit</EM> attribute. The maximal distance between
any point rendered by a style and the original path must not exceed half the line width
times the style limit. The style limit can be set with <STRONG>Gfx.SetStyleLimit</STRONG>
and is by default set to 5.
<P>
As with cap styles you may define your own line join styles. However, a detailed description
of the join style interface is beyond the scope of this document. You will gain further
insight by studying the definition of <STRONG>Gfx.JoinStyle</STRONG> and the default
implementations of the predefined styles.

<H3><A NAME="Attributes.7">How do I control the quality of arc and bezier approximation?</A></H3>
Except for a few special cases, rendering arcs and B&eacute;zier curves is very complicated.
Most concrete contexts therefore choose to approximate these curves with straight lines,
which are far easier to handle. The curves are usually subdivided until each part is close
enough to a straight line, where "close enough" means that the maximal distance
from any point on the original curve to the linear approximation is smaller than a given
limit. This limit is stored in the <EM>flatness</EM> attribute of a context and can be
modified with <STRONG>Gfx.SetFlatness</STRONG>. Unlike most other attributes, the
current flatness is measured in device pixels and is independent of the current
transformation matrix. The default flatness is set to one device pixel.

<H3><A NAME="Attributes.8">Why doesn't Gfx let me change attributes within a path?</A></H3>
Between <STRONG>Gfx.Begin</STRONG> and <STRONG>Gfx.End</STRONG>, an attempt
to set any context attribute causes a run-time error. Gfx doesn't allow you to change graphical
attributes within a path because most of them depend on the current transformation matrix
(see <A HREF="#Coordinates.1">Coordinate Systems</A>), which <EM>can</EM> be changed
while inside a path. Now combine this with the fact that a context may render individual
path elements whenever it sees fit, which may be as soon as a curve is specified, when the
path is closed, or any moment inbetween. It is obviously impossible to synchronize changing
attributes and output operations. Context attributes therefore mustn't be modified during
rendering.

<HR>
<H2 ALIGN=CENTER>Text</H2>

<H3><A NAME="Text.1">How do I display a string?</A></H3>
The most convenient way is to call
<PRE>
  Gfx.DrawStringAt(ctxt, x, y, "Hello");
</PRE>
You can then immediately append another string to the one you've just displayed with
<PRE>
  Gfx.DrawString(ctxt, " World!");
</PRE>
Both procedures will display the string using the current fill color and the current font.

<H3><A NAME="Text.2">How can I set the current point manually?</A></H3>
If you should ever need to set the current point manually, call
<PRE>
  Gfx.SetPoint(ctxt, x, y);
</PRE>

<H3><A NAME="Text.3">How do I change the current font?</A></H3>
To set the current font family to "Oberon", style to "Bold" at size 12 call
<PRE>
  Gfx.SetFontName(ctxt, "Oberon-Bold", 12);
</PRE>
You can also create a font instance which is derived from an existing font by applying
an arbitrary transformation matrix. As an example, let's simulate a "Oberon-BoldItalic"
font (which doesn't exist) by shearing an "Oberon-Bold" font, using size 20.
<PRE>
  GfxMatrix.Init(mat, 1, 0, 0.25, 1, 0, 0);	(* shear matrix *)
  Gfx.SetFont(ctxt, GfxFonts.Open("Oberon-Bold", 20, mat));
</PRE>

<H3><A NAME="Text.4">How do I change the current text color?</A></H3>
Since <STRONG>Gfx.DrawString</STRONG> uses the current fill color, set the
current text color by calling <STRONG>Gfx.SetFillColor</STRONG> with the
appropriate color value.

<H3><A NAME="Text.5">Can I convert characters to paths?</A></H3>
Yes, if you have the corresponding outline fonts installed. You can download outline
fonts for Oberon metafonts
<A HREF="ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/Contrib/Metafonts/">here</A>
Once these outline fonts are available on your system, Gfx will use them automatically if you request a
font instance for which no matching Oberon raster font is found or if you explicitly request to
use character outlines inside a path by calling either of <STRONG>Gfx.ShowAt</STRONG> or
<STRONG>Gfx.Show</STRONG>. These work like <STRONG>Gfx.DrawStringAt</STRONG>
and <STRONG>Gfx.DrawString</STRONG> but can only be called ater a path has been
begun. Instead of always using <STRONG>Gfx.Fill</STRONG> mode, however, they
render characters of a string in the current drawing mode of the path. That means
that you can stroke character outlines, draw patterned characters or use character
shapes as clipping regions.
<P>
The following example fills the characters of the string "Bart" with a pattern of "Bart.Pict"
bitmaps:
<PRE>
  VAR map: GfxMaps.Map; done: BOOLEAN;
  NEW(map); GfxMaps.Load(map, "Bart.Pict", done); ASSERT(done, 110);
  Gfx.SetFillPattern(ctxt, Gfx.NewPattern(ctxt, map, 0, 0));
  Gfx.SetFontName(ctxt, "Oberon-Bold", 64);
  Gfx.Begin(ctxt, {Gfx.Fill});
  Gfx.ShowAt(ctxt, 100, 100, "Bart");
  Gfx.End(ctxt);
</PRE>

<H3><A NAME="Text.6">How can I center a caption?</A></H3>
Use <STRONG>Gfx.GetStringWidth</STRONG> to find out how the current point
would be advanced if a string were drawn and displace the string by half this
vector.

<H3><A NAME="Text.7">Can I use my huge collection of TrueType fonts?</A></H3>
Yes, if you have installed the OpenType type for Oberon available for download
<A HREF="ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/Contrib/OType/">here</A>
and compile the module <STRONG>GfxOType</STRONG> in the Gfx distribution.
Also make sure that the following line is part of your Oberon.Text:
<PRE>
  { FontFormats = { TTF = GfxOType.Install }}
</PRE>
You should then be able to use TrueType fonts just like regular Oberon fonts from
within Gfx.

<H3><A NAME="Text.8">How about my Type1 fonts?</A></H3>
Unfortunately there is no support for Type1 fonts in Gfx at the moment. If you have
a working Type1 rasterizer for Oberon, please don't hesitate and make it available
to Gfx and OType.

<HR>
<H2 ALIGN=CENTER>Coordinate Systems</H2>

<H3><A NAME="Coordinates.1">Where is the coordinate origin of a context?</A></H3>
In the lower left corner of the drawable area. This is often equal to <EM>(0, 0)</EM>.

<H3><A NAME="Coordinates.2">How can I move the current coordinate origin?</A></H3>
It is often convenient to move the origin of the coordinate system somewhere else, e.g. if
you plan to describe a graphic that is symmetric around an origin and therefore uses both
positive and negative coordinate values.
<PRE>
  Gfx.Translate(ctxt, dx, dy);
</PRE>
displaces the coordinate origin by the vector <EM>(dx, dy)</EM> for all following
rendering operations. This is effected by prepending a translation matrix to the
current transformation matrix of the context.

<H3><A NAME="Coordinates.3">What is the default unit of a context?</A></H3>
The default unit of a context corresponds to an Oberon Display unit, which corresponds
to 1/91.44 dots per inch.

<H3><A NAME="Coordinates.4">How do I scale the current coordinate system?</A></H3>
By calling one of
<PRE>
  Gfx.Scale(ctxt, sx, sy);
  Gfx.ScaleAt(ctxt, sx, sy, x, y);
</PRE>
all following operations will use a scaled coordinate system. The second call uses the
given point instead of <EM>(0, 0)</EM> as an invariant origin for the transformation.

<H3><A NAME="Coordinates.5">How do I rotate the current coordinate system?</A></H3>
With one of
<PRE>
  Gfx.Rotate(ctxt, sin, cos);
  Gfx.RotateAt(ctxt, sin, cos, x, y);
</PRE>
E.g. a counter-clockwise rotation by 90&deg; has <EM>sin=1</EM> and <EM>cos=0</EM>.
Gfx expects sine and cosine of an angle and not the value of the angle itself to make special
cases more efficient.

<H3><A NAME="Coordinates.6">Can I specify other transformations to the current coordinate system?</A></H3>
Yes, if you can describe the transformation with a three-row, two-column matrix. This includes any combination
of translation, scaling, rotation and shearing. Prepend this matrix to the current transformation matrix with
<PRE>
  Gfx.Concat(ctxt, mat);
</PRE>
and it affects all following operations.

<H3><A NAME="Coordinates.7">How can I undo the changes I've made to the current coordinate system?</A></H3>
By saving the current transformation matrix before modifying the coordinate system and later
restoring it:
<PRE>
  VAR save: GfxMatrix.Matrix;
  save := ctxt.ctm;
  ...
  Gfx.SetCTM(ctxt, save);
</PRE>

<H3><A NAME="Coordinates.8">How can I return to the original coordinate system?</A></H3>
By calling <STRONG>Gfx.ResetCTM</STRONG> or <STRONG>Gfx.Reset</STRONG>, where
the latter also resets the clip region and all context attributes. If you didn't set up the context
yourself, you should rather save and restore the CTM instead because your caller might have
modified the coordinate system before calling you.

<H3><A NAME="Coordinates.9">What are the dimensions of a device pixel?</A></H3>
The dimensions of a device pixel can be found by resetting the current transformation
matrix, inverting the default CTM and applying it to a unit vector.

<HR>
<H2 ALIGN=CENTER>Bitmaps</H2>

<H3><A NAME="Bitmaps.1">Why can't I just draw Oberon pictures?</A></H3>
For a long time, Gfx has indeed been working with regular Oberon pictures. However,
they only support indexed bitmap formats with a depth of eight, which proved to be
too restrictive, especially in the context of filtered bitmap transformations. So now
there is a module <STRONG>GfxMaps</STRONG>, which is part of Gfx and offers
a lot of advanced features.

<H3><A NAME="Bitmaps.2">What are bitmap formats?</A></H3>
Gfx bitmaps are not restricted to indexed formats. They can include components
holding RGB information, palette index numbers, and alpha values. The number of bits
used per pixel may vary as well. All information about what is stored in a pixel
and how it is stored is gathered in a <EM>bitmap format</EM>. Several bitmap
formats are predefined and are exported as global format variables from
<STRONG>GfxMaps</STRONG>:
<UL>
<LI><STRONG>A1</STRONG> stores exactly one bit of alpha information per pixel.
This corresponds to the patterns used for Oberon raster fonts.</LI>
<LI><STRONG>A8</STRONG> stores 8 bits of alpha information per pixel, i.e. each
pixel stores how opaque it is with 0 being fully transparent and 255 being fully
opaque.</LI>
<LI><STRONG>I8</STRONG> corresponds to the format used for Oberon pictures.
Each byte represents one pixel and its value is used as an index into a color lookup
table (also called <EM>palette</EM>).</LI>
<LI><STRONG>BGR555</STRONG> and <STRONG>BGR565</STRONG> are
so called <EM>hi-color</EM> formats, using two bytes per pixel. Within a pixel
blue, green, and red values are stored using 5 bits each or 5 bits for blue and red
and 6 for green.</LI>
<LI><STRONG>BGR24</STRONG> occupies three bytes per pixel, the first of which
holds the blue component, the second the green component, and the third the red
component.</LI>
<LI><STRONG>BGRA32</STRONG> is similar to <STRONG>BGR24</STRONG>
but occupies four bytes per pixel, the fourth byte being used to store an alpha
value for each pixel.</LI>
<LI><STRONG>PixelFormat</STRONG> is a special format which is compatible
with the <STRONG>Pixel</STRONG> type also exported from <STRONG>GfxMaps</STRONG>.
Pixel values are used when accessing or modifying bitmaps.
</UL>
It is strongly suggested that you use one of these predefined formats whenever
you create a bitmap with <STRONG>GfxMaps.Create</STRONG>.

<H3><A NAME="Bitmaps.3">Can I define my own bitmap formats?</A></H3>
Answer: yes, you can, if you are willing to accept a small performance hit. Apart
from information about which components are available and how many bits per
pixel are used, a format also contains two procedures <STRONG>pack</STRONG>
and <STRONG>unpack</STRONG>. They are supposed to store (pack) a pixel at
a given address and to load (unpack) a pixel when called. Call
<STRONG>GfxMaps.InitFormat</STRONG> to initialize all relevant fields of
your custom format. By the way, the performance hit comes from the fact
that the pack and unpack procedures are often bypassed for pixel transfers
between predefined formats, which cannot be done for formats defined
outside <STRONG>GfxMaps</STRONG>.

<H3><A NAME="Bitmaps.4">What is a blend operator?</A></H3>
A blend operator is a generalization of the mode parameter used by many Oberon
Display procedures. It defines how source pixels affect destination pixels. Two
very often used blend operators are exported as global variables from
<STRONG>GfxMaps</STRONG> and should be used wherever appropriate:
<UL>
<LI>With <STRONG>GfxMaps.SrcCopy</STRONG>, source pixels just replace
whatever was stored in the destination pixels before. This corresponds to
the <EM>replace</EM> mode in the Oberon Display module.</LI>
<LI>With <STRONG>GfxMaps.SrcAlpha</STRONG>, the alpha component
of the source pixel defines how much the source pixel affects the destination
pixel. If the source pixel is transparent (alpha=0), the destination pixel remains
unaffected. If the source pixel is opaque (alpha=255), it fully replaces the
destination pixel. Otherwise, source and destination pixels are blended
according to the alpha value of the source pixel.</LI>
</UL>

<H3><A NAME="Bitmaps.5">Can I define custom blend operators?</A></H3>
Yes! Just declare a variable of type <STRONG>GfxMaps.BlendOp</STRONG>
and set its blend procedure to a procedure implementing your blending
scheme. The blend procedure gets a source and a destination pixel and
must store its result in a result parameter. However, because
<STRONG>GfxMaps</STRONG> uses optimized code for its predefined
blend operators which bypasses calling the blend procedure, you may
find that using your custom blend operator is slower than using one
of the builtin operators.

<H3><A NAME="Bitmaps.6">What is a filter?</A></H3>
A filter is an extension of a blend operator. In addition to blending source
and destination pixels, it offers procedure variables for shifting and
scaling pixel rows and columns, which makes them suitable to implement
bitmap transformations. The problem with bitmap transformations is that
fast algorithms normally suffer from poor quality and that smarter algorithms
producing better quality are much slower. Filters allow <STRONG>GfxMaps</STRONG>
to leave that decision up to its callers. It offers two sets of filter procedures
and two predefined filters exported as global variables:
<UL>
<LI><STRONG>NoFilter</STRONG> does what is known as a box filter
or a nearest neighbor filter. It's still called <STRONG>NoFilter</STRONG>
because its results correspond to what a naive implementation that has
never even heard of filtering would achieve.</LI>
<LI><STRONG>LinearFilter</STRONG> uses bilinear filtering for scaling and
interpolates linearly when shifting by fractional amounts. It's much slower
but also looks better (except for a tendency to blur its result).</LI>
</UL>

<H3><A NAME="Bitmaps.7">And I can define custom filters, too?</A></H3>
Yes. Call <STRONG>GfxMaps.InitFilter</STRONG> with a blend procedure and appropriate
shift and scale procedures and you have your custom filter. You might want to take a look
at the implementation of the predefined filter procedures first, though.

<H3><A NAME="Bitmaps.8">I'd still like to use existing Oberon pictures. How?</A></H3>
If you have an Oberon picture stored in a file, you can directly load it into a Gfx map
using the following code:
<PRE>
  VAR map: GfxMaps.Map; done: BOOLEAN;
  NEW(map); GfxMaps.Load(map, "MyImage.Pict", done);
  IF done THEN ... END;
</PRE>
<EM>Note:</EM> this only works if your Oberon.Text has been augmented by a line
<PRE>
  { ImageFormats = { Pict = GfxPictures.Install }}
</PRE>
Alternatively, if the picture is already available as a structure in memory, it can be
converted to a Gfx bitmap like this:
<PRE>
  VAR map: GfxMaps.Map;
  NEW(map); GfxPictures.PictToMap(pict, map);
</PRE>
Bear in mind that the picture contents are copied. If you later need to convert the
map back to a picture, you can do so with <STRONG>GfxPictures.MapToPict</STRONG>.
Converting a Gfx map to a picture requires an additional palette parameter to
select the set of colors that will be used in the picture. If the map is in
<STRONG>GfxMaps.I8</STRONG> format (e.g. because it is a converted picture),
you should probably use the palette from the map format. If the picture
needs to be displayed, consider using <STRONG>GfxMaps.DefaultPal</STRONG>
which contains exactly the same colors as the Oberon display. Finally, if the
source bitmap is in a hi-color or true-color format, you might want to calculate
a palette that best represents the colors used in the bitmap with
<STRONG>GfxMaps.ComputePalette</STRONG> and use this palette for
the conversion.

<H3><A NAME="Bitmaps.9">And while we're at it, how about Oberon patterns?</A></H3>
Studying the definition of <STRONG>GfxPictures</STRONG> reveals a procedure
<STRONG>PatternToMap</STRONG> which converts an Oberon pattern to a
Gfx map in <STRONG>GfxMaps.A1</STRONG> format. The conversion from
Gfx bitmaps to Oberon patterns is not supported.

<H3><A NAME="Bitmaps.10">How can I integrate my images in XYZ format into Gfx?</A></H3>
Since Gfx bitmaps support so many different formats, it would be nice to be able
to load and store image files in all the dozens of file formats that exist. Currently
only Oberon picture files are supported, but it's easy to add other file formats if
you follow these steps:
<OL>
<LI>Implement procedures for loading and storing a bitmap in the new file format.</LI>
<LI>Add a command procedure (e.g. "Install") to your module which sets the
global procedure variables <STRONG>GfxMaps.LoadProc</STRONG> and
<STRONG>GfxMaps.StoreProc</STRONG> to your load and store procedures.</LI>
<LI>Add a line for installing your command to your Oberon text:
<PRE>
  ImageFormats = {
    Pict = GfxPictures.Install
    Xyz = GfxXyz.Install
  }
</PRE></LI>
</OL>

<HR>
<H2 ALIGN=CENTER>Clipping</H2>

<H3><A NAME="Clipping.1">What is the initial clipping region of a context?</A></H3>
This depends on the context type but usually the clipping region is a rectangle around
the drawable area of the context.

<H3><A NAME="Clipping.2">How do I change a context's default clipping region?</A></H3>
Many context modules export procedures for setting the default clipping region of
a context to a rectangle or a given region. The default clipping region is the one that
is reestablished when <STRONG>Gfx.ResetClip</STRONG> or <STRONG>Gfx.Reset</STRONG>
is called.

<H3><A NAME="Clipping.3">How do I convert a gadget mask to a clipping region?</A></H3>
By enumerating the mask and adding the enumerated rectangles to the region:
<PRE>
  VAR R: GfxRegions.Region;
  
  PROCEDURE AddRect (x, y, w, h: INTEGER);
  BEGIN
    GfxRegions.AddRect(R, x, y, x + w, y + h)
  END AddRect;
  
  PROCEDURE MaskToRegion (mask: Display3.Mask; reg: GfxRegions.Region);
  BEGIN
    R := reg; GfxRegions.Clear(R);
    Display3.EnumRect(mask, mask.X, mask.Y, mask.W, mask.H, AddRect)
  END MaskToRegion;
</PRE>

<H3><A NAME="Clipping.4">How can I change the current clipping region?</A></H3>
The current clipping region of a context can be intersected with an arbitrary path by
rendering the path in <STRONG>Gfx.Clip</STRONG> mode. The following code snippet
restricts all following rendering operations to the interior of the letter "A" within a
circle:
<PRE>
  Gfx.SetFontName(ctxt, "Oberon-Bold", 128);
  Gfx.Begin(ctxt, {Gfx.Clip});
  Gfx.ShowAt(ctxt, 100, 100, "A");
  Gfx.End(ctxt);
  Gfx.DrawCircle(ctxt, 150, 150, 50, {Gfx.Clip});
</PRE>

<H3><A NAME="Clipping.5">How can I undo the changes I've made to the current clipping region?</A></H3>
Save the current clipping region before you modify it and restore it later:
<PRE>
  Gfx.SaveClip(ctxt);
  Gfx.Begin(ctxt, {Gfx.Clip}); ... ; Gfx.End(ctxt);
  ....
  Gfx.RestoreClip(ctxt);
</PRE>

<H3><A NAME="Clipping.6">How can I return the the clipping region to its initial state?</A></H3>
By calling <STRONG>Gfx.RestoreClip</STRONG>.

<HR>
<H2 ALIGN=CENTER>Paths</H2>

<H3><A NAME="Paths.1">How can I access the elements in the current path?</A></H3>
The module <STRONG>GfxPaths</STRONG> offers two methods for accessing the elements
stored in a path. The first is to open a path scanner (<STRONG>GfxPaths.Scanner</STRONG>)
on the path and advance from element to element. The second is to enumerate all path
elements by passing an enumerator procedure to <STRONG>GfxPaths.Enumerate</STRONG>.
The procedure is then called for each element in the path. While the enumeration method
offers less control over the traversal, it can be used to visit flattened paths and elements
or natural splines, which cannot be stored in paths at all.
<P>
If you access the elements in the current path of a context, bear in mind that the
<STRONG>Gfx.Record</STRONG> mode must have been set and that the current
context matrix has been applied to all coordinates.

<H3><A NAME="Paths.2">How to calculate bounding box and length of path?</A></H3>
The module <STRONG>GfxPaths</STRONG> offers useful procedures for finding
out details about a path. <STRONG>GfxPaths.GetBox</STRONG> returns the bounding
box for all elements in the path and <STRONG>GfxPaths.Length</STRONG>
returns the length of a (flattened) path.

<H3><A NAME="Paths.3">How can I modify a recorded path?</A></H3>
Due to the internal storage structure of paths, there are no procedures for
altering individual path elements once a path is built althouth you can apply
a transformation matrix to a path or reverse it. Other modifications can be
achieved by constructing a temporary path and copying back its contents to
the original path afterwards.

<H3><A NAME="Paths.4">How to render an edited path?</A></H3>
<STRONG>Gfx.DrawPath</STRONG> is one possibility. The current path
can be drawn with <STRONG>Gfx.Render</STRONG>.

<HR>
<H2 ALIGN=CENTER>What next?</H2>

<H3><A NAME="Next.1">Are there other sources of information?</A></H3>
Most of the topics touched in this document are presented with a bit more structure
in the <A HREF="GfxOverview.html">Gfx Overview</A>. Other than that, most
features are also discussed where they are defined in a module interface. For the
deepest insight, you should look directly at the source code, which is part of the
distribution. If all this doesn't help, send inquiries and suggestions to the
<A HREF="mailto://oswald@inf.ethz.ch">Institute for Computer Systems</A>
at ETH Z&uuml;rich.

<H3><A NAME="Next.2">Who do I report bugs and suggestions to?</A></H3>
Directly to the author of Gfx, <A HREF="mailto://oswald@inf.ethz.ch">Erich Oswald</A>.

<H3><A NAME="Next.3">How can I contribute to Gfx?</A></H3>
<UL>
<LI>Send a mail to <A HREF="mailto://oswald@inf.ethz.ch">oswald@inf.ethz.ch</A>
and tell me what you think.</LI>
<LI>Use it in a project and send bug reports and suggestions to
<A HREF="mailto://oswald@inf.ethz.ch">oswald@inf.ethz.ch</A>.</LI>
<LI>Implement a bitmap import/export module for GIF, JPG, PNG, TGA, TIFF, PIC, BMP
or whatever else excites you and make it available.</LI>
<LI>Implement a Type1 font rasterizer and make it available.</LI>
<LI>Make the world a better place.</LI>
</UL>

<HR>
<FONT SIZE=-1><EM>Erich Oswald Apr 1999</EM></FONT>

</BODY>
</HTML>
