<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML Level 2.0 2//EN"><!-- Generated by Text2HTMLGIF (afi, ejz)--><HTML><HEAD><META NAME="Author" CONTENT="Andre Fischer"><TITLE>Oberon System 3 Games</TITLE></HEAD><BODY><H1><CENTER>Oberon System 3 Games</CENTER></H1><HR><CENTER><B>[ Text | <A HREF="Games.Contents.html">Contents</A> | <A HREF="Games.Index.html">Index</A> | <A HREF="Big.Index.html">Master index</A>]</B></CENTER><BR><BR><H1><A NAME="0"></A>Introduction to the card games - by Patrick Saladin</H1>As every operating system has at least one solitaire to offer, I decided to write a framework that would permit anyone to develop such games for Oberon System 3.<P>I began with <A HREF="#Solitaire">Solitaire</A> because it is a very simple game. Then I wrote <A HREF="#Spider">Spider</A> based on a native Amiga Oberon version I did some years ago. The latest (and maybe last) solitaire I did, was <A HREF="#Freecell">Freecell</A>. I think these three examples suffice to show how to implement one's own, preferred solitaires. For a more or less complete overview of the functionality of this framework, refer to the section "How To Write A New Card Game" below, and study the source codes.<P>To start any of the three games open the <CALL CMD="Desktops.OpenDoc CardGames.Panel"><FONT COLOR=FF0000>CardGames.Panel</FONT></CALL>.<P><B>Backgounds</B> - choose one of nine card backgrounds<B><BR>Open Help</B> - opens this text<P>Clicking on:<BR>&nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/Games1.gif" OBJECT="GamesObjs.1"> opens a Solitaire game<BR>&nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/Games2.gif" OBJECT="GamesObjs.3"> opens a Spider game<BR>&nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/Games3.gif" OBJECT="GamesObjs.5"> opens a Freecell game<P><B>Draws</B> - number of cards to be drawn to the deck in Solitaire<P>I hope, you willl have a lot of fun with these three games.<P><HR><H1><A NAME="Solitaire"></A>Solitaire - Release 1.3</H1><B> </B>An Oberon System 3 version of the maybe most famous solitaire game Solitaire, created by Wes Cherry and found in Microsoft Windows 95 and also provided with several other operating systems.<P><H2><A NAME="1"></A>Rules</H2>The gameboard has three areas: the deck in the upper left corner, four "suit" stacks in the upper right and a row of seven "row" stacks below the deck and suit stacks. The number of cards in each row stack increases from one to seven, from left to right. The top card of each row stack is face up, the other cards are face down.<P>The object of the game is to move all the cards to the four suit stacks in ascending order from ace to king. For example, you can place the two of hearts on the ace of hearts.<P>To move a card (or a stack of cards) from one place to another, point to it, press the left mouse key, drag the card(s) to the final destination and release the key. The program moves the card(s) if it is a legal move or does nothing if the card(s) do not fit.<P>During the game, you will be building row stacks by dragging a card or a stack of cards and dropping it on the top card of another row stack. Cards in a row stack are stacked in descending order, alternating between red cards and black cards. For example, you can place the two of hearts on the three of clubs.<P>If in the process, you uncover a face down card in a row stack, turn it face up with a left mouse key click. A stack may also be built on an empty row stack provided it starts with a king.<P>When you made all the possible plays, click the deck to begin turning over cards in packets of three. The card that is face up on the deck is always available for play. When the end of the deck is reached, turn it over and continue to draw cards.<P>The mouse pointer changes to a 'pointing hand' as soon as you are pointing to a card you are allowed to move.<P>To move a card to one of the four suit stacks, you can also click with the middle mouse key on the card instead of using drag and drop. Here also, the program moves the card to the appropriate stack or does nothing if the card doesn't fit on any of the stack's top card.<P>There are two game control buttons in the menu bar:<P>[New] - Throws away the current game and starts a new one.<BR>[Undo] - Undo the last move. The Undo function can be repeated back to the beginning of the game.<P><H2><A NAME="2"></A>Differences with the MS Solitaire (TM)</H2><UL><BR><LI>A card placed on a suit stack cannot be moved back to a row stack.<LI>Cards on the deck are turned over in packets of 3 only.<LI>This Solitaire has a more powerfull Undo function. The MS Solitaire allows a single Undo.<LI>This Solitaire has no scoring system and no timing.</UL><P><HR><H1><A NAME="Spider"></A>Spider - Release 1.1</H1>An Oberon System 3 version of the Spider game (coming with SUN's OpenLook). The following text is adapted from an original text written by Donald R. Woods of Sun Microsystems, Inc.<P>Spider is a variant of solitaire using a double deck of cards, which is more complex and also more challenging than the previous one.<P><H2><A NAME="3"></A>Rules</H2>The gameboard consists of the stack of undealt cards in the upper left corner, eight suit stacks in the upper right corner and of the remaining cards of a double deck, which are dealt in ten columns at the beginning of the game.<P>The object of the game is to build a stack of the same suit from King to Ace and to move completed stacks from the table to the suit stacks above. When all eight stacks have been built and removed, you have won the game. A more challenging version of this is to leave all eight stacks on the table until done instead of moving the completed ones immediately to the stacks above.<P>One may move the next lower card onto a card of the same or different suit; however, one may only move contiguous cards of the same suit as a group. For example, one may move the five of spades onto either a six of spades or a six of hearts. Moving the five of spades onto the six of spades is a better move since this pair of cards may be moved as a group, whereas the five of spades, six of hearts group may not. Also, moving the four of spades onto the six of spades is not a legal move. A King may only be moved to an empty column (or moved to the stacks above when the sequence King to Ace is complete) since there are no higher cards than a King.<P>As a general strategy, one should attempt to free a column, or several of them, since this is the most flexible way to move cards around. A empty column is where all cards on the table have been removed. Note: before dealing the next round, all columns have to have at least one card in them.<P>THE HAND. The sixty cards not dealt initially form the "hand". Whenever you wish (typically, whenever you get stuck), you may deal a new row of ten cards from the hand face-up upon the piles. NOTE: You are not allowed to do this if an empty column exists. You must first drop a card on it. Notice that these additional deals tend to introduce discontinuities in the piles; that is, you can get cards covering others that are not next-higher in rank. If you get stuck after having dealt the last of the six additional deals, you have lost.<P><H2><A NAME="4"></A>The program</H2>If you press the middle mouse button anywhere within or below a column of cards, it says you want to move the top cards of that column (top cards: in a row and of same suit). The program looks for a destination column and then moves the cards from the first column to the second. If there is no such legal move, the program does nothing. The lookup strategy is defined as followed:<BR><OL><BR><LI>remove them if they form a completed suit<LI>move them onto a card of the same suit<LI>move them onto a card of a different suit<LI>move them into a space</OL><P>If you instead use the left mouse button to select a card within a column, it says you want to move the card you are pointing at plus any cards covering it. (The program changes the mouse pointer to a 'pointing hand' as soon as you're pointing on a card you are allowed to move.) Then you must move the mouse to another column and release the button. The program moves the selected cards to the destination. The only time you need to use this method (instead of using middle) is if you're moving fewer cards than the maximum permitted.<P>To deal a new round, left key click on the facedown stack in the upper left. Remember that all spaces must be filled before you can deal a new round, except there is no possibility to fill them.<P>There are two game control buttons in the menu bar:<P>[New] - Throws away the current game and starts a new one.<BR>[Undo] - Undo the last move. The Undo function can be repeated back to the beginning of the game.<P><HR><H1><A NAME="Freecell"></A>Freecell - Release 0.9</H1>An Oberon System 3 version of another solitaire game FreeCell, created by Jim Home and found in Microsoft Windows 95.<P><H2><A NAME="5"></A>Rules</H2>The gameboard consists of four free cells in the upper left corner, four suit stacks in the upper right and the deck of cards, which is dealt face-up in eight columns at the beginning of the game (seven cards on each of the first four columns and six on the last four).<P>The object of the game is to move all the cards to the four suit stacks, using the free cells as place holders. To win, you have to build the four suit stacks in ascending order from ace to king. For example, you can place the two of hearts on the ace of hearts.<P>Freecell knows three legal moves:<BR><OL><BR><LI>move to a free cell: any card from the bottom of a column<LI>move to a suit stack: any card from a free cell or from the bottom of a column. The card must be greater in rank than the card in the suit.<LI>move to the bottom of a column: any card from a free cell or from the bottom of another column, provided the rank of the card is one less than the rank of the card you will place it on, and the colors of the cards are different. For example, you can move a black three onto a red four. Any card can be moved to an empty column.</OL><P>To move a card from one place to another, just left click on the card you want to move (it will be highlighted) and then left click the area to which you want to move the card. To cancel a move, simply left click again on the highlighted card.<P>You can move a stack of cards from one column to another if there are enough free cells open. To move a stack, left click the bottom card in the column, then left click the column that you want to move the stack to. The program assumes that you always want to move as many cards as possible to a free column. If you want to move only the top card of a stack to a free column, middle click on the free column instead of left clicking on it.<P>To quickly move a card from a free cell or a column to one of the four suit stacks, simply middle click on the card.<P>There are two game control buttons in the menu bar:<P>[New] - Throws away the current game and starts a new one.<BR>[Undo] - Undo the last move. The Undo function can be repeated back to the beginning of the game.<P><HR><H1><A NAME="6"></A>How to write a new card game</H1><H2><A NAME="7"></A>Introduction</H2>The module Cards provides three basic data structures, needed in every solitaire: Card, Stack and Move. It also contains some basic procedures that operate on these types. Two basic messages to control the games are defined in here as well.<P>This chapter gives you first a description of the data structures and messages and then explains the functionality of each procedure provided by this module.<P><H2><A NAME="8"></A>Data structures</H2><B>Card</B><P>&nbsp; &nbsp; next, prev: Pointer to next, previous card in a list (stack)<BR>&nbsp; &nbsp; face: suit of a card<BR>&nbsp; &nbsp; &nbsp; &nbsp;  <IMG ALT="Cool Oberon Object " SRC="images/Games4.gif" OBJECT="GamesObjs.7"> = 0 (clubs) <IMG ALT="Cool Oberon Object " SRC="images/Games5.gif" OBJECT="GamesObjs.9"> = 1 (spades) <IMG ALT="Cool Oberon Object " SRC="images/Games6.gif" OBJECT="GamesObjs.11"> = 2 (hearts) <IMG ALT="Cool Oberon Object " SRC="images/Games7.gif" OBJECT="GamesObjs.13"> = 3 (diamonds)<BR>&nbsp; &nbsp; nr: card number (0 = Ace, 12 = King)<BR>&nbsp; &nbsp; visible: flag to indicate if a card's surface is visible or not (TRUE = show card's surface)<P><B>Stack</B><P>&nbsp; &nbsp; tail: list of cards in stack. 'tail' marks the end of a list and is not a valid card<BR>&nbsp; &nbsp; 'tail.next' is the top card and 'tail.prev' the last card in the list<BR>&nbsp; &nbsp; do: a block of methods<BR>&nbsp; &nbsp;  - canDrop: checks if 'card' can be dropped on stack 'S'<BR>&nbsp; &nbsp;  - dropCard: drops the given card(s) on stack 'S'<BR>&nbsp; &nbsp;  - moveCard: moves the given card(s) from stack 'self' to stack 'to'<BR>&nbsp; &nbsp;  - undoMove: recovers the latest action done by stack 'S'<BR>&nbsp; &nbsp;  - restoreStack: redraws stack 'S'<BR>&nbsp; &nbsp;  - trackMouse: tracks the mouse until all buttons are released<BR>&nbsp; &nbsp; bgNr: cards background in stack. Valid values are between [0..8]<P><B>Move</B><P>Whenever an action (move, draw, flip, ...) is taken by a stack, you should remember this action. This way, will recover every step taken during the game.<P><B>SimpleMove</B><BR>&nbsp; &nbsp; to: stack, cards have been moved to<BR>&nbsp; &nbsp; card: card dropped on stack<P>A simple move is used to indicate a drop of cards to another stack.<P><B>CollectMsg</B><BR>&nbsp; &nbsp; tail: list of collected cards<P>This message is broadcast to collect all cards in a stack. Each stack has to append its cards to the tail of the message.<P><B>UndoMsg</B><BR>&nbsp; &nbsp; time: timestamp of the move<BR>&nbsp; &nbsp; stack: stack that did the latest move<P>This message is broadcast to determine, which stack did the latest move. Each stack has to check the message timestamp. If the stack has a more recent move (move timestamp is greater than that of the message), it must set the stack field to itself and must assign the timestamp of its move to the time field.<P><B>BGMsg</B><P>&nbsp; &nbsp; bgNr: background number<P>This message is broadcast to change the background of all the cards in a stack. Assign the background number to the corresponding field in the stack.<P><H2><A NAME="9"></A>Procedures</H2>First, three procedures not related to any data structure but often used to implement card games.<P><B>Random</B><BR>&nbsp; &nbsp; range: upper limit of range (not including this number)<BR>&nbsp; &nbsp; return: random number<P>Returns a random number in range [0..range[<P><B>Shuffle</B><BR>&nbsp; &nbsp; tail: list of cards to shuffle<P>As the name implies, this procedure shuffles the given list of cards. Remember 'tail' is not a valid card and is only used as a sentinel.<P><B>TrackMove</B><BR>&nbsp; &nbsp; M: Oberon.InputMsg received by stack's handler<BR>&nbsp; &nbsp; x, y: lower left corner of top card (completely visible) in stack 'self'<BR>&nbsp; &nbsp; self: stack, the selected cards belong to<BR>&nbsp; &nbsp; card: first card in a list of cards the user want to move<BR>&nbsp; &nbsp; draw, fade: procedures to draw, fade tracking rectangle<P>This is a standard procedure to track the mouse pointer and a list of selected cards. While tracking, TrackMove calls the procedures draw and fade with the given parameters x, y and card. If the user releases all the mouse buttons, the procedure checks, only if the left mouse button was being pressed (this means the user wants to drop the cards on the stack right under the cursor's current position). It checks if it is possible to drop the given cards on this stack and if so, moves the cards from stack 'self' to this stack by calling method 'dropCard' of stack 'self'.<P><H3><A NAME="10"></A>Procedures on card</H3>The following procedures are related to data structure Card. Card is not a very complex data structure, so there are not many procedures one can think of implementing.<P><B>DrawCard</B><BR>&nbsp; &nbsp; R: Display3.Mask - contains clipping region<BR>&nbsp; &nbsp; card: card to draw<BR>&nbsp; &nbsp; x, y, w, h: rectangle to draw card in<BR>&nbsp; &nbsp; bgNr: background number if card is not visible<P>Draws the given card into the given rectangle (x, y, w, h)<P><B>NewCard</B><BR>&nbsp; &nbsp; suit: card suit<BR>&nbsp; &nbsp; nr: card number<BR>&nbsp; &nbsp; visible: if card is visible or not<BR>&nbsp; &nbsp; return: returns the new allocated card<P>Procedure to allocate a new card. The given parameter will be assigned to the corresponding fields in the card data structure.<P><B>CloneCard</B><BR>&nbsp; &nbsp; card: card to clone<BR>&nbsp; &nbsp; return: new, cloned card<P>This procedures allocates a new card and copies the value of the given card.<P><B>WriteCard</B><BR>&nbsp; &nbsp; R: file to write card values to<BR>&nbsp; &nbsp; card: card to write to file<P>Stores the values of the given card to the given file. IF card is NIL, the value -1 will be written to the file.<P><B>ReadCard</B><BR>&nbsp; &nbsp; R: file to read card value from<BR>&nbsp; &nbsp; card: read card<P>Reads in a card from the file. If it reads -1, NIL will be returned; otherwise a new card is allocated.<P><B>NewTail</B><BR>&nbsp; &nbsp; return: new allocated tail<P>Allocates a new sentinel of a card list.<P><H3><A NAME="11"></A>Procedures on stack</H3>The cards of a stack are stored in a double linked list. As their type of list is a bit more complex than simple linked list, I wrote three procedures that make the handling of cards and lists much easier.<BR>A stack always has a tail to which all the cards are linked. Field 'tail.next' is the top card of a stack and field 'tail.prev' the last card in a list of cards. If you want to remove a list of cards, it is sufficient to give the last card in this list (you just can take cards from the top of a stack). Free cards (not belonging to any stack) are managed in a ring of reversed order. The top card can be reached by field 'card.prev'.<P><CENTER><BR><IMG ALT="Cool Oberon Object " SRC="images/Games8.gif" OBJECT="GamesObjs.15"><BR>This figure shows how cards are linked in a stack (left) and in a list of free cards (right)<BR></CENTER><BR> <B>IsEmpty</B><BR>&nbsp; &nbsp; tail: list to check<BR>&nbsp; &nbsp; return: TRUE if list is empty<P>Checks if the given list is empty or not. Empty means the list consists only of the sentinel 'tail'.<P> <B>RemoveCard</B><BR>&nbsp; &nbsp; tail: list to remove card(s) from<BR>&nbsp; &nbsp; card: last card in the list of cards to remove<P>Removes all the cards in the given list (by tail). Returns a list of removed cards. The list starts with 'card' and ends with 'tail.next' and is of reversed order (stack's top card is now the last card in this list).<P> <B>AppendCard</B><BR>&nbsp; &nbsp; tail: list to append card(s) on<BR>&nbsp; &nbsp; card: list of cards to append<P>This procedure does the opposite of RemoveCard: it appends the cards in the list (specified by 'card') to the list (given by 'tail'). 'card.prev' will be the top card of the stack (= 'tail.next') and 'card' will be somewhere in the middle or at the end of the list (by 'tail').<P><H3><A NAME="12"></A>Procedures on move</H3>There are two procedures to handle Moves. As Move covers fields to manage history, these procedures should be used to add, clear stacks actions.<P> <B>AppendMove</B><BR>&nbsp; &nbsp; S: stack the move belongs to<BR>&nbsp; &nbsp; M: move to append to the stack<P>Appends the given move to the list of moves of this stack and assigns actual time to the move's time field.<P> <B>ClearMove</B><BR>&nbsp; &nbsp; S: stack to clear move list of<P>Clears all moves of the given Stack.<P><H3><A NAME="13"></A>Basic Methods</H3>Description of basic procedures assigned to the basic method block 'methods'. These procedures can (must) be written over, when you implement a new type of stack.<P> <B>CanDropCard</B><BR>&nbsp; &nbsp; S: stack the card should be dropped on<BR>&nbsp; &nbsp; card: card you want to drop on stack<BR>&nbsp; &nbsp; return: TRUE if card can be dropped on stack, FALSE otherwise<P>This method is used by the framework to check if the user is allowed to drop the selected card(s) on this stack. The result depends on the solitaire's rules.<P> <B>DropCard</B><BR>&nbsp; &nbsp; S: stack top card on<BR>&nbsp; &nbsp; card: card to drop on stack<P>Appends all cards in list ('card') to stack 'S' and redraws the stack.<P> <B>MoveCard</B><BR>&nbsp; &nbsp; self: stack to take cards from<BR>&nbsp; &nbsp; to: stack to put cards on<BR>&nbsp; &nbsp; card: last card in list of cards to move (starts with top card of stack 'self')<BR>&nbsp; &nbsp; undo: flag to indicate if move is an undo move<P>This method is called to move cards from stack 'self' to stack 'to', where the list of cards to move is specified by 'card'. This implementation moves the cards and appends a SimpleMove to the move list of stack 'self' if flag 'undo' is set to FALSE.<P> <B>UndoMove</B><BR>&nbsp; &nbsp; S: stack to move cards to<BR>&nbsp; &nbsp; M: move to recover<P>This method is called to recover a move. This implementation handles only SimpleMove. Whenever you define new type of moves, you have to extend this method in your own module.<P> <B>DrawSrack</B><BR>&nbsp; &nbsp; S: stack to redraw<BR>&nbsp; &nbsp; M: Display3.Mask - contains clipping region<BR>&nbsp; &nbsp; x, y, w, h: rectangle to draw stack in<P>This method is called whenever a stack needs to be redrawn (Display.DisplayMsg). This implementation draws a stack top card if the stack is not empty.<P> <B>TrackMouse</B><BR>&nbsp; &nbsp; S: stack that received Oberon.InputMsg<BR>&nbsp; &nbsp; M: Oberon.InputMsg received by stack handler<P>This method is called whenever the mouse pointer enters the stack. Set M.res to a value greater than -1, if you handled the message or left it, so the framework can take a default action. As this implementation does nothing, the default behavior will be applied.<P><H3><A NAME="14"></A>Stack-object procedures</H3>Now I would like to explain the standart procedures needed to implement an Oberon System 3 object. As a stack is nothing but a visible gadget, one must implement certain procedures.<P> <B>CopyStack</B><BR>Copies all stack values as well as all cards linked to field 'tail'.<P> <B>StackHandler</B><BR>The object handler does a lot of work for you and is the heart of the framework. I tried to react on messages in such a manner that you never have to spend a lot of time implementing your own handler (this work is delegated to the methods).<BR>A few messages cannot be handled efficiently in a global sense, so you have to react on some of them by yourself. These messages are Objects.AttrMsg and Objects.CopyMsg. You also have to implement the CollectMsg and Objects.FileMsg, if you have more than one list of cards in your stack.<BR>The whole rest of messages should be handled in a proper way, and if there's a malfunction, check your implementation of the methods first and be sure you understood their functionality. Never change this default handler &amp; methods in this module. Should there be an error or functionality missing in Cards.Mod, please let me know, I will try to fix it.<BR>Printing is not handled by this framework, so if you want to print a stack, react on Display.PrintMsg, too. I might have time to work on this in future (may result in an additional method, I think).<P> <B>InitStack</B><BR>Initialize fields of a default stack. Call this procedure within your own initialize procedure.<P> <B>NewStack</B><BR>Allocates, initializes a new stack object and assigns it to 'Objects.NewObj'.<P><H2><A NAME="15"></A>Commands</H2>This module has two commands to offer:<P> <B>SetBG</B><BR>Takes the background number as parameter and broadcasts a BGMsg.<P> <B>Undo</B><BR>Recovers latest action by broadcasting an UndoMsg.<P><HR><H1><A NAME="MineSweeper"></A>MineSweeper - Version 1.2</H1>An Oberon System 3 version of the original MineSweeper written by Robert Donner and Curt Johnson, and found in Microsoft Windows 95. This one was created by Markus D&#228;twyler and Patrick Saladin.<P>Start the game with <CALL CMD="Desktops.OpenDoc My.Game(MineSweeper.NewDoc)"><FONT COLOR=FF0000>Desktops.OpenDoc My.Game(MineSweeper.NewDoc)</FONT></CALL>.<P><H2><A NAME="16"></A>Rules</H2>The object of this game is to find all the hidden mines in a mine field as quickly as possible without uncovering any of them. The mine field is divided into square boxes and each box knows how many mines there are in the neighbouring boxes. By combining the given pieces of information it should be possible to find most of the mines. For the rest, you still need a lucky hand (just like in real life!).<BR>The game is over when either the player taps on a mine (which is mostly the case) or all mines are marked with a flag or all boxes with no mines are covered up.<P>The game's main view is divided in two parts. The left part shows time passed since the player did his first action on the field (covering up a box or setting a flag). The second field shows how many flags the player has to set to end the game. The right part shows the minefield itself. There the player can set the flags and try to cover up the boxes.<P><H2><A NAME="17"></A>Game settings</H2><B>[New]</B> - starts a new game (this button appears in the menu bar and in the panel). The game takes it old settings (width, height &amp; number of mines). The game settings can be adjusted with the sliders.<P><B>[Pause]</B> - pauses the game. During the break, time will stop and the minefield is fully covered, so a player cannot cheat. To continue the game press the pause button again or else start a new game with the New button.<P><B>Sliders</B> - The sliders and text fields control the settings of the game. The left slider controls the width of the minefield, the middle one controls its height and the right one controls the number of mines in the minefield. The player can either choose a value using the sliders or by typing in a correct number in the corresponding text fields. The correct values for the fields are:<P>&nbsp; &nbsp; width: 8 to 30<BR>&nbsp; &nbsp; height: 8 to 16<BR>&nbsp; &nbsp; #mines: 10 to 99, but at most 70% of the number of boxes in the mine field<P><H2><A NAME="18"></A>Controlling the game with mouse key clicks</H2><B>Left mouse key</B> - Covers up the box pointed at if it is in a neutral state. If there are no mines in the neighbouring boxes, it recursively covers up these too. An uncovered box turns from neutral to:<P>&nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/Games9.gif" OBJECT="GamesObjs.17"> covered up. The number tells the player how many mines exist in the neighbouring boxes, if any.<BR>&nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/Games10.gif" OBJECT="GamesObjs.19"> means BAD LUCK!!! The box was hiding a mine which exploded. The game ends and all remaining boxes are uncovered, revealing the location of the other mines. <IMG ALT="Cool Oberon Object " SRC="images/Games11.gif" OBJECT="GamesObjs.21"> appear on boxes where the player made a bad guess, flagging a free box.<P><B>Middle mouse key</B> (??) - When pointing at a covered up box, it counts all the flags on the neighbouring boxes and compares this number with the number shown on the pointed box. If it is the same it recursively covers up the unmarked neighbouring boxes (unmarked means no flag on the box).<P><B>Right mouse key</B> - Toggles between the 3 states, in a ring, of a covered box:<P>&nbsp; &nbsp; neutral - <IMG ALT="Cool Oberon Object " SRC="images/Games12.gif" OBJECT="GamesObjs.23"> a covered box<BR>&nbsp; &nbsp; flag set -<IMG ALT="Cool Oberon Object " SRC="images/Games13.gif" OBJECT="GamesObjs.25"> the player thinks that the box covers a mine<BR>&nbsp; &nbsp; not sure - <IMG ALT="Cool Oberon Object " SRC="images/Games14.gif" OBJECT="GamesObjs.27"> the player is not sure if this box covers a mine or not, but hints at a possible danger<P><HR><H1><A NAME="Scramble"></A>Scramble</H1>An Oberon System 3 version of Scramble, consisting in unscrambling a puzzle. It was created by Emil Zeller.<P>Open a game board by executing <CALL CMD="Desktops.OpenDoc (Scramble.NewDoc)"><FONT COLOR=FF0000>Desktops.OpenDoc (Scramble.NewDoc)</FONT></CALL>. Middle click on the menu bar button captioned "Scramble" to start a game. One of the pieces is removed to allow shifting of the remaining pieces.<P><H2><A NAME="19"></A>Rules</H2>The object of the game is unscramble a puzzle with a picture on one size and numbered pieces on the other side. Middle click on a piece, moves the piece or a group of them in the direction of the empty slot. To reverse a puzzle, middle click on the menu bar button captioned "Num" or "Pict" depending on which side is visible.<P>You can change the puzzles's picture or the number of pieces with one of the following commands:<P><B>Scramble.ChangePict ( pictureName | ^ )</B> replaces the picture of the marked puzzle by the picture specified in the parameter. Clown.Pict, Grapes.Pict and Default.Pict are examples of picture files delivered with the Oberon software. The picture is made apparent but the order of the pieces is kept.<P><B>Scramble.ChangeSize ( m n | ^ )</B> divides the marked puzzle into m * n pieces and unscrambles the puzzle.<P><HR><H1><A NAME="Sokoban"></A>Sokoban</H1>An Oberon System 3 version of Sokoban. This one was created by Emil Zeller.<P>Start the game by opening the document <CALL CMD="Desktops.OpenDoc (Sokoban.NewDoc)"><FONT COLOR=FF0000>Desktops.OpenDoc (Sokoban.NewDoc)</FONT></CALL>.<P><H2><A NAME="20"></A>Rules</H2>Push the yellow garbage cans around using the red pusher which is moved using the keyboard cursor keys. The color of garbage can changes to green when it has reached its correct final position.<P><HR><H1><A NAME="Tetris"></A>Tetris - Version 2.5</H1>An Oberon System 3 version of the well-known russian Tetris game. This one was created by Wolfgang Ibl.<P>To start the game open the <CALL CMD="Desktops.OpenDoc Tetris.Panel"><FONT COLOR=FF0000>Desktops.OpenDoc Tetris.Panel</FONT></CALL>.<P><H2><A NAME="21"></A>Rules</H2><BR><HR><BR>Revised 11 Dec 1996<BR>Installed on 14 Feb 1997<HR></BODY></HTML>