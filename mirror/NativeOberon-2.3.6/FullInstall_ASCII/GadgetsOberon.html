<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML Level 2.0 2//EN"><!-- Generated by Text2HTMLGIF (afi, ejz)--><HTML><HEAD><META NAME="Author" CONTENT="Andre Fischer"><TITLE>Using Gadgets from within Oberon</TITLE></HEAD><BODY><H1><CENTER>Using Gadgets from within Oberon</CENTER></H1><HR><CENTER><B>[ Text | <A HREF="GadgetsOberon.Contents.html">Contents</A> | <A HREF="GadgetsOberon.Index.html">Index</A> | <A HREF="Big.Index.html">Master index</A>]</B></CENTER><BR><BR><H1><A NAME="0"></A>Objective</H1>You have most probably read the tutorial <A HREF="GadgetsUse.html#">Using Gadgets</A> to learn how to create user interfaces interactively and to learn how to define simple behaviors for these interfaces. Having mastered this first and simplest step in using the Oberon System 3 , we invite you to tackle the next and slightly more demanding step, namely that of placing the behavior of the user interface under program control. This entails writing fairly simple procedures in Oberon. To illustrate how to achieve that, code fragments of at most 20 lines are presented and explained in great details. You should regard these fragments as sound theoretical building elements susceptible of integration in workable procedures that you might fancy to develop. To help you to reach your goal even better and faster, all fragments have been implemented in the modules <CALL CMD="Desktops.OpenDoc Examples.Mod"><FONT COLOR=FF0000>Examples.Mod</FONT></CALL> which will be used throughout this tutorial for live demonstrations.<P>Estimated time: 60 minutes.<P>How to prepare your environment}<P>Click on the "Log" icon in your <A HREF="GadgetsIntro.html#Desktop">desktop</A> to open an "Oberon.Log". Move that viewer to the top right corner of your desktop and remember to keep an eye on the Log viewer whilst doing the exercises. Now move this tutorial viewer to the top left corner of the desktop and make sure there is some free space in your desktop. You will use that free space later on as playground. If the playground becomes crowded, you may take the initiative to remove superfluous visual gadgets.<BR>Exercises are not at all confined to those suggested in the tutorial, you would do well to apply the exercises to other objects found on your desktop.<BR>You are now invited to print the source text "Examples.Mod" on paper for consultation, with for example <CALL CMD="Edit.Print LPT1 Examples.Mod ~"><FONT COLOR=FF0000>Edit.Print LPT1 Examples.Mod ~</FONT></CALL> on your local printer.<P><HR><H1><A NAME="1"></A>How to control gadgets with commands</H1><BR>An important feature of the Oberon system is the capability to invoke commands from ordinary text. The Gadgets module exports a number of commands with which you can directly interrogate or change gadgets. These commands are described in the <A HREF="GadgetsUse.html#GadgetsMod">Gadgets module</A> and in <A HREF="GadgetsUse.html#Attributes">Attributes</A>.Several gadgets, such as a <A HREF="GadgetsUse.html#Button">button</A>, have a <I>Cmd</I> attribute, which may contain a command. This command is executed when the gadget is activated (e.g. when a button is clicked). This device enables you to delegate the control of a gadget to yet another gadget.<P>The following panel demonstrates such a situation.<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon1.gif" OBJECT="GadgetsOberonObjs.0"><P>On the right you have a <A HREF="GadgetsUse.html#ColorPicker">color picker</A> and on the left a <A HREF="GadgetsUse.html#Rectangle">rectangle</A> named "Color", i.e. "Color" is the value of its <I>Name</I> attribute. The color picker's <I>Cmd</I> attribute has the value:<BR>&nbsp; &nbsp; &nbsp; &nbsp; <A HREF="GadgetsUse.html#Set">Gadgets.Set</A> Color.Color #Col ~.<P>Now, press the middle mouse key when on the color picker, position the arrow pointer on a color of your choice and release the key. The color of the rectangle is changed. In this case one of the commands exported by the Gadgets module is used, but you are not limited to these.<P>If the construction of new commands is a declared objective of this tutorial and of yourself, one programming problem is that of supplying the commands with information about the environment in which they are executed.<P><H2><A NAME="ParVar"></A>Where to obtain information on the environment</H2>The Gadgets module exports four variables <I>Gadgets.context</I>, <I>Gadgets.executorObj</I>, <I>Gadgets.senderObj</I> and <I>Gadgets.receiverObj</I> supplying the commands with the necessary information on the environment or context.<P><H3><A NAME="Gcontext"></A>Gadgets.context</H3>This global variable is set when a gadget executes a command and contains the <A HREF="GadgetsIntro.html#Context">context or parent</A> of the gadget executing the command. This value may then be used to retrieve gadgets (visual or model gadgets) in that context. Setting this value under program control changes the context.<P>Example: the procedure <I>Gadgets.FindObj(context, name)</I> may be used to look for a named gadget in a given context.<P><H3><A NAME="2"></A>Gadgets.executorObj</H3>This global variable is set when a gadget executes a command and contains the gadget executing the command. This value is also stored in the global variable <I>Oberon.Par.obj</I>.<P><H3><A NAME="3"></A>Gadgets.senderObj</H3>This variable only contains a valid value when a consume operation (drag and drop) is executed. It then contains the gadget being either consumed (e.g. a picture gadget consumed by a button) or dropped onto another gadget (e.g. a button onto a panel).<P><H3><A NAME="4"></A>Gadgets.receiverObj</H3>This variable only contains a valid value when a consume operation (drag and drop) is executed. It then contains the gadget consuming another gadget (e.g. a button consuming a caption).<P><H2><A NAME="5"></A>Alternative environment information sources</H2>The Oberon module exports the variables <I>Oberon.Par.obj</I> and <I>Oberon.Par.frame</I> supplying similar environment information to commands. Also the Objects module supplies an information.<P><H3><A NAME="6"></A>Oberon.Par.obj</H3>This global variable is set when a gadget executes a command and contains the same value as <I>Gadgets.executorObj</I>.<P><H3><A NAME="7"></A>Oberon.Par.frame</H3>This global variable is set when a gadget executes a command and contains (a pointer to) the outermost frame in which the command is executed, i.e. that of the desktop.<P><H3><A NAME="8"></A>Objects.NewObj</H3>This global variable is set when a new object is created with either the procedure <A HREF="#CreateObj"><I>CreateObject</I></A> or the procedure <A HREF="#CreateView"><I>CreateViewModel</I></A>. It then contains the new object. This variable allows other commands or procedures to process the new object, the simplest process being the <A HREF="#GadgetsIntegrate">insertion</A> of the new gadget at the caret position in the display space.<P><HR><H1><A NAME="9"></A>How to control gadgets with messages</H1><BR>The frame messages in the Display module derived from Display.FrameMsg play a central role in inter-frame communication. These build a communication protocol allowing frames to communicate with each other without knowing too much about each other. The latter is crucial if foreign or yet unknown objects are to be integrated into the system and applications need to exchange objects with each other. The <I>FrameMsg</I> is defined as follows:&nbsp; &nbsp; DEFINITION Display; (* excerpt only! *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; FrameMsg = RECORD (Objects.ObjMsg)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F: Frame; (* target frame *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x, y, res: INTEGER<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END Display.<P>F plays a central role in the <I>FrameMsg</I>. It determines the destination or target frame of a message. Often the destination frame of a message is unknown. This happens for example when model update messages are broadcast. In this case the F field is set to NIL.<P>Caution: It is very important to initialize the message fields correctly. The res field common to all messages, is used to store a result value (>= 0). M.res therefore always should be initialized to -1.<P><H2><A NAME="10"></A>Accessing gadgets - Display.SelectMsg</H2>A client module can interrogate and control the display space by broadcasting a <I>SelectMsg</I> to the display space or to a given frame. A list of visual gadgets can be addressed on condition that they all have the same ancestor.<P>&nbsp; &nbsp; DEFINITION Display; (* excerpt only! *)<BR>&nbsp; &nbsp; CONST<BR>&nbsp; &nbsp; &nbsp; &nbsp; get = 0; set = 1; reset = 2;<BR>&nbsp; &nbsp; TYPE<BR>&nbsp; &nbsp; &nbsp; &nbsp; SelectMsg = RECORD (FrameMsg)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id: INTEGER;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time: LONGINT;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sel: Frame;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj: Objects.Object<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END Display.<P>where:<BR>- <I>id</I> is the message identifier determining which action to perform on a gadget. The following actions are defined:<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>get</I>: When interrogating which gadget or gadgets are selected in the display space, the destination of the message is unknown. Therefore the field F must be set to NIL. On return the fields <I>obj</I> and <I>sel</I> are set.<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>set</I>: Select the visual gadget specified in the destination frame field F.<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>reset</I>: Deselect the visual gadget specified in the destination frame field F.<P>When <I>id=set</I> or <I>id=reset</I> the visual gadget is NOT redrawn. The client module must request a redraw by broadcasting a <I>DisplayMsg</I>.<P>- <I>time</I> contains, on return, the time of the selection when <I>id=get</I>. This field is unaltered if no object is selected. It is therefore important to initialize it with a negative value (<I>time:=-1</I>).<BR>- <I>sel</I> contains, on return, the ancestor of the selected object(s) when <I>id=get</I>.<BR>- <I>obj</I> contains, on return, the selected object (or the first object of a list) when <I>id=get</I>.<P>&nbsp; &nbsp; &nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon2.gif" OBJECT="GadgetsOberonObjs.3"><P>&nbsp; &nbsp; (*-- Access a list of selected gadget(s) one by one. --*)<BR>&nbsp; &nbsp; PROCEDURE EnumSelection;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>S: Display.SelectMsg</B>; obj: Objects.Object;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>S.id := Display.get;  S.F := NIL;  S.time := -1;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Display.Broadcast(S)</B>;<BR>&nbsp; &nbsp; &nbsp; &nbsp; IF (S.time > 0) &amp; (S.obj # NIL) THEN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj := S.obj;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Access the first object *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHILE obj # NIL DO<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*-- Process this object --*)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj := obj.slink&nbsp; &nbsp; &nbsp; &nbsp;  (* Access the next object *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END EnumSelection;<P><B>Exercise:</B><P>1) Select any number of gadgets in your display space and interrogate them with <CALL CMD="Examples.GetSelection"><FONT COLOR=FF0000>Examples.GetSelection</FONT></CALL> (uses id=get).<P>2) Deselect all gadgets and repeat the question.<P>&nbsp; &nbsp; (*-- Select a gadget --*)<BR>&nbsp; &nbsp; PROCEDURE SelectGadget*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>S: Display.SelectMsg;</B> obj: Objects.Object;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; obj := Gadgets.FindObj(Gadgets.context, "Test");<BR>&nbsp; &nbsp; &nbsp; &nbsp; IF (obj # NIL) THEN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B>S.id := Display.set; S.F := obj(Display.Frame); S.obj := NIL; S.sel := NIL;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B>Display.Broadcast(S);</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Use the information collected *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Info(S.obj);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Info(S.sel);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Redraw the gadget *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END SelectGadget;<P><B>Exercise:</B><P>1) Click the left button in this panel, to execute the command Examples.SelectGadget (uses id=set):<P>&nbsp; &nbsp; &nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon3.gif" OBJECT="GadgetsOberonObjs.44"><P>2) Display the information on that gadget named "Test" which has just been selected <CALL CMD="Examples.GetSelection"><FONT COLOR=FF0000>Examples.GetSelection</FONT></CALL> (uses id=get).<P>3) Deselect that gadget again with <CALL CMD="Examples.DeselectGadget"><FONT COLOR=FF0000>Examples.DeselectGadget</FONT></CALL> (uses id=reset). If you attempted to deselect the button 'Test' with a right mouse key click, it would fail: the panel is locked!<P><H2><A NAME="11"></A>Removing gadgets - Display.ControlMsg</H2>A client module can control the display space by broadcasting a <I>ControlMsg</I> to a given frame, specified in the destination frame field F of the base <I>FrameMsg</I>. A list of visual gadgets may be addressed on condition that they all have the same ancestor.<P>&nbsp; &nbsp; DEFINITION Display; (* excerpt only! *)<BR>&nbsp; &nbsp; CONST<BR>&nbsp; &nbsp; &nbsp; &nbsp; remove = 0; suspend = 1; restore = 2;<BR>&nbsp; &nbsp; TYPE<BR>&nbsp; &nbsp; &nbsp; &nbsp; ControlMsg = RECORD (FrameMsg)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id: INTEGER<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END Display.<P>where:<BR>- <I>id</I> is the message identifier which determines which action to perform in the display space. The following actions are defined:<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>remove</I>: Remove the destination frame(s) from the display space. Only the frame is (or the frames are) removed from the display space. The object(s) still exist(s) and may be restored to the display space at the caret location using <A HREF="#GadgetsIntegrate"><I>Gadgets.Integrate(obj)</I></A> for example.<BR>&nbsp; &nbsp; &nbsp; &nbsp;  This is either to delete it or to insert it into a new parent.<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>suspend</I>: Temporarily remove a frame from the destination downwards from the display space.<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>restore</I>: Restore a frame from the destination downwards to the display space. Frames which may have missed messages while suspended will then update their internal data structures.<P>Model program for removing a gadget from the display space:<P>&nbsp; &nbsp; PROCEDURE RemoveGadget(obj: Objects.Object);<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>C: Display.ControlMsg</B>;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>C.id := Display.remove</B>; <B>C.F</B> := obj(Gadgets.Frame); <B>C.res := -1</B>;<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Display.Broadcast(C)</B><BR>&nbsp; &nbsp; END RemoveGadget;<P><B>Exercise:</B><P>1) Place the caret in a free area of your desktop (outside of this viewer!).<BR>2) Insert a panel gadget at that point with <CALL CMD="Gadgets.Insert Panels.NewPanel"><FONT COLOR=FF0000>Gadgets.Insert Panels.NewPanel</FONT></CALL>.<BR>3) Select that gadget.<BR>4) Remove it with <CALL CMD="Examples.RemoveSelection"><FONT COLOR=FF0000>Examples.RemoveSelection</FONT></CALL> (uses id=remove).<BR>5) Again place the caret in a free area of your desktop.<BR>6) Re-insert the gadget at the caret with <CALL CMD="Examples.RestoreRemoved"><FONT COLOR=FF0000>Examples.RestoreRemoved</FONT></CALL>.<P><H2><A NAME="12"></A>Resizing / Moving a gadget - Display.ModifyMsg</H2>A client module can resize or move a visual gadget in the display space by broadcasting a <I>ModifyMsg</I> to a given frame, specified in the destination frame field F of the base <I>FrameMsg</I>.<P>&nbsp; &nbsp; DEFINITION Display; (* excerpt only! *)<BR>&nbsp; &nbsp; CONST<BR>&nbsp; &nbsp; &nbsp; &nbsp; reduce = 0; extend = 1; move = 2;<BR>&nbsp; &nbsp; &nbsp; &nbsp; display = 0; state = 1;<BR>&nbsp; &nbsp; TYPE<BR>&nbsp; &nbsp; &nbsp; &nbsp; ModifyMsg = RECORD (FrameMsg)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id: INTEGER; (* reduce, extend, move *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode: INTEGER; (* display, state *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dX, dY, dW, dH: INTEGER;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X, Y, W, H: INTEGER<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END Display.<P>where:<BR>- <I>id</I> is the message identifier which determines which action to perform in the display space. The following actions are defined:<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>reduce</I> or <I>extend</I>: Resize frame to the specified Width and Height.<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>move</I>: Move the frame to the new coordinates X and Y.<BR>- <I>mode</I> is set to <I>state</I>, the frame should not display itself immediately but only update its coordinates or size. This message must never be invalidated and the <I>dX, dY, dW, dH</I> change coordinates should always be set.<P>&nbsp; &nbsp; (*-- Resize a gadget to (W, H) --*)<BR>&nbsp; &nbsp; PROCEDURE ResizeTo(F: Gadgets.Frame; W, H: INTEGER);<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR<B> M: Display.ModifyMsg</B>;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.id := Display.extend</B>;&nbsp; &nbsp; (* or M.id := Display.reduce *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.mode := Display.display</B>;<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.F := F;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.X := F.X; M.Y := F.Y;</B>&nbsp; &nbsp; &nbsp; &nbsp; (* Same coordinates *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.dX := 0; M.Y := 0;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.W := </B>W<B>; M.H := </B>H<B>;</B>&nbsp; &nbsp; &nbsp; &nbsp;  (* New size *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.dW := </B>W<B>-F.W; M.dH := </B>H<B>-F.H;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Display.Broadcast(M)</B><BR>&nbsp; &nbsp; END ResizeTo;<P><B>Exercise:</B><P>1) Place the caret in a free area of your desktop (outside of this viewer!).<BR>2) Insert a panel gadget at that point with <CALL CMD="Gadgets.Insert Panels.NewPanel"><FONT COLOR=FF0000>Gadgets.Insert Panels.NewPanel</FONT></CALL>.<BR>2) Select that gadget.<BR>3) Determine the gadget coordinates and size with <CALL CMD="Examples.LocateGadget"><FONT COLOR=FF0000>Examples.LocateGadget</FONT></CALL> (uses SelectMsg).<BR>4) Resize the gadget with <CALL CMD="Examples.Resize 120 45"><FONT COLOR=FF0000>Examples.Resize 120 45</FONT></CALL>. The size values W=125 and H=45 are not editable in this viewer.<P>If you copy these two Examples commands in an editable viewer, say Oberon.Log, you may exercise with other gadgets and sizes on your desktop. Adequate size values can be chosen using the values produced in step 3).<P>&nbsp; &nbsp; (*-- Move a gadget to (X, Y) --*)<BR>&nbsp; &nbsp; PROCEDURE MoveToXY(F: Gadgets.Frame; X, Y: INTEGER);<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>M: Display.ModifyMsg</B>;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.id := Display.move</B>;<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.mode := Display.display</B>;<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.F</B> := F;<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.X := </B>X<B>; M.Y := </B>Y<B>;</B>&nbsp; &nbsp; &nbsp; &nbsp; (* New coordinates *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.dX := X-</B>F.X<B>; M.dY := Y-</B>F.Y<B>;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.W := </B>F.W<B>; M.H := </B>F.H<B>;</B>&nbsp; &nbsp; (* Same size *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>M.dW := 0; M.dH := 0;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Display.Broadcast(M)</B><BR>&nbsp; &nbsp; END MoveToXY;<P><B>Exercise:</B><P>1) Place the caret in a free area of your desktop (outside of this viewer!).<BR>2) Insert a panel at that point with <CALL CMD="Gadgets.Insert Panels.NewPanel"><FONT COLOR=FF0000>Gadgets.Insert Panels.NewPanel</FONT></CALL>.<BR>2) Select that gadget.<BR>3) Determine the gadget coordinates and size with <CALL CMD="Examples.LocateGadget"><FONT COLOR=FF0000>Examples.LocateGadget</FONT></CALL> (uses SelectMsg).<BR>4) Copy this Examples.MoveGadget X Y command to an editable viewer, say Oberon.Log, and replace the X and Y by reasonable coordinates values infered from the data obtained in the previous step.<P>You may also exercise with other gadgets and coordinates values on your desktop.<P><H2><A NAME="13"></A>Locating a frame - Display.LocateMsg</H2>A client module can interrogate the display space by broadcasting a <I>LocateMsg</I> to the display space.<P>&nbsp; &nbsp; DEFINITION Display; (* excerpt only! *)<BR>&nbsp; &nbsp; TYPE<BR>&nbsp; &nbsp; &nbsp; &nbsp; LocateMsg = RECORD (FrameMsg)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc: Frame;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X, Y, u, v: INTEGER<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END Display.<P>where:<BR>- <I>loc</I> contains, on return, the frame containing the point at the absolute coordinates X, Y. If no frame is found it contains NIL.<BR>- <I>X, Y</I> are the absolute coordinates of the point where the display space is interrogated.<BR>- <I>u, v</I> contain, on return, the relative coordinates of that point in the frame (relative to the frame's top left corner).<P>&nbsp; &nbsp; (*-- Locate gadget at screen coordinates X, Y --*)<BR>&nbsp; &nbsp; PROCEDURE Locate*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>L: Display.LocateMsg;</B> X, Y: INTEGER;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; ...<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Set X and Y *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>L.X := </B>X<B>; L.Y := </B>Y<B>; L.res := -1; L.F := NIL; L.loc := NIL;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Display.Broadcast(L);</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Use the information collected *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; Info(L.loc);<BR>&nbsp; &nbsp; &nbsp; &nbsp; Out.String("u="); Out.Int(L.u, 5);<BR>&nbsp; &nbsp; &nbsp; &nbsp; Out.String(" v="); Out.Int(L.v, 5); Out.Ln<BR>&nbsp; &nbsp; &nbsp; &nbsp; ...<BR>&nbsp; &nbsp; END Locate;<P><B>Exercise</B>:<P>1) Move the mouse pointer and place the star-shaped pointer within the limits of a frame on your desktop.<BR>2) Determine which gadget is located at that point with <CALL CMD="Examples.Locate"><FONT COLOR=FF0000>Examples.Locate</FONT></CALL> and observe where the pointer is located relative to the top left corner of the frame. Explain.<BR>3) Repeat this with other gadgets and also with the pointer placed in a free area of your desktop.<P><H2><A NAME="14"></A>(Re)drawing a gadget - Display.DisplayMsg</H2>A client module can request the redrawing of gadgets by broadcasting a <I>DisplayMsg</I>.<P>&nbsp; &nbsp; DEFINITION Display; (* excerpt only! *)<BR>&nbsp; &nbsp; CONST<BR>&nbsp; &nbsp; &nbsp; &nbsp; frame = 0; area = 1;<BR>&nbsp; &nbsp; TYPE<BR>&nbsp; &nbsp; &nbsp; &nbsp; DisplayMsg = RECORD (FrameMsg)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id: INTEGER;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u, v, w, h: INTEGER<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END Display.<P>where:<BR>- <I>id</I> is the message identifier which determines which action to perform in the display space. The following actions are defined:<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>frame</I>: Redraw the destination frame.<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>area</I>: Redraw the area defined by <I>u, v, w, h</I> inside the destination frame.<BR>- <I>u, v, w, h</I> define the relative coordinates <I>u, v</I> of an area of width <I>h</I> and of height <I>w</I> inside the destination frame, when <I>id=area</I>. These coordinates are determined relatively to the top left corner of the frame.<P>&nbsp; &nbsp; (*-- Select gadget --*)<BR>&nbsp; &nbsp; PROCEDURE SelectGadget*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR S: Display.SelectMsg; obj: Objects.Object; <B>D: Display.DisplayMsg;</B><BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; obj := Gadgets.FindObj(Gadgets.context, "Test");<BR>&nbsp; &nbsp; &nbsp; &nbsp; IF (obj # NIL) THEN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Select the gadget *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Redraw the gadget *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B>D.id := Display.frame; D.F :=</B> obj(Display.Frame);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B>Display.Broadcast(D);</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END SelectGadget;<P><H2><A NAME="AttrMsg"></A>Attribute management - Objects.AttrMsg</H2>Each gadget has a set of attributes representing the state, configuration or behaviour of the gadget. An attribute is a (Name, Value) pair, where the value is of type boolean, integer, real, character or string. An attribute is used to store the name, the value, a command string, an editing characteristic or other information of a gadget. For instance an attribute named "Cmd" may contain an Oberon command (string) which is executed when the gadget is activated (clicking the middle mouse key).<P>In the gadget system of Oberon System 3 attribute management is strictly and exclusively handled by sending messages, that is gadget attributes are retrieved and changed individually or enumerated by sending a message of type <I>AttrMsg (</I>defined in the module <I>Objects)</I> directly to a gadget, by calling it's handler with:<I><P>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj.handle(obj, message)<P></I>Note that object attributes can also be visualized and edited using a universal editor name "Inspector".<P>&nbsp; &nbsp; DEFINITION Objects; (* excerpt only! *)<BR>&nbsp; &nbsp; CONST<BR>&nbsp; &nbsp; &nbsp; &nbsp; enum = 0; get = 1; set = 2;<BR>&nbsp; &nbsp; &nbsp; &nbsp; Inval = 0; String = 2; Int = 3; Real = 4;<BR>&nbsp; &nbsp; &nbsp; &nbsp; LongReal = 5; Char = 6; Bool = 7;<BR>&nbsp; &nbsp; TYPE<BR>&nbsp; &nbsp; &nbsp; &nbsp; AttrMsg = RECORD (ObjMsg)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id: INTEGER;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Enum: PROCEDURE (name: ARRAY OF CHAR);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: Name;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res, class: INTEGER;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i: LONGINT;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x: REAL;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y: LONGREAL;&nbsp; &nbsp; &nbsp; &nbsp; c: CHAR;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b: BOOLEAN;&nbsp; &nbsp; &nbsp; &nbsp;  s: ARRAY 64 OF CHAR<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END Objects.<P>where:<BR>- <I>id</I> is the message identifier which determines which action to perform on the attribute. The following values are defined:<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>get</I>: Retrieve the value of the attribute <I>name</I>.<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>set</I>: Set the value of the attribute <I>name</I>.<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>enum</I>: Enumerate all the attributes of an object. The procedure <I>enum</I> is called repeatedly, once for each attribute<P>- <I>Enum</I> is an enumerator procedure that must be supplied by the sender when <I>id=enum</I>.<P>- <I>name</I> is the name of the attribute. It must be specified when <I>id=get</I> or <I>id=set</I>.<P>- <I>res</I> reports about the result: &lt; 0 message not handled, >= 0 message handled.<P>- <I>class</I> is the type of attribute. The predefined types are listed above: Inval, String, ...<P>- <I>i, x, y, c, b, s</I>: only just one of these fields is used to store the attribute value. The field used is the one matching the type specified by the <I>class</I> value. When <I>id=get</I> the attribute value is returned in one of the fields. When <I>id=set</I> the attribute value to assign must be stored in one of the fields before sending the message.<P><H3><A NAME="15"></A>Retrieving an attribute</H3>Use <I>id=Objects.get</I> to retrieve an attribute value of a given object. The result is stored in one of the i, x, y, c, b, s fields.<P>&nbsp; &nbsp; (*-- Retrieve a named attribute of an object --*)<BR>&nbsp; &nbsp; PROCEDURE GetAttr(obj: Objects.Object; name: ARRAY OF CHAR);<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>A: Objects.AttrMsg</B>;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.id := Objects.get</B>;<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>COPY(</B>name, <B>A.name);</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.res := -1;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; obj.handle(obj,<B> A</B>);<BR>&nbsp; &nbsp; &nbsp; &nbsp; IF <B>A.res</B> >= 0 THEN&nbsp; &nbsp; (* Attribute exists *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IF <B>A.class</B> = Objects.String THEN&nbsp; &nbsp; &nbsp; &nbsp; (* value A.s *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ELSIF <B>A.class</B> = Objects.Int THEN&nbsp; &nbsp; &nbsp; &nbsp; (* value A.i *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ELSIF <B>A.class</B> = Objects.Real THEN&nbsp; &nbsp; (* value A.x *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ELSIF <B>A.class</B> = Objects.LongReal THEN(* value A.y *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ELSIF <B>A.class</B> = Objects.Char THEN&nbsp; &nbsp; (* value A.c *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ELSIF <B>A.class</B> = Objects.Bool THEN&nbsp; &nbsp; (* value A.b *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ELSE<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* unknown class *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; &nbsp; &nbsp; ELSE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Attribute does not exist *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END GetAttr;<P><B>Exercise:</B><BR>1) Select this object <IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon4.gif" OBJECT="GadgetsOberonObjs.47"><BR>2) Display that object's attributes with <CALL CMD="Examples.ShowValue"><FONT COLOR=FF0000> Examples.ShowValue</FONT></CALL>.<BR>3) Move the slider and repeat the query.<P><H3><A NAME="16"></A>Setting an attribute</H3>Use <I>id=Objects.set</I> to set an attribute value.<P>&nbsp; &nbsp; (*-- Store a LONGINT value in a named object --*)<BR>&nbsp; &nbsp; PROCEDURE SetAttr(obj: Objects.Object; name: ARRAY OF CHAR; i: LONGINT);<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>A: Objects.AttrMsg;</B><BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.id := Objects.set;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; COPY(name, <B>A.name</B>);<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.class := Objects.Int;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.i</B> := i;<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.res := -1</B>;<BR>&nbsp; &nbsp; &nbsp; &nbsp; obj.handle(obj, <B>A</B>)<BR>&nbsp; &nbsp; END SetAttr;<P><H3><A NAME="17"></A>Enumerating the attributes</H3>Use <I>id=Objects.enum</I> to retrieve all attribute values.<P>&nbsp; &nbsp; &nbsp; &nbsp; VAR tmp: Objects.Object;<BR>&nbsp; &nbsp; (*-- Retrieve a named attribute --*)<BR>&nbsp; &nbsp; PROCEDURE RetrObjAttr(name: ARRAY OF CHAR);<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR<B> A: Objects.AttrMsg;</B><BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.id := Objects.get;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; COPY(name, <B>A.name</B>);<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.res := -1;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </B>tmp.handle(tmp, <B>A</B>);<BR>&nbsp; &nbsp; &nbsp; &nbsp; IF <B>A.res >= 0</B> THEN&nbsp; &nbsp; (* Attribute exists *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* <B>A.class</B> as in GetAttr *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; ELSE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (* Attribute does not exist *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END RetrObjAttr;<P>&nbsp; &nbsp; PROCEDURE EnumAttr*(obj: Objects.Object);<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR<B> A: Objects.AttrMsg;</B><BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.id := Objects.enum;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.Enum</B> := RetrObjAttr;<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>A.res := -1;</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; tmp := obj;<BR>&nbsp; &nbsp; &nbsp; &nbsp; obj.handle(obj, <B>A</B>)<BR>&nbsp; &nbsp; END EnumAttrs;<P><HR><H1><A NAME="18"></A>How to control gadgets with procedures</H1><BR>Preliminary remark: The command procedures exported by the Gadgets module are explained in the <A HREF="GadgetsUse.html#GadgetsMod">Using Gadgets</A> tutorial.The gadgets module exports a whole palette of procedures, only some of which are described and commented here. Among these, some are provided to simplify programming only, that is the same functionality can be obtained using by sending some of the messages described in the previous chapter. Notes scattered in the text will draw your attention on these cases.<P>Procedures which are of special interest for programmers of new gadgets are explained in the <A HREF="GadgetsProg.html#">Programming new Gadgets</A> tutorial.<P><H2><A NAME="CreateObj"></A>Creating an object - CreateObject</H2><B>Gadgets.CreateObject(newproc: ARRAY OF CHAR): Objects.Object</B> returns a new object from a new procedure. The newly created object is stored in the global variable <I>NewObj</I> in the <I>Objects</I> module and it can be referenced by <I>Objects.NewObj</I>. Note that the new gadget instance, a visual gadget or a model gadget, exists only IN the system. You can let a visual gadget appear in the display space by calling the Gadgets.Integrate procedure described below.<P>See how this is implemented in the example below.<P><H2><A NAME="GadgetsIntegrate"></A>Inserting a gadget at the caret location - Integrate</H2><B>Gadgets.Integrate(obj: Objects.Object)</B> integrates (i.e. inserts) the object <I>O</I> in the display space at the caret position.<P>&nbsp; &nbsp; (*-- Create a slider gadget and insert it at the caret position --*)<BR>&nbsp; &nbsp; PROCEDURE InsertAtCaret*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>obj: Objects.Object;</B><BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; ...<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>obj := Gadgets.CreateObject</B>("BasicGadgets.NewSlider"<B>)</B>;<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Gadgets.Integrate(obj)</B><BR>&nbsp; &nbsp; END InsertAtCaret;<P><B>Exercise:</B><P>1) Place the caret in a free area of your desktop (outside of this viewer!).<BR>2) Insert a slider gadget at that point with <CALL CMD="Examples.InsertAtCaret"><FONT COLOR=FF0000>Examples.InsertAtCaret</FONT></CALL>.<P><H2><A NAME="CreateView"></A>Creating a view/model pair - CreateViewModel</H2><B>Gadgets.CreateViewModel(viewnewproc, modelnewproc: ARRAY OF CHAR): Display.Frame</B> creates a view/model gadget pair, i.e. a visual gadget associated to a model gadget, for example a text field and a string. The newly created visual gadget is stored in the global variable <I>Objects.NewObj</I> and the newly created model gadget can be referenced by <I>Objects.NewObj(Gadgets.Frame).obj</I>.<P>&nbsp; &nbsp; (*-- Create a text field linked to an integer and insert it at the caret position --*)<BR>&nbsp; &nbsp; PROCEDURE InsertPair*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>F: Display.Frame;</B> obj: Objects.Object;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>F := Gadgets.CreateViewModel(</B>"TextFields.NewTextField",<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "BasicGadgets.NewInteger"<B>)</B>;<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Gadgets.Integrate(F);</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Name the model "Volts" *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Gadgets.NameObj</B>(F(Gadgets.Frame).obj, "Volts");<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Create a slider named "Slider" and link it to the integer --*)&nbsp; &nbsp; &nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; obj := Gadgets.CreateObject("BasicGadgets.NewSlider");<BR>&nbsp; &nbsp; &nbsp; &nbsp; Gadgets.Integrate(obj);<BR>&nbsp; &nbsp; &nbsp; &nbsp; Gadgets.NameObj(obj, "Slider");<BR>&nbsp; &nbsp; &nbsp; &nbsp; obj(Gadgets.Frame).obj := F(Gadgets.Frame).obj<BR>&nbsp; &nbsp; END InsertPair;<P><B>Exercise</B>:<P>1) Place the caret in a free area of your desktop (not in this viewer!).<BR>2) Insert a slider gadget at that point with <CALL CMD="Examples.InsertPair"><FONT COLOR=FF0000>Examples.InsertPair</FONT></CALL>.<P><H2><A NAME="19"></A>Naming an object - NameObj</H2><B>Gadgets.NameObj(obj: Objects.Object; name: ARRAY OF CHAR)</B> changes the name of any object (Note: ANY object, i.e. needs not to be a gadget at all).<P>See how this is implemented in the example above.<P><H2><A NAME="20"></A>Retrieving an object's name - GetObjName</H2><B>Gadgets.GetObjName(obj: Objects.Object; VAR name: ARRAY OF CHAR)</B> retrieves the name of any object (Note: ANY object, i.e. needs not to be a gadget at all).<P>&nbsp; &nbsp; (*-- Display names assigned in previous example--*)<BR>&nbsp; &nbsp; PROCEDURE ShowNames*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR S: Display.SelectMsg; ObjName: ARRAY 64 OF CHAR;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; .....<BR>&nbsp; &nbsp; &nbsp; &nbsp; Out.String("Visual gadget name: ");<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Gadgets.GetObjName</B>(S.obj, ObjName);<BR>&nbsp; &nbsp; &nbsp; &nbsp; Out.String(ObjName); Out.Ln;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*-- This visual gadget may have no model --*)<BR>&nbsp; &nbsp; &nbsp; &nbsp; Out.String("Model gadget name: ");<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Gadgets.GetObjName</B>(S.obj(Gadgets.Frame).obj, ObjName);<BR>&nbsp; &nbsp; &nbsp; &nbsp; Out.String(ObjName); Out.Ln<BR>&nbsp; &nbsp; END ShowNames;<P><B>Exercise 1</B>:<P>1) Select the slider created before.<BR>2) Prove that the names assigned are correct with <CALL CMD="Examples.ShowNames"><FONT COLOR=FF0000>Examples.ShowNames</FONT></CALL>.<BR>3) Deselect the slider and select the text field.<BR>4) Execute <CALL CMD="Examples.ShowNames"><FONT COLOR=FF0000>Examples.ShowNames</FONT></CALL> again and explain the result.<P><B>Exercise 2</B>:<P>Repeat the exercise with other gadgets on your desktop (using <CALL CMD="Examples.ShowNames"><FONT COLOR=FF0000>Examples.Shownames</FONT></CALL>) and note that some have no model gadget. Explain..<P><H2><A NAME="21"></A>Retrieving a public object - FindPublicObj</H2><B>Gadgets.FindPublicObj(name: ARRAY OF CHAR): Objects.Object</B> searches for a public object, the name of which is specified as "L.O". Where L is the name of a public library (e.g. Icons.Lib, a PublicPanel, ...) and O the name of the object. If no object of the given name exists NIL is returned.<P><H2><A NAME="22"></A>Retrieving an object - FindObj</H2><B>Gadgets.FindObj(context: Objects.Object; name: ARRAY OF CHAR): Objects.Object</B> searches for a named object in the specified context. If no object of the given name exists NIL is returned.<P>&nbsp; &nbsp; (* Find a named gadget in a specified context. *)<BR>&nbsp; &nbsp; PROCEDURE FindObj*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>obj: Objects.Object;</B><BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; (* Note that if this command is executed from a gadget<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the context is already set at execution time, before<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reaching this point. *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>obj := Gadgets.FindObj(</B>Gadgets.context, "Test");<BR>&nbsp; &nbsp; &nbsp; &nbsp; IF (<B>obj</B> # NIL) &amp; (<B>obj</B> IS BasicGadgets.Button) THEN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END FindObj;<P><B>Exercise</B>:<P>1) Click the left button in this panel, to execute the command Examples.FindObj:<BR>&nbsp; &nbsp; &nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon5.gif" OBJECT="GadgetsOberonObjs.48"><BR>2) Read the new information in Oberon.Log and explain.<P><H2><A NAME="Update"></A>Updating a gadget - Update</H2><B>Gadgets.Update(obj: Objects.Object)</B> if obj is a frame, a <I>Display.DisplayMsg</I> is broadcasted, else a <I>Gadgets.UpdateMsg</I> is broadcasted. This is needed if the data of a visual or model gadget is changed directly.<P><H2><A NAME="23"></A>Retrieving a frame - ThisFrame</H2><B>Gadgets.ThisFrame(X, Y: INTEGER; VAR F: Display.Frame; VAR u, v: INTEGER)</B> retrieves the frame <I>F</I> located at the absolute coordinates <I>X</I>, <I>Y</I> in the display space. <I>u</I>, <I>v</I> contain the relative coordinates of that point in the frame. These coordinates are determined relatively to the top left corner of the frame.<P>&nbsp; &nbsp; (*-- Locate gadget at screen coordinates X, Y --*)<BR>&nbsp; &nbsp; PROCEDURE LocateP*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR <B>F: Display.Frame;</B> X, Y: INTEGER; <B>u, v: INTEGER;</B><BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; ....<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Set X and Y *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Gadgets.ThisFrame(X, Y, F, u, v);</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* Use the information collected *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; Info(F);<BR>&nbsp; &nbsp; &nbsp; &nbsp; Out.String("u="); Out.Int(u, 5);<BR>&nbsp; &nbsp; &nbsp; &nbsp; Out.String("   v="); Out.Int(v, 5); Out.Ln<BR>&nbsp; &nbsp; &nbsp; &nbsp; ....<BR>&nbsp; &nbsp; END LocateP;<P><B>Exercise</B>:<P>1) Move the mouse pointer and place the star-shaped pointer within the limits of a frame on your desktop.<BR>2) Determine which gadget is located at that point with <CALL CMD="Examples.LocateP"><FONT COLOR=FF0000>Examples.LocateP</FONT></CALL> and observe where the pointer is located relative to the top left corner of the frame. Explain.<BR>3) Repeat this with other gadgets and also with the pointer placed in a free area of your desktop.<P><H2><A NAME="24"></A>Executing a command - Execute</H2><B>Gadgets.Execute(cmd: ARRAY OF CHAR; executor, dlink, sender, receiver: Objects.Object)</B> executes the command string <I>cmd</I>. Sender and receiver only have a value for consume operations. Dlink is copied to <A HREF="#Gcontext"><I>Gadgets.context</I></A>; <I>Oberon.Par.obj</I> is set to the executor, and <I>Oberon.Par.frame</I> is set to the outermost frame in which the command is executed.<P><H2><A NAME="25"></A>Executing a command - ExecuteAttr</H2><B>Gadgets.ExecuteAttr(F: Frame; attr: ARRAY OF CHAR; dlink, sender, receiver: Objects.Object)</B> searches for a certain attribute <I>attr</I> of <I>F</I> to be executed as command.<P><H2><A NAME="26"></A>Changing a gadget value directly - SetValue</H2><B>BasicGadgets.SetValue(obj: Objects.Object)</B> changes the "Value" attribute of a gadget of a type defined in the BasicGadgets module, after a direct change of its "val" field. Visual gadgets are automatically updated.<P>&nbsp; &nbsp; (*-- Look for an integer model gadget called "Test" in the current<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context and increment its val field. The model is visualized by<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a text field. --*)<BR>&nbsp; &nbsp; (*-- This command must be executed in a given context. --*)<BR>&nbsp; &nbsp; PROCEDURE Inc*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR obj: Objects.Object;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; obj := Gadgets.FindObj(Gadgets.context, "Test");<BR>&nbsp; &nbsp; &nbsp; &nbsp; IF (obj # NIL) &amp; (obj IS BasicGadgets.Integer) THEN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WITH obj: BasicGadgets.Integer DO<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INC(obj.val);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B>BasicGadgets.SetValue(obj)</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END Inc;<P><B>Exercise:</B><P><IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon6.gif" OBJECT="GadgetsOberonObjs.51"><P>1) Click on the "Inc" button at the top right corner of the panel and watch the Counter text field (starts at 0) and the slider (starts at 50) changing value or position. The "Inc" button's "Cmd" field contains "Examples.Inc". Executing the command causes a direct increment of two gadget values and the two views are updated. No <I>Objects.AttrMsg</I> is required.<P><H2><A NAME="27"></A>Comparison between commands and procedures</H2>The Gadgets module provides a number of commands which may be executed by the user or by gadgets to control gadgets and the display space. The same actions may be performed under program control using procedures (middle column). Objects and gadgets attributes can also be retrieved or changed by sending messages, defined in the Objects module, directly to objects. The following table summarizes that:<P><IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon7.gif" OBJECT="GadgetsOberonObjs.59"><BR><HR><H1><A NAME="Document"></A>How to control documents</H1><BR>You may write your own procedures and command procedures to control the presentation of new or existing documents. A number of standard procedures will help you in doing that.<H2><A NAME="28"></A>Loading an existing document - Documents.Open</H2><B>Documents.Open(name: ARRAY OF CHAR): Document</B> loads a named document from disk and returns the document. If a file of that name is not found NIL is returned. Note that the external document is internalized but not presented in the display space. To present it to the user you must use the next procedure.<P>For an example see the statement <B>(1)</B> in the procedure below.<P><H2><A NAME="29"></A>Presenting a document - Desktops.ShowDoc</H2><B>Desktops.ShowDoc(D: Documents.Document)</B> opens a document in the desktop or in a viewer depending on the context.<P>&nbsp; &nbsp; PROCEDURE OpenDoc(name: ARRAY OF CHAR);<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR D: Documents.Document;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>D := Documents.Open(name);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (1)</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; IF D # NIL THEN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B>Desktops.ShowDoc(D)&nbsp; &nbsp; (2)</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; END OpenDoc;<P><B>Exercise:</B><P>1) Start the tutorial named "Tutorial User's Guide", a Book document, with <CALL CMD="Examples.OpenDoc"><FONT COLOR=FF0000>Examples.OpenDoc</FONT></CALL> which loads the document "Tutorials.Book" (1) and presents it (2).<BR>2) Close the tutorial.<P><H2><A NAME="30"></A>Creating a new document</H2>Included in this release you will find several document types. With each document type a so-called document New procedure is associated. Calling this procedure causes (a new instance of) a document of the associated type to be created. The name of the New procedure is also recorded in the document itself. In this manner, a filed document can be recreated later on.<P>The New procedures currently available are listed in a table appearing in a subsequent chapter.<P>The procedure "InsertDoc" below shows how a new text document is created <B>(1)</B> and how it is given a name <B>(1a)</B>.<P><B>Reminder</B>: the command Desktops.OpenDoc uses the same new procedures to create and present new documents in the display space.<P><H2><A NAME="31"></A>Initializing a document - Documents.Init</H2><B>Documents.Init(F: Document, main: Gadgets.Frame)</B> initializes a document with a 'container' gadget.<BR><A NAME="InsertDoc"></A><BR>&nbsp; &nbsp; (*-- Insert a new text document in the display space --*)<BR>&nbsp; &nbsp; (*-- and give it a name, e.g. "MyDoc.Text".               --*)<BR>&nbsp; &nbsp; PROCEDURE InsertDoc(name: ARRAY OF CHAR);<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR D: Documents.Document;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj: Objects.Object;<BR>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; TextDocs.NewDoc;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <B>(1)</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; D := Objects.NewObj(Documents.Document);<BR>&nbsp; &nbsp; &nbsp; &nbsp; COPY(name, D.name);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    <B>(1a)</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; obj := Gadgets.CreateObject("TextGadgets.New");&nbsp; &nbsp; <B>(2)</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <B>Documents.Init(D, obj(Gadgets.Frame);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (3)</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; Desktops.ShowDoc(D, FALSE)<BR>&nbsp; &nbsp; END InsertDoc;<P><H2><A NAME="32"></A>Overview of commands and procedures</H2><IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon8.gif" OBJECT="GadgetsOberonObjs.91"><BR>When executed by the user or by a gadget, Gadgets.Insert causes a new visual (container) gadget to be presented in the display space whereas Desktops.OpenDoc causes a document gadget to be presented. The New procedure selected determines the gadget type or document type respectively.<P>The same result can be obtained under program control using standard procedures. Refer to the <A HREF="#InsertDoc">InsertDoc</A> procedure above to see the three steps (1), (2) and (3) required. The following table summarizes what is needed for each document type.<P><IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon9.gif" OBJECT="GadgetsOberonObjs.125"><BR>The third step is to initialize the document with the appropriate gadget <B>(3)</B>.<P>The system is also delivered with a number of special purpose documents.<P><BR><IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon10.gif" OBJECT="GadgetsOberonObjs.152"><BR><HR><H1><A NAME="33"></A>A final example</H1><BR>As a final example we have a <A HREF="GadgetsUse.html#Panel">panel</A> witch simply adds two real numbers. Entering a number in any of the three <A HREF="GadgetsUse.html#TextField">textfields</A> will keep the equation correct.&nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/GadgetsOberon11.gif" OBJECT="GadgetsOberonObjs.185"><P>Use the <CALL CMD="Desktops.OpenDoc (Inspectors.NewDoc)"><FONT COLOR=FF0000>Inspector</FONT></CALL> to see the attributes of selected gadgets. Note that the text fields have <A HREF="GadgetsUse.html#Real">real</A> model gadgets linked to them and a <A HREF="GadgetsUse.html#CmdAttr">command attribute</A> set to "Examples.Add".<P>The program behind this panel is rather simple:<P>MODULE Examples;<BR>&nbsp; &nbsp; IMPORT Objects, Gadgets, BasicGadgets, Out;<P>&nbsp; &nbsp; PROCEDURE Add*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR x, a, b: BasicGadgets.Real;<P>&nbsp; &nbsp; &nbsp; &nbsp; PROCEDURE GetReal(name: ARRAY OF CHAR): BasicGadgets.Real;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VAR obj: Objects.Object;<BR>&nbsp; &nbsp; &nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obj := Gadgets.FindObj(Gadgets.context, name);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IF (obj # NIL) &amp; (obj IS BasicGadgets.Real) THEN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RETURN obj(BasicGadgets.Real)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ELSE<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RETURN NIL<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END<BR>&nbsp; &nbsp; &nbsp; &nbsp; END GetReal;<P>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; (* 1. get the real gadgets *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; x := GetReal("xx");<BR>&nbsp; &nbsp; &nbsp; &nbsp; a := GetReal("aa");<BR>&nbsp; &nbsp; &nbsp; &nbsp; b := GetReal("bb");<BR>&nbsp; &nbsp; &nbsp; &nbsp; IF (x = NIL) OR (a = NIL) OR (b = NIL) THEN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RETURN<BR>&nbsp; &nbsp; &nbsp; &nbsp; END;<BR>&nbsp; &nbsp; &nbsp; &nbsp; (* 2. solve the equation *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; IF Gadgets.executorObj(Gadgets.Frame).obj # x THEN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* command executed from text field aa or bb *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x.val := b.val -a.val<BR>&nbsp; &nbsp; &nbsp; &nbsp; END;<BR>&nbsp; &nbsp; &nbsp; &nbsp; (* 3. notify clients of model x that x.val has changed *)<BR>&nbsp; &nbsp; &nbsp; &nbsp; BasicGadgets.SetValue(x)<BR>&nbsp; &nbsp; END Add<BR>END Examples.<P>The Examples.Add command can be divided into three parts:<P>(1) Retrieve the objects: <I>Gadgets.FindObj(context, name)</I> is used to find a named gadget in a <A HREF="GadgetsIntro.html#Context">context</A>. Because the command is executed from a gadget, the context (the panel containing the text fields) is stored in the variable <I>Gadgets.context</I>.<P>(2) Solve the equation.<P>(3) Notify clients of the changed object: In the case of real gadgets this can be done by calling <I>BasicGadgets.SetValue(obj)</I> (alternatively <A HREF="#Update">Gadgets.Update(obj)</A> could have been used).<BR><HR><H1><A NAME="34"></A>What's next?</H1>If you had liked to develop your own gadgets learn all about it in <A HREF="GadgetsProg.html#">Programming new Gadgets</A>.<P><HR><BR>Revised, afi 03 Mar 1995<BR>Installed on 14 Feb 1997<HR></BODY></HTML>