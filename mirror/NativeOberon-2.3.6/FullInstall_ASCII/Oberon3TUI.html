<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML Level 2.0 2//EN"><!-- Generated by Text2HTMLGIF (afi, ejz)--><HTML><HEAD><META NAME="Author" CONTENT="Andre Fischer"><TITLE>Using the textual interface of Oberon</TITLE></HEAD><BODY><H1><CENTER>Using the textual interface of Oberon</CENTER></H1><HR><CENTER><B>[ Text | <A HREF="Oberon3TUI.Contents.html">Contents</A> | <A HREF="Oberon3TUI.Index.html">Index</A> | <A HREF="Big.Index.html">Master index</A>]</B></CENTER><BR><BR><H1><A NAME="0"></A>Tutorial objective</H1>Introduce you to the Oberon textual user interface (TUI), the standard system editor, the file system and the system commands. The tutorial runs along the same line as Martin Reiser's User's Guide in <A HREF="Main.html#Literature">The Oberon System</A> on which it is based. Sitting at your workstation you are able to 'look and feel' Oberon and practice immediately new commands.<P>The tutorial is an application of the Gadgets system: you should organize your display space with, on the left your prefered desktop and on the right the Oberon system track. If your desktop covers the entire display screen, middle click on the [Close] button located in the top left corner and position this tutorial frame on the left, that is in the user track, of the screen for good visibility.<P>Estimated time: 60 minutes.<P><HR><H1><A NAME="Viewer"></A>The viewer</H1><BR>One of the intrinsic concepts of the Oberon system is the <I>viewer</I>, a rectangular area on the display. Viewers provide <I>a port to an underlying application</I> which is typically an editor operating on text, picture or graphic data objects. Viewers are non-overlapping and tile the display area completely. This is how it is organised:<A NAME="Track"></A><A NAME="1"></A>The screen of your Oberon system is divided vertically into two tracks: a wider user track (on the left) and a narrower system track (on the right).<P>&nbsp; &nbsp; &nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/Oberon3TUI1.gif" OBJECT="Oberon3TUIObjs.0"><P>The vertical stripe of a track is further subdivided horizontally into <A HREF="#VLayout">viewers</A>. Viewers are stacked, one on top of another, and fill tracks from the bottom up without leaving gaps. Within this grid, viewers are opened and closed by issuing commands or under program control. There are two commands for opening text viewers - <A HREF="#EditO">Edit.Open</A> and <A HREF="#SysOpen">System.Open</A>. A log viewer, a specialized text viewer, is opened with System.OpenLog.<P><H2><A NAME="VLayout"></A>Viewer layout</H2>Open a viewer in the system track by clicking on (this command) <CALL CMD="System.OpenLog"><FONT COLOR=FF0000>System.OpenLog</FONT></CALL>. An Oberon viewer is a rectangular area on the display with two active subframes: a <I></I><A NAME="2"></A>menu frame at the top and <I></I><A NAME="3"></A>main frame below. Now locate the following layout elements in that viewer:<BR><UL><BR><LI>the <I>title bar</I> with the viewer name at the left followed by by what is called the <I>menu text</I> (a set of commands). The title bar appears on a grey background.<LI>the <I>vertical scroll bar</I> located on the left<LI>the <I>main text area</I> below the title bar</UL><BR>The name (here "System.Log") identifies the viewer. In many cases, it corresponds to a file name designating the disk file where the data displayed in the main text area is stored. Close the viewer by clicking on the <I>menu command</I> "System.Close".<P><H2><A NAME="VPlace"></A>Placement of the viewer</H2>The user has control over the placement of viewers:<BR>&nbsp; &nbsp; o&nbsp; &nbsp; at the time of the open command,<BR>&nbsp; &nbsp; o&nbsp; &nbsp; after the viewers have been opened.<P>Normally, when an open command is issued, Oberon makes a reasonable guess as to where to place the viewer on the display. That is precisely the difference between the two open commands above: with Edit.Open, the viewer will open in the user track and with System.Open in the system track. The user, however, can indicate where the viewer should open by means of the <A HREF="Mouse.html#Marker">pointer</A>. Regardless of where Oberon would have opened the viewer, it will open in the track of the pointer and its top edge will be at the height of the pointer.<P>Verify those assertions by yourself, placing the pointer in any of the user or system tracks and clicking on <CALL CMD="System.OpenLog"><FONT COLOR=FF0000>System.OpenLog</FONT></CALL>. Remove these viewers by clicking on the menu command "System.Close".<P>An opened viewer may be resized or relocated with its <A HREF="#TitleBar">title bar</A>.<P><HR><H1><A NAME="MouseCmd"></A>Mouse commands</H1><BR>The Oberon system relies very much on the availability of a mouse. A tutorial <A HREF="Mouse.html#">Using the mouse and the keyboard</A> has been developed specially for new Oberon users. Summarizing what is presented at length in that tutorial, we might say that the three mouse keys are assigned to the following basic functions:<BR><UL><BR><LI><A HREF="Mouse.html#Insertion">Mouse Left key - ML</A>: <B>point</B> i.e. set the caret (mark the <I>insertion point</I>)<LI><A HREF="Mouse.html#ExecCmd">Mouse Middle key - MM</A>: <B>execute</B> a command pointed at by the <I>mouse focus</I><LI><A HREF="Mouse.html#Selection">Mouse Right key - MR</A>: <B>select</B> (character, word, stretch of text, line, paragraph)</UL><BR>The three keys are used to issue commands whose meaning is defined by the class of the viewer which contains the cursor. When used with the standard <A HREF="#Editor">system editor</A> - that is with a viewer of the class text viewers, often used functions such as select, copy, delete and execute can be executed "in place" using the mouse alone, without the need for a tool or a menu. The complete set of mouse commands used by the editor is documented below.<B>Cancelling a mouse action</B>: When a wrong key is pressed, pressing <B>all</B> keys cancels any action that would otherwise be initiated. The same holds true for an interclick.<P><H2><A NAME="CursorText"></A>Cursor in main text area</H2>All edit commands work either on selected text or on the text at the caret location. Oberon ensures that at any time only one caret is set. However there is no unique selection, each frame may have its own selection. Commands working on the selection always work on the most recently made one.<P>Oberon abandons the notion of a program, atomic actions are called Commands. Commands are executed by pressing and releasing the middle mouse key while pointing at the command name. As visual feedback the command name is underlined while the middle mouse key remains pressed.<BR><A NAME="CursorTable"></A><BR>&nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/Oberon3TUI2.gif" OBJECT="Oberon3TUIObjs.10"><BR>&nbsp; &nbsp; Notes:<BR>&nbsp; &nbsp; &nbsp; &nbsp; (1)&nbsp; &nbsp; There are two variants of copy:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Left + middle: Copy an existing selection to the caret.<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The caret is set with this interclick.<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Right + middle: Make a selection and copy it over to the caret.<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The caret must have been set earlier.<BR>&nbsp; &nbsp; &nbsp; &nbsp; (2)&nbsp; &nbsp; Font and color of the text at the caret location are copied.<BR>&nbsp; &nbsp; &nbsp; &nbsp; (3)&nbsp; &nbsp; This interclick is specially useful when developing software.<P><H2><A NAME="4"></A>Cursor in scroll bar</H2><BR>&nbsp; &nbsp; &nbsp; &nbsp; <BR>&nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/Oberon3TUI3.gif" OBJECT="Oberon3TUIObjs.33"><BR>&nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/Oberon3TUI4.gif" OBJECT="Oberon3TUIObjs.39"><BR>&nbsp; &nbsp; Notes:<BR>&nbsp; &nbsp; &nbsp; &nbsp; (1)&nbsp; &nbsp; Dragging tracks the line which becomes the topmost line.<BR>&nbsp; &nbsp; &nbsp; &nbsp; (2)&nbsp; &nbsp; Scrolls to the begining of the document or a step up,<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; depending on the editor used.<H2><A NAME="5"></A>Cursor in title bar</H2>&nbsp; &nbsp; <IMG ALT="Cool Oberon Object " SRC="images/Oberon3TUI5.gif" OBJECT="Oberon3TUIObjs.57"><BR>The title bar is also text. All editing operations work the same way as those in the main editable text - new commands may be added, the name may be changed, stretches of text may be selected, deleted and copied. The only restriction is that, in order to set the caret (it is NOT visible), the mouse has to point at the very bottom of the area rendered in reverse video. Also, a changed title CANNOT be saved to disk. When the viewer is reopened, the standard commands are again displayed.<BR><A NAME="TitleBar"></A><BR><IMG ALT="Cool Oberon Object " SRC="images/Oberon3TUI6.gif" OBJECT="Oberon3TUIObjs.64"><BR>&nbsp; &nbsp; Note:<BR>&nbsp; &nbsp; &nbsp; &nbsp; If the mouse cursor is in the <I>upper part</I> of the title bar, pressing the<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>left key</I> removes the reverse video, thereby telling the user that a<BR>&nbsp; &nbsp; &nbsp; &nbsp; tracking mode has been entered. Dragging on the left key will<BR>&nbsp; &nbsp; &nbsp; &nbsp; determine the new top position in the track. On releasing the key,<BR>&nbsp; &nbsp; &nbsp; &nbsp; the top edge of the viewer moves to the height of the mouse<BR>&nbsp; &nbsp; &nbsp; &nbsp; cursor and the viewer contents is redrawn.<BR>&nbsp; &nbsp; &nbsp; &nbsp; If the middle key is interclicked while dragging, the viewer may be<BR>&nbsp; &nbsp; &nbsp; &nbsp; relocated in another track.<BR>&nbsp; &nbsp; &nbsp; &nbsp; This interclick can also be used to force a viewer to redraw its<BR>&nbsp; &nbsp; &nbsp; &nbsp; contents.<P><H2><A NAME="LargeSelect"></A>Large selection</H2>If a large portion of a document has to be selected, it may not fit into in the viewer. In this case, a second viewer must be opened adjacent to the original one using <A HREF="#SysCopy">System.Copy</A>. The text in the second viewer must then be scrolled until the end of the desired selection becomes visible. The large selection can now be made as follows:<P>(1)&nbsp; &nbsp; Select the beginning of the desired large selection in one viewer. An arbitrary piece of the beginning may be selected - just one character is sufficient.<P>(2)&nbsp; &nbsp; Select the end of the desired large selection in the other viewer. As before, an arbitrary large piece of the end may be selected. Interclick commands can be given while selecting the tail piece. They operate on the whole large selection.<P>Now the entire text, including the invisible portion between the beginning of the first and the end of the second sub-selection, is selected.<I><BR>Note:</I> The entire large selection is NOT highlighted in reverse video. Only the two sub-selections are.<P><HR><H1><A NAME="Command"></A>Taking control of Oberon</H1><BR>Now that you know how your display space is organized, what actions can be started with your mouse and how to point with the cursor to a point where text can be entered, deleted, edited, you are invited to take control of Oberon.In Oberon, the code unit which can be executed from your user interface is called a <I>command</I>. Commands are simply typed into a text viewer and then executed by pointing at them with the mouse cursor and clicking the middle mouse key. A command may be embedded anywhere in a text. If a command produces output to the screen, the output may appear in a viewer already opened or a new text viewer may be opened to present it.<P>To see an example corresponding to the first case click on this command <CALL CMD="System.Time"><FONT COLOR=FF0000>System.Time</FONT></CALL><I> </I>. It is a command producing this output text in the System.Log (look at the upper part of the system track):<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Time dd.mm.yy hh:mm:ss.<P>To see an example corresponding to the second case click on this command <CALL CMD="System.ShowModules"><FONT COLOR=FF0000>System.ShowModules</FONT></CALL>. It is a command producing an output text in a System.ShowModules viewer which is opened in the system track.<P>And now click on the 'System.Close' command which appears in the title bar of that viewer.<P><H2><A NAME="Syntax"></A>Command definition and syntax</H2>An Oberon command is a parameterless procedure in a module written in the programming language Oberon. It is written as:&nbsp; &nbsp; &nbsp; &nbsp; <I>Module.Procedure</I><P>where <I>Procedure</I> is the name of a procedure exported by a module named <I>Module</I>. You have just seen three examples of that.<P><H2><A NAME="6"></A>Parameter</H2>Most commands require parameters. It is important not to confuse these with the formal parameters of procedures written in the programming language Oberon. The parameters of commands have different sources such as:<BR><UL><BR><LI>text following the command name<LI>text contained in the selection<LI>the viewer from which the command is executed<LI>the marked viewer, i.e. designated by the pointer.</UL><BR>The parameters provided by these sources is text that may be of arbitrarily complex syntax. A single name or a list of names are just the simplest cases. We shall frequently make use of the expression 'parameter list'.<P><H2><A NAME="7"></A>No parameter</H2>A few commands simply do not require parameters at all. For example, the command <CALL CMD="System.OpenLog"><FONT COLOR=FF0000>System.OpenLog</FONT></CALL> which opens a text viewer named "System.Log". Some commands, also not requiring parameters, operate on implicitely defined object(s). Commands which appear in the title bar usually take their viewer as implied parameter. For example, <I>System.Close</I>, which when executed from the title bar, needs no parameter and closes the viewer. Do close the "System.Log" you have just opened.<P><H2><A NAME="8"></A>Single name as parameter</H2>Several commands expect a single word after the command's name. That word is separated from the command name by one or several blanks. A word is a string of at most 32 characters not containing blanks. It is usually a file name or a template defined by its own syntax. Oberon uses structured names to identify objects. The syntax of names is:<P>&nbsp; &nbsp; &nbsp; &nbsp; name = namePart{"."namePart}.<BR>&nbsp; &nbsp; &nbsp; &nbsp; namePart = letter{letter | digit}.<BR>&nbsp; &nbsp; &nbsp; &nbsp; letter = "A" | "B" | ... | "Z" | "a" | "b" | ... |"z".<BR>&nbsp; &nbsp; &nbsp; &nbsp; digit = "0" | "1" | ... | "9".<P>Thus, if a name is expected, any special symbol terminates the name. For example, <CALL CMD="System.Open EmptyViewer.Text~"><FONT COLOR=FF0000>System.Open EmptyViewer.Text~</FONT></CALL>. Upper and lower case letters are considered distinct.<P>The following are examples of structured names:<P><B>Oberon3TUI.html</B> the name of a file containing this tutorial and the name of this document: look at its <A HREF="GadgetsUse.html#NamePlate">name plate</A> at the top left corner.<P><B>Sample.Mod</B> the name of a file containg the source text of the module Sample, written in the Oberon language.<P><H2><A NAME="9"></A>List of names as parameter - {nameList} ~</H2>Some commands take a list of names as parameters. The list may be of variable length. It is separated from the command name by one or several blanks and items in the list are blank delimited. The list is terminated by a special symbol, typically "~". For example, executing <CALL CMD="Compiler.Compile M1.Mod M2.Mod M3.Mod~"><FONT COLOR=FF0000>Compiler.Compile M1.Mod M2.Mod M3.Mod~</FONT></CALL> will compile all three files in that order.<P><H2><A NAME="10"></A>List of name pairs as parameter - {namePair} ~</H2>A few commands process a list of name pairs as indicated in this example:<P>&nbsp; &nbsp; System.RenameFiles A.Mod => a.Mod B.Text => b.Text ~<P>The arrow composed of the character "=" immediately followed by ">" that the file "A.Mod" is being renamed to "a.Mod" and not the other way round.<P><H2><A NAME="Selection"></A>Selection as parameter - ^</H2>If "^" follows the command name, the parameter is found in the most recent selection (this upward arrow is the caret on your keyboard). Only an initial portion of a word needs to be selected, but at least the first character.<P>Re-using a recent example, select a few initial characters in -> EmptyViewer.Text and click on <CALL CMD="System.Open ^"><FONT COLOR=FF0000>System.Open ^</FONT></CALL>.<P><B>Warning!</B> Watch this pitfall: Do <B>not</B> place the selection in the system log viewer. Many commands write to it and as you know the selection may be <A HREF="Mouse.html#Observe">cleared</A> before this last parameter is processed.<P><H2><A NAME="11"></A>Marked viewer as parameter - *</H2>Other commands operate on the <A HREF="Mouse.html#Marker">marked viewer</A>, either implicitely as for example, System.Close executed in the title bar of a viewer, or explicitely by expecting an "*" after the command name as for example Edit.Print LPT1 *. Assuming that the marked viewer's name is "Test.Mod", then the previous command is equivalent to: Edit.Print LPT1 Test.Mod.<P><HR><H1><A NAME="Editor"></A>Using the standard editor</H1><BR>Every viewer displaying text (called <I>text frame</I>) embodies an interactive text editor. We can regard it as an interpreter of a set of built-in commands (so-called <I>intrinsic commands</I>, e.g. the mouse commands presented in the previous chapter).Module Edit is a toolbox (see <CALL CMD="System.Open Edit.Tool"><FONT COLOR=FF0000>Edit.Tool</FONT></CALL>) of standard editing commands (so-called <I>extrinsic commands</I>).<P><H2><A NAME="EditO"></A>Opening a text viewer - Edit.Open</H2><B>Edit.Open name | ^</B> opens a text <A HREF="#Viewer">viewer</A> named <B>name</B> and, if a file with the same name exists, displays the file contents in the viewer. Otherwise, an empty viewer is opened. The viewer is opened in the <A HREF="#Track">user track</A> unless the <A HREF="#VPlace">pointer</A> is set.<B><BR>Note:</B> The selection is also searched if the text line is empty after the command name.<P><B>Exercises:</B><BR>&nbsp; &nbsp; &nbsp; &nbsp; <CALL CMD="Edit.Open Sample1.Mod"><FONT COLOR=FF0000>Edit.Open Sample1.Mod</FONT></CALL> and close it.<BR>Select a portion or whole of Sample1.Mod .<BR>&nbsp; &nbsp; &nbsp; &nbsp; <CALL CMD="Edit.Open ^"><FONT COLOR=FF0000>Edit.Open ^</FONT></CALL> and close it.<BR>&nbsp; &nbsp; &nbsp; &nbsp; <CALL CMD="Edit.Open "><FONT COLOR=FF0000>Edit.Open </FONT></CALL><BR>and close it.<P><H2><A NAME="12"></A>Showing a string in a module - Edit.Show</H2><B>Edit.Show module.txt | ^</B> opens a <A HREF="#Viewer">viewer</A> named <B>module.Mod</B> displaying the module if it exists with the first occurence of the string "txt" positioned near the top. If the module does not exist an empty viewer is opened. The viewer is opened in the <A HREF="#Track">user track</A> unless the <A HREF="#VPlace">pointer</A> is set.<B><BR>Note:</B> The selection is also searched if the text line is empty after the command name.<P><B>Exercise:</B><BR><CALL CMD="Edit.Show Examples.InsertAt"><FONT COLOR=FF0000>Edit.Show Examples.InsertAt</FONT></CALL> opens a viewer displaying the source text in the file Examples.Mod.<P><H2><A NAME="EditSto"></A>Storing a text - Edit.Store</H2><B>Edit.Store [name | ^]</B> If executed from the title bar, the viewer contents is stored in a disk file whose name is identical to the viewer's name. If executed from a main text, the contents of the marked viewer is stored in a disk file named <B>name</B>. The file is stored in the current directory. If a file with that name already exists, it is renamed: the suffix ".Bak" is appended to its original name.<P><H2><A NAME="EditRec"></A>Undo last delete - Edit.Recall</H2><B>Edit.Recall</B> inserts the most recently deleted text at the position of the caret (undo). The caret may be in a different viewer from the one where the text was deleted.<P>Note: Deletion and Edit.Recall can be used in combination to move text from one place to another (cut and paste).<BR>&nbsp; &nbsp; (1) Delete text to be moved.<BR>&nbsp; &nbsp; (2) Place the caret at the insertion point.<BR>&nbsp; &nbsp; (3) Execute Edit.Recall<P><B>Caution:</B> After having deleted the text to be moved, do NOT use the backspace key to correct a typing error, e.g. while typing "Edit.Recall". The deleted text is lost and replaced by the last character deleted.<P><H2><A NAME="13"></A>Changing the color - Edit.ChangeColor</H2><B>Edit.ChangeColor colorNumber</B> changes the color of the most recent selection to <B>colorNumber</B>. The parameter must be an integer denoting a color in the color palette.<P><H2><A NAME="EditChangeFont"></A>Changing the font - Edit.ChangeFont</H2><B>Edit.ChangeFont fontName</B> changes the font of the most recent selection to <B>fontName</B>. The parameter must specify a valid font name -> <CALL CMD="System.Directory *.Scn.Fnt "><FONT COLOR=FF0000>System.Directory *.Scn.Fnt </FONT></CALL>.<P><H2><A NAME="14"></A>Copying the font - Edit.CopyFont</H2><B>Edit.CopyFont</B> changes the font of the selection to the font at the place of the star-shaped pointer.<P><H2><A NAME="EditSea"></A>Searching a pattern - Edit.Search</H2><B>Edit.Search</B> searches a pattern in the marked text. The pattern is defined by the most recent selection. If none exists, the previous pattern is used. Searching is started at the position of the caret. If none exists in the marked text, searching starts at the beginning. The initial value of the pattern is the space character.<P><I>Note:</I> Repeated execution of this command searches for subsequent occurrences of the pattern.<P><H2><A NAME="EditLoc"></A>Locating a position - Edit.Locate</H2><B>Edit.Locate</B> The text in the selection is scanned from left to right for the first occurrence of an integer. Assume that 'n' denotes that integer. The caret is then placed in the text of the marked viewer after the nth character. Carriage return characters are also counted. The command is used for locating a compiler detected error in the (source) text of a module.<P><H2><A NAME="15"></A>Printing a text - Edit.Print</H2><B>Edit.Print ServerName [%] { (textFileName | *) ["/" noOfCopies] }</B> sends all texts specified by the parameter list to the print server whose name is taken from the first entry in the parameter list. Names in the parameter list refer to text files, the symbol * to the text in the marked viewer. The special character "%" specifies the vanilla-print option: the texts are printed in a single monospaced small font (Gacha10l). This option is typically used for printing source program listings. The option <B>noOfCopies</B> specifies the desired number of copies. It must be a single-digit number.<P>On workstations directly connected to a printer <I>ServerName</I> is the name of the printer port (e.g. LPT1 on a PC, or QuickDraw on an Apple Macintosh).<P><H2><A NAME="EditCle"></A>Clearing a viewer - Edit.Clear</H2><B>Edit.Clear [*]</B> <FONT COLOR=FF0000>(Windows ONLY)</FONT> clears a viewer: if executed from the title bar, it clears the viewer containing the title bar, and if executed from a main text, the marked viewer. The deleted text can be re-inserted after the caret by executing the <A HREF="#EditRec">Edit.Recall</A> command.<P><H2><A NAME="EditRep"></A>Replacing text - Edit.Replace</H2><B>Edit.Replace</B> <FONT COLOR=FF0000>(Windows ONLY)</FONT> replaces the search pattern set by the last <A HREF="#EditSea">Edit.Search</A> command by the most recent selection and resumes the search of the pattern. The caret must be positioned immediately after the search pattern.<P><H2><A NAME="EditRepAll"></A>Replacing all text occurrences - Edit.ReplaceAll</H2><B>Edit.ReplaceAll</B> <FONT COLOR=FF0000>(Windows ONLY)</FONT> replaces the search pattern set by the last <A HREF="#EditSea">Edit.Search</A> command by the most recent selection and proceeds with the search until all occurrences have been replaced. The caret must be positioned immediately after the search pattern.<P><HR><H1><A NAME="FileSyst"></A>Using the file system</H1><BR>Oberon features a simple and extremely efficient file system. The disk directory is organized as a B-Tree. A clear distinction is made between a file and aggregates to access it, which are called riders. Files names are case sensitive and may be up to 32 characters long and contain any number of dots ".". There are no folders or directories, so each file is fully identified by its name. The working files are located either on a hard disk or a RAM disk. Diskettes are primarily used to back-up and restore these working files. Note, that some of the commands described below are not available on MacOberon (see your MacOberon documentation for more information).File name suffixes are normally used to determine the type of data contained in a file. The following suffixes are commonly used:<P>- Bak: Back-up files; if the contents of a viewer (text editor, graphics editor, ...) are saved (e.g. with <A HREF="#EditSto">Edit.Store</A>) and if a file with the viewer's name already exists, then the old file is kept under the name "name.Bak".<P>- Fnt: Font file; a font file name usually has the following structure:<BR>&nbsp; &nbsp; &nbsp; &nbsp; &lt;name of font family> &lt;size and attribute> "." &lt;output device> ".Fnt".<P>Example: Syntax12i.Scn.Fnt - A 12 point italic display font of the Syntax font familiy<P>- Mod: Oberon module (source program text)<BR>- Obj: Oberon module (object files)<BR>- Pict: picture file<BR>- Text: text file<BR>- Tool: Working menu, which is freely editable (e.g. Backup.Tool)<BR>- Graph or Graphic: graphics document<P><A NAME="FileAdm"></A>The facilities for file administration are provided by the command module <A HREF="#SysCmd">System</A>.<P><H2><A NAME="16"></A>Directory management commands</H2><A NAME="17"></A><B>System.CreateDirectory [path]name | ^</B> creates a subdirectory.<P><A NAME="18"></A><B>System.ChangeDirectory [path]name | .. | ^</B> changes the current subdirectory to the one specified.<P><A NAME="19"></A><B>System.DeleteDirectory [path]name | ^</B> deletes the specified subdirectory.<P><A NAME="20"></A><B>System.Directory [template[\d] | ^]</B> opens a viewer named "System.Directory" displaying a list of file names. The names selected are those matching the <B>template</B>, a text string with no blank character, in which the "*" is used as a wildcard - that is, a character matched by any string of non-blank characters. If the option <B>\d</B> follows the template without blanks, the listing includes the date and the time of file creation and file size in bytes. In the case of a <B>^</B> following the command name the parameter is taken from the current selection. The viewer is opened in the <A HREF="#Track">system track</A> unless the <A HREF="#VPlace">pointer</A> is set.<P><A NAME="21"></A>Examples of templates are as follows:<BR><PRE>   <B>String    Files selected</B>   *          All files   *.*        All files with a name containing at least two parts, separated by a dot   *.Mod      All files with suffix "Mod"   Test.*     All files with first name part "Test"   *.Scn.*    All files with second name part "Scn"</PRE><B><BR>Exercise:</B> Click here to <CALL CMD="BookDocs.CopyToFile Sample1.Mod File1Beg File1End"><FONT COLOR=FF0000>create a file named "Sample1.Mod"</FONT></CALL>.<BR><A NAME="File1Beg"></A><P>&nbsp; &nbsp; MODULE Sample1;<BR>&nbsp; &nbsp; &nbsp; &nbsp; IMPORT Oberon, Texts;<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR W: Texts.Writer;<P>&nbsp; &nbsp; &nbsp; &nbsp; PROCEDURE Hello*;<BR>&nbsp; &nbsp; &nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Texts.WriteString(W, "hello, world");<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Texts.WriteLn(W);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Texts.Append(Oberon.Log, W.buf)<BR>&nbsp; &nbsp; &nbsp; &nbsp; END Hello;<P>&nbsp; &nbsp; BEGIN<BR>&nbsp; &nbsp; &nbsp; &nbsp; Texts.OpenWriter(W)<BR>&nbsp; &nbsp; END Sample1.<P><A NAME="File1End"></A><BR>Now be prepared to close the viewer which will open when you click on <CALL CMD="System.Directory Sample*/d"><FONT COLOR=FF0000>System.Directory Sample*/d</FONT></CALL>.<P><H2><A NAME="22"></A>File management commands</H2><BR><A NAME="SysCopy"></A><BR><B>System.CopyFiles {name1 => name2} ~ | ^</B> A list of name pairs <I>name1</I> and <I>name2</I> is processed. The pairs are separated by "=>". The file <I>name1</I> is duplicated and a directory entry <I>name2</I> is created. If a file <I>name2</I> already exists, it is overwritten.<B>Exercise:</B> <CALL CMD="System.CopyFiles Sample1.Mod => Sample2.Mod ~"><FONT COLOR=FF0000>System.CopyFiles Sample1.Mod => Sample2.Mod ~</FONT></CALL><P><A NAME="23"></A><B>System.RenameFiles {name1} => name2 ~ | ^</B> A list of name pairs <I>name1</I> and <I>name2</I> is processed. The pairs are separated by "=>". The directory entry <I>name1</I> is renamed to <I>name2</I>. If a file <I>name2</I> already exists, it is overwritten.<P><B>Exercise:</B> <CALL CMD="System.RenameFiles Sample1.Mod => Sample3.Mod ~"><FONT COLOR=FF0000>System.RenameFiles Sample1.Mod => Sample3.Mod ~</FONT></CALL><P><A NAME="24"></A><B>System.DeleteFiles {name} ~ | ^</B> deletes all the files named the parameter list.<B><BR>Caution</B>: Don't forget to terminate the parameter list with a "~". Any file whose name appears after the intended name list will be deleted without a request for confirmation or the possibility of undoing the operation.<P><B>Exercise:</B> <CALL CMD="System.DeleteFiles Sample2.Mod Sample3.Mod ~"><FONT COLOR=FF0000>System.DeleteFiles Sample2.Mod Sample3.Mod ~</FONT></CALL><P><HR><H1><A NAME="Diskette"></A>Using a diskette - Native Oberon</H1><BR>Diskettes are primarily used to back-up files of the hard disk. The commands exported by the module <I>Backup</I> serve to:<BR>&nbsp; &nbsp; o format and initialize diskettes<BR>&nbsp; &nbsp; o display the directory of diskettes<BR>&nbsp; &nbsp; o read files from diskette to hard disk<BR>&nbsp; &nbsp; o write files from hard disk to diskette<BR>&nbsp; &nbsp; o delete files from disketteA <CALL CMD="System.Open Backup.Tool"><FONT COLOR=FF0000>Backup tool</FONT></CALL> presents a set of commands ready for execution with the mouse.<P><H2><A NAME="25"></A>Selecting a diskette drive - Backup.SetDriveA</H2><B>Backup.SetDriveA</B> and <B>Backup.SetDriveB</B> select the (3.5" diskette) drive to be used by the various Backup commands. Default is drive A.<I></I><P><H2><A NAME="26"></A>Formatting a diskette - Backup.Format</H2>Any diskette formatted with a standard DOS formatter may be used. Alternatively, the following commands are provided:<P><B>Backup.Format [/D] | /H</B> formats a 2-sided double density (DD) or respectively a high density (HD) diskette in the selected drive. In both cases the diskette has the proprietary Oberon format.<P><H2><A NAME="27"></A>Initializing in DOS format - Backup.InitDOS</H2><B>Backup.InitDOS [volName]</B> initializes a formatted diskette, i.e. creates a DOS directory, and sets a volume label. <I>volName</I> must be a valid DOS name (fname.ftype). During this process, all existing data is erased from the diskette. This is much faster than <I>Backup.Format</I> and corresponds to a DOS FORMAT d:/Q/V command.<P><H2><A NAME="28"></A>Initializing in Oberon format - Backup.InitOberon</H2><B>Backup.InitOberon [volName]</B> initializes a formatted diskette i.e. creates an Oberon directory, and sets a volume label. <I>volName</I> must be a name or any string enclosed in quotes. During this process, all existing data is erased from the diskette. This is much faster than <I>Backup.Format</I>.<P><H2><A NAME="29"></A>Viewing the contents of a diskette - Backup.Directory</H2><B>Backup.Directory[\d]</B> opens a text viewer named "Backup.Directory" displaying the directory of the diskette in the selected drive. If the option \<I>d</I> follows the command without blanks, the listing includes the date and the time of file creation and the file size in bytes. The viewer is opened in the <A HREF="#Track">system track</A> unless the <A HREF="#VPlace">pointer</A> is set.<P>For an empty formatted diskette the following information is displayed:<BR>&nbsp; &nbsp; DD - 720KB&nbsp; &nbsp; after formatting&nbsp; &nbsp; &nbsp; &nbsp; free 112 entries/ 713 KB<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; after initializing&nbsp; &nbsp; &nbsp; &nbsp;  free 111 entries/ 713 KB<BR>&nbsp; &nbsp; HD - 1.44MB after formatting&nbsp; &nbsp; &nbsp; &nbsp; free 223 entries/ 1423 KB<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; after initializing&nbsp; &nbsp; &nbsp; &nbsp;  free 222 entries/ 1423 KB<P><H2><A NAME="30"></A>Reading all files from a diskette - Backup.ReadAll</H2><B>Backup.ReadAll</B> copies all files from the diskette in the selected drive to the hard disk.<B><BR>Caution</B>: If a file name on the diskette matches a file name on the disk, that file is overwritten.<P><H2><A NAME="31"></A>Reading files from diskette - Backup.ReadFiles</H2><B>Backup.ReadFiles {name} ~ | ^</B> reads all files specified by the parameter list from the diskette in the selected drive to the hard disk.<B><BR>Caution</B>: If a file name on the diskette matches a file name on the disk, that file is overwritten.<P><H2><A NAME="32"></A>Writing files to diskette - Backup.WriteFiles</H2><B>Backup.WriteFiles {name} ~ | ^</B> writes all files specified by the parameter list to the diskette in the selected drive.<B><BR>Caution</B>: If a file name on the disk matches a file name on diskette, that file is overwritten.<P><H2><A NAME="33"></A>Deleting files from diskette - Backup.DeleteFiles</H2><B>Backup.DeleteFiles {name} ~ | ^</B> deletes all files specified by the parameter list from the diskette in the selected drive.<B><BR>Caution</B>: Don't forget to terminate the parameter list with a "~".<P><H2><A NAME="34"></A>Using a DOS formatted diskette</H2>The diskette format used by the Oberon system is close to the DOS format. Full compatibility may be achieved through two commands exported by module System.<P><H3><A NAME="35"></A>Importing from DOS - System.CopyFromDOS (obsolete)</H3>The directory of a DOS diskette is modified to be readable by an Oberon system.<P><H3><A NAME="36"></A>Exporting to DOS - System.CopyToDOS (obsolete)</H3>The directory of an Oberon diskette is modified to be compatible with the DOS format.<P>Caution: File names may be changed (capitalized and truncated).<P><HR><H1><A NAME="DisketteWin"></A>Using a diskette - Oberon for Windows</H1><BR>Diskettes are primarily used to back-up files of the hard disk. The commands exported by the command module <B>DOSBackup</B> serve to:<BR>&nbsp; &nbsp; o initialize diskettes<BR>&nbsp; &nbsp; o display the directory of diskettes<BR>&nbsp; &nbsp; o read files from diskette to hard disk<BR>&nbsp; &nbsp; o write files from hard disk to diskette<BR>&nbsp; &nbsp; o delete files from disketteA <CALL CMD="System.Open DOSBackup.Tool "><FONT COLOR=FF0000>DOSBackup tool</FONT></CALL> presents a set of commands ready for execution with the mouse.<P>DOSBackup is the backup utility for Oberon for Windows. It maintains on diskette an extra file _TRANS.TBL containing a translation table of Oberon long names to DOS names.<P>Macintosh Note:<P>You can only use this tool on your Macintosh if you installed MacOS 7.5 or any tool that extends you computer with the capability of reading MSDOS diskettes (e.g. PC Exchange).<P><H2><A NAME="37"></A>Initializing a diskette - DOSBackup.Init</H2>Any diskette formatted with a standard DOS formatter may be used.<P><B>Backup.Init</B> erases all the Oberon files and the translation table file on the diskette in the selected drive. Note that all the other DOS files stored on the diskette are <B>not</B> affected.<P><H2><A NAME="38"></A>Viewing the contents of a diskette - DOSBackup.Directory</H2><B>DOSBackup.Directory</B> opens a viewer named "A:/*" displaying the directory of the diskette. The listing shows the Oberon files with their long file names based on the information stored in the translation table. The viewer is opened in the <A HREF="#Track">user track</A> unless the <A HREF="#VPlace">pointer</A> is set.<P><H2><A NAME="39"></A>File management commands</H2><A NAME="40"></A><B>DOSBackup.ReadAll</B> copies all files from the diskette to the hard disk.<B><BR>Caution</B>: If a file name on the diskette matches a file name on the disk, that file is overwritten.<P><A NAME="41"></A><B>DOSBackup.ReadFiles {name} ~ | ^</B> reads all files specified by the parameter list from the diskette to the hard disk.<B><BR>Caution</B>: If a file name on the diskette matches a file name on the disk, that file is overwritten.<P><A NAME="42"></A><B>DOSBackup.WriteFiles [%] {name} ~ | ^</B> writes all files specified by the parameter list to the diskette and updates the translation table file. If the option % is used, the files are compressed (using the LZW compression algorithm). Compressed files have a special header that is recognized by the commands ReadFiles and ReadAll; that is, no option is required by these commands.<B><BR>Caution</B>: If a file name on the disk matches a file name on diskette, that file is overwritten.<P><A NAME="43"></A><B>DOSBackup.DeleteFiles {name} ~ | ^</B> deletes all files specified by the parameter list from the diskette and updates the translation table file.<B><BR>Caution</B>: Do not forget to terminate the parameter list with a "~".<P><HR><H1><A NAME="SysCmd"></A>System commands</H1><BR>The command module System provides the following facilities:<BR><UL><BR>- <A HREF="#FileAdm">file administration</A><BR>- open documents (i.e. document viewers) and the Oberon log<BR>- close, copy and enlarge viewers and tracks, recall previously closed viewers<BR>- display system state information<BR>- unload modules and force garbage collection<BR></UL><BR><H2><A NAME="SysOpen"></A>Controlling the viewers in the tracks</H2><A NAME="44"></A><B>System.Open name | [^]</B> opens a text <A HREF="#Viewer">viewer</A> named <B>name</B> and, if a file with the same name exists, displays the file contents in the viewer. Otherwise the viewer is empty. The viewer is opened in the <A HREF="#Track">system track</A> unless the <A HREF="#VPlace">pointer</A> is set.<B><BR>Note:</B> The selection is also searched if the text line is empty after the command name.<P><A NAME="45"></A><B>System.Copy</B> opens a copy of the <A HREF="#Viewer">viewer</A> in which <I>System.Copy</I> is executed (from the title bar or from the main text). The copy displays the <B>same</B> data as the original viewer. Almost exclusively used from the title bar. <B>The</B> command that makes a <A HREF="#LargeSelect">large selection</A> possible. But, click here <CALL CMD="System.Copy"><FONT COLOR=FF0000>System.Copy</FONT></CALL> you will be surprised! You now have cloned your desktop: whatever you do in one is reflected in the other. Please middle click on the "Close" button under "Oberon.Desk" to remove the copy.<P><A NAME="46"></A><B>System.Grow</B> enlarges the viewer in which the command is executed (from the title bar or from the main text). An overlay track is opened and the viewer grows to cover the whole track or, if applied to a viewer already filling a track, to cover the whole display. The enlarged viewer displays the <I>same</I> data as the original one.<P>In the overlay track, other viewers may open and close in the usual manner. If the last viewer in the overlay track closes, the underlying track is restored.<BR><A NAME="SysClose"></A><BR><A NAME="47"></A><B>System.Close</B> removes a viewer from the display: if executed from the title bar, it removes the viewer containing the title bar, and if executed from a main text, the marked viewer. The viewer adjacent (on top) to the one which is closed reclaims the freed display area. If the track is an overlay, the underlying track is recovered.<P><B>Note</B>: The viewer's contents are NOT saved to disk. If the viewer is erroneously closed before saving to disk (Store), data may be permanently lost, but the viewer may be reopened with <A HREF="#SysRecall">System.Recall</A>.<P><H2><A NAME="48"></A>Controlling the Oberon log</H2><A NAME="49"></A><B>System.OpenLog</B> opens a text viewer named "System.Log" displaying the system-wide log. It is a copy of an existing one. The log is updated regardless of its visibility. Therefore, the log always shows the complete history of the current session. The viewer is opened in the <A HREF="#Track">system track</A> unless the <A HREF="#VPlace">pointer</A> is set.<P><A NAME="50"></A><B>System.ClearLog</B> clears the contents of the Oberon log, regardless of its visibility.<P><H2><A NAME="SysRecall"></A>Reopening the viewer closed last - System.Recall</H2><A NAME="51"></A><B>System.Recall</B> reopens the most recently (perhaps erroneously) closed viewer. This command is very useful to recover data lost through inadvertent use of the command <A HREF="#SysClose">System.Close</A>.<P><H2><A NAME="52"></A>Closing a track - System.CloseTrack</H2><B>System.CloseTrack</B> closes the marked track, i.e. removes all viewers in this track. If the track is an overlay, the underlying track is recovered.<P><H2><A NAME="53"></A>Displaying / setting time and date - System.Time</H2><B>System.Time [dd mm yy hh mm ss}</B> If the command has no parameter, for example if it is followed by a special symbol <CALL CMD="System.Time ~"><FONT COLOR=FF0000>System.Time~</FONT></CALL>, then the date and time are displayed in the system log. With parameters, date and time are set. The symbols <I>dd</I>, <I>mm</I>, <I>yy</I>, <I>hh</I>, <I>mm</I>, and <I>ss</I> are all two-digit blank delimited numbers denoting day, month, year, hour, minute and second of date and time to be set.<P><H2><A NAME="54"></A>Displaying free memory space - System.Watch</H2><B>System.Watch</B> displays the amount of free main memory space (in bytes) in the log.<P><H2><A NAME="55"></A>Initiating a garbage collection - System.Collect</H2><B>System.Collect</B> initiates a subsequent garbage collection.<P><H2><A NAME="Free"></A>Unloading modules - System.Free</H2><B>System.Free {moduleName[*]} ~ | ^</B> unloads every module specified by the parameter list. If a module name is immediately followed by "*", imported modules are also unloaded as far as possible. A module can only be unloaded if it has no client; that is, if it is not imported by another module which is still loaded. Therefore, the order of the module names in the parameter list may be significant. The command <A HREF="Compiler.html#Free">Builder.Free</A> offers more comfort.<P><H2><A NAME="56"></A>Freeing libraries - System.FreeLibraries</H2><B>System.FreeLibraries {libName} ~ | ^</B> frees shared libraries from memory. This is mostly a harmless operation, since the libraries will simply be loaded again when required. The garbage collector frees libraries automatically when they are not required anymore.<P><H2><A NAME="57"></A>Show commands exported by a module - System.ShowCommands</H2><B>System.ShowCommands moduleName | ^</B> opens a viewer named "System.ShowCommands" displaying a list of all the commands exported by the named module. If the module is not already loaded, it is automatically loaded.<P><H2><A NAME="58"></A>Show loaded libraries - System.ShowLibraries</H2><B>System.ShowLibraries</B> opens a viewer named "System.Showlibraries" displaying a list of the currently loaded libraries.<P><H2><A NAME="59"></A>Displaying loaded modules - System.ShowModules</H2><B>System.ShowModules</B> opens a viewer named "System.ShowModules" displaying a map of all currently loaded modules. The state of any particular module can be obtained with the 'System.State' command.<P><H2><A NAME="60"></A>Displaying the active tasks - System.ShowTasks</H2><B>System.ShowTasks</B> opens a viewer named "System.ShowTasks" displaying a map of all currently active tasks.<P><H2><A NAME="61"></A>Displaying a module's state - System.State</H2><B>System.State moduleName | ^</B> opens a viewer named "System.State" displaying the global data of the named module if it is loaded: all scalar variables and strings together with their values are listed in alphabetical order. If not, the viewer's text is:<BR>&nbsp; &nbsp; moduleName not loaded<P>The Internet tools use the module 'NetSystem' which is controlled by a section of the oberon.ini file. Issue the command 'System.State NetSystem' to verify its presence.<P><H2><A NAME="62"></A>Controlling the global text attributes</H2><A NAME="63"></A><B>System.SetFont fontName | ^</B> applies the font specified by the parameter to subsequently typed characters. The parameter must specify a valid font name.<P><A NAME="64"></A><B>System.SetColor colorNumber | ^</B> applies the color specified by the parameter to subsequently typed characters. The parameter must be an integer denoting a color in the color palette.<P><A NAME="65"></A><B>System.SetOffset offsetNumber | ^</B> applies the vertical offset specified by the parameter to subsequently typed characters. The parameter must be an integer designating the vertical character offset.<P><HR><H1><A NAME="registry"></A>The Registry</H1><B></B>Oberon for Windows has a mechanism to store configuration data permanently. The permanent storage is called the registry. The registry is structured hierarchically into sections and keys. Each section can be thought of as a dictionary that associates a value with a key. Module Registry provides a program interface to the registry (see below). The user interface is embodied in the commands System.Set and System.Get.<P><A NAME="66"></A><B>System.Set ^ | section key := [ value ]</B> enter a section and key in the registry and associate a value with it. If a value is not given, the entry for the given section and key is removed from the registry. Section, key, and value may be either names or strings.<P><A NAME="67"></A><B>System.Get ^ | section [ key ]</B> inspect the value of a given section and key in the registry. If a key is not given, all keys contained in the section are listed together with their associated values. Section and key may be either names or strings.<P><HR><H1><A NAME="68"></A>What's next?</H1>Proceed with the study of the Oberon System 3 graphical user interface (GUI) named Gadgets, starting with the tutorial <A HREF="GadgetsIntro.html#">Introduction to Gadgets</A>.<BR><HR><BR>Revised, afi 11 Dec 1996<BR>Installed on 14 Feb 1997<HR></BODY></HTML>