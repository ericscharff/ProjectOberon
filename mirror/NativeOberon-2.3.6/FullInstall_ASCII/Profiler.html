<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML Level 2.0 2//EN"><!-- Generated by Text2HTMLGIF (afi, ejz)--><HTML><HEAD><META NAME="Author" CONTENT="Andre Fischer"><TITLE>Profiler User's Guide</TITLE></HEAD><BODY><H1><CENTER>Profiler User's Guide</CENTER></H1><HR><CENTER><B>[ Text | <A HREF="Profiler.Contents.html">Contents</A> | <A HREF="Profiler.Index.html">Index</A> | <A HREF="Big.Index.html">Master index</A>]</B></CENTER><BR><BR><H1><A NAME="0"></A>Tutorial objective</H1>Learn how to measure the execution speed of your system extensions.<P>Estimated time: 10 minutes.<P>Note: The profiler is not available on Native Oberon.<HR><H1><A NAME="1"></A>Using the profiler</H1><BR>The <I>profiler</I> is a <I>performance measurement</I> tool consisting of only just five Oberon commands, which are listed in the <CALL CMD="Desktops.OpenDoc Profiler.Tool"><FONT COLOR=FF0000>Profiler.Tool</FONT></CALL> and are described below.<H2><A NAME="2"></A>Principle of operation</H2>The profiler adds profiling code to the entry and exit points of the procedures in a module. Consequently, the module source text is required. This allows a detailed measurement of the number of times a procedure is called, how much time is spent in a procedure in total, and the time spent on average per procedure call. As the measurement itself influences the results, the elapsed times must be regarded in relation to each other. On a Macintosh, the elapsed time is measured in microseconds whereas on a Intel based system, the elapsed time is measured in ticks of less than 1 microsecond.<BR><A NAME="3"></A><BR>The profiler is split into two modules: Profiler, which implements the instrumentation and the user interface, and a low-level module (cAP i.e. <I>call Attribute Profiler</I> or Profiler0), which does the actual measurement. This module does not import any other module and can thus be imported by even the lowest modules in the module hierarchy.<P><B>Current limitation:</B> The profiler requires some additional storage for a call trace. Recursive procedures may use more memory than normal when profiled and may, in cases of very deep recursion, cause a memory allocation error.<P><H2><A NAME="4"></A>The profiler compiler - Profiler.Compile</H2><B>Profiler.Compile {moduleName} ~ | ^ | *</B> compiles the named modules, reporting success or failure to the Oberon log. This compiler accepts the same options as the Compiler.<P>If the compilation fails, the error(s) are listed in the log in exactly the same manner as the Compiler, and an unnamed document viewer is opened. It shows the original module text in the marked viewer extended with the profiling code inserted by the cAP module. The position of the errors apply to the text in that viewer, and errors can be located using the System.Locate command. The same text can be displayed at any time using the <I>Profiler.ShowCode</I> command described below.<P><B>Example:</B><P>The module ProfilerExample.Mod, delivered with the system, demonstrates the difference in execution time between two different implementations of simple data output to the Oberon log: one using the module Out and the other using a writer and the module Texts.<P>Compile the module with:<BR><UL><BR><CALL CMD="Profiler.Compile ProfilerExample.Mod ~"><FONT COLOR=FF0000>Profiler.Compile ProfilerExample.Mod ~</FONT></CALL><BR></UL><BR>and execute the command: ProfilerExample.Do<P><H2><A NAME="5"></A>Show the profiler counters - Profiler.Show</H2><B>Profiler.Show</B> opens a document viewer named "Profiler.Show" displaying the profiler counter values in a table. Each table entry presents the number of times a procedure was called, the time spent on average per procedure call, the total time spent in a procedure and the percentage of time spent in a procedure in relation to all the measured time in all modules. The time spent in RETURN statements cannot be measured. If a profiled module calls an unprofiled procedure, the time spent in unprofiled code is <I>added</I> to the procedure in the profiled code.<P>Now execute: Profiler.Show to display the data collected during the execution of the previous command.<P><H2><A NAME="6"></A>Reset the profiler counters - Profiler.Reset</H2><B>Profiler.Reset</B> resets the profiler counters.<P><H2><A NAME="7"></A>Show the profiler code - Profiler.ShowCode</H2><B>Profiler.ShowCode *</B> opens an unnamed document viewer, showing the module text in the marked viewer extended with the profiling code inserted by the cAP module. This can be useful for debugging purposes.<P>Display the module's text with:<BR><UL><BR><LI>execute <B>Desktops.OpenDoc</B> ProfilerExample.Mod<LI>mark (F1 key) the viewer just opened<LI>then execute: <B>Profiler.ShowCode *</B> to see how the text was modified.</UL><BR><H2><A NAME="8"></A>Show memory dump - Profiler.ShowMem  (Windows only)</H2><B>Profiler.ShowMem</B> opens a document viewer named "MemoryDump.Text" showing the memory allocated by modules. The memory dump shows the size of the module data (code + data + type descriptors), the number of objects allocated on the heap with a type declared in that module and their total size. The size includes the size of the type tag pointer (4 bytes). Currently the profiler does not identify all allocated memory. The last part of the dump indicates how many bytes could not be identified.<P>The information displayed is equivalent to that provided by the command System.ShowModules. System.Watch also supplies information on the number of bytes allocated.<P><HR><H1><A NAME="9"></A>What's next?</H1>Use this valuable source of information when developing your own system extensions.<BR><HR><BR>Revised, 01 Dec 1996<BR>Installed on 14 Feb 1997<HR></BODY></HTML>