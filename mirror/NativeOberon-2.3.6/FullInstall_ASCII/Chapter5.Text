
Chapter Five

The Programmer's Guide






5.1	Introduction

Programming with the Oberon system involves extending the Oberon run-time environment. The reader familiar with programming will equate programming with writing a program. Once completed, the program is run. The program requests input data, does some calculation, and then outputs the result. This may happen many times until the program terminates and releases the resources it used.
	In Oberon, there are no programs. Programs are relics of the days when computers had little memory and other resources. Programs wait in line until the user decides to execute them. After termination, the program removes itself from memory to make space for the next program. Communication between different programs running at different times takes place by storing a message in non-volatile storage (a file for example). Today however, computers have more memory and programs routinely run concurrently with each other. This is called multi-tasking. The computer resources are shared between all running programs. Unfortunately, communication between different programs has not progressed much further than in the earlier days of batch processing, which makes the cooperation and integration of different programs a difficult task.
	The reason for this state of affairs can be traced back to the technology used for writing programs. If a program were unsafe, that is, doing the wrong thing, it could damage the integrity of the system, and thus negatively influence the other programs running on the computer. Most of today's programming languages allow the programmer to write (knowingly or unknowingly) programs that crash the system when run. Rather than solving the problem at its root (i.e. the bad programs), software systems started using the concept of memory protection. Using memory protection, a program is encapsulated in a "shield", preventing other programs from damaging it. Sadly enough, a memory protection shield also prevents easy communication with a program, thus hindering integration and cooperation between different programs.
	In contrast, the Oberon system is an example of an open and extensible system. Open means that a high level of cooperation, integration and re-use of code between applications is practised. Extensible means that anybody can add a new part to the Oberon system. This new part might be using a part somebody else added, or might be used itself by another part added later. To achieve this flexibility, Oberon does away with programs completely. Instead, Oberon provides two concepts: modules and type safety.

Modules.	An Oberon module contains (part of) the executable program code of an Oberon application. Modules are typically much smaller than programs, and an application often consists of more than one module. The modules of all activated Oberon applications share the memory of the Oberon system. There are no barriers between modules of different applications. Once loaded into memory, a module normally remains there until the computer is switched off. A module X may use (or re-use) the code contained in other modules A, B, C, etc. We say that module X imports modules A, B, C, and that module X is a client of modules A, B and C. Because a module is always visible to other modules (when in an import relationship), a large level of code or module re-use is possible. That means that applications can share useful modules between each other. For example, the Oberon system provides modules for managing text, bitmaps, data compression, network communication like file transfer and e-mail. These and other modules are often shared between different applications. The set of modules loaded into memory form the module hierarchy. The Oberon module hierarchy is a directed acyclic graph (DAG), in other words, no recursive imports are allowed.
	But how do modules get into the computer memory in the first place? The Oberon system contains a module loader that can dynamically load and link a module into the running system. All imported modules are loaded automatically if they are not loaded into memory already. Instead of running a program, Oberon allows you to execute a command located in a module. A command is nothing more than a procedure located in a specific module, that is, a command M.P results in procedure P of module M being called. Thus, executing a command will result in a module being loaded into the system (from disk) by the module loader. The module typically remains in memory until the computer is shut down or until it is freed explicitly by the user.

Type safety.	To prevent a module from corrupting the system, a danger in such an open arrangement, the Oberon programming language provides type safety. Type safety guarantees that a module cannot do bad things (by mistake or on purpose) to the system and to other modules. This is accomplished by a strong typing system in the Oberon language, and by checking the correct use of modules by the Oberon compiler. Each module provides additional functionality to the Oberon system, the use of which is determined by the module's interface or definition. The interface of a module tells us what components of a module are visible to the outside world (i.e. to the other modules in the system).
	We say that these components are exported from the module. Type safety ensures that only these components and nothing more can be accessed by client modules. This allows the Oberon programmer to hide implementation details behind module interfaces and so ensure that private data structures can not be altered from outside the module. The value of type safety should not be underestimated. It protects the system and the programmer in a world of hundreds of cooperating but also at times menacing modules.
	How do modules communicate with each other? As expected, one module can call the exported procedures of other modules directly. Another powerful technique is to share data structures between modules. In Oberon, all dynamically allocated memory is shared by modules in the so-called heap. Type safety ensures that only valid references to memory allocated on the heap are passed as pointers from one module to another. In fact, this is the basis of much of the run-time behavior of the Oberon system. We can imagine the heap to be a large database of collective data. Activating a command causes a module to transform data in the database, the result of which is again inserted into the database. This is a powerful way for applications to communicate directly without barriers, and even for applications to influence each other. As an example we can write a module containing a command that colors all the occurrences of the word "and" in a text document in red - simply by directly accessing the abstract text data type of a text document. In a similar way, we can add new functionality to all Oberon applications.
	In conclusion, it should now be clear that Oberon has an advantage over other systems when it comes to integrating different applications with each other, protecting the system from the user (or the user against himself), supporting the ordered re-use of code, and constructing applications rapidly from prefabricated building blocks. The remainder of this chapter will enable you to do so yourself.


5.2	The Module Hierarchy

Learning to program the Oberon system involves studying the Oberon module hierarchy. From the modules themselves, you will learn the run-time structure of the system (i.e. the contents of the heap). There are lots of modules in the Oberon system and getting to know them all at once is not recommended. It is best to start with the easier modules and then work yourself up to the more difficult ones. Depending on your needs, you might not even need to learn how to build more complicated modules with the system - most of them are already available and can just be used "as is". If you fall into this category, the bulk of this chapter can be ignored, and you can concentrate on the programming of commands that manipulate existing components of the system. For this purpose, the examples provided later in this chapter are invaluable.
	First, we discuss the larger structure of the system. The Oberon modules can be conceptually divided into the inner core, the outer core, the object core, the text system, the gadget core, the gadget catalog and the document catalog. The inner core is responsible for memory management, file management, and module loading. The outer core additionally provides device drivers for display, printer, keyboard, mouse, network etc. Other parts of the outer core provide viewer management and task and event dispatching. The distinction between inner core and outer core is rather artificial. The inner core is the minimum part of the system that needs to be present to boot Oberon. It is consequently always present and statically linked into a boot image. The outer core contains other important parts of the system.
	The object core contains the Oberon persistent object manager, whilst the text system contains the font and text machinery. The gadget core provides the basis of the Gadgets component framework on top of which the remainder of the system is built. The gadgets catalog refers to the set of modules implementing the different gadgets. In the same manner, the document catalog refers to the modules of the different document classes. The remainder of the modules are typically command modules, that is, modules that have no clients and provide the commands the user sees. A command module mostly consists of parameterless procedures (commands). Each command module typically has a tool text, summarizing the usage of its commands, associated with it; for example, the System module has an associated text System.Tool. More graphically oriented modules have associated user interface panels.
	The Figure 5.1 shows an extract of the Oberon module hierarchy. This import diagram shows modules as rectangular boxes with lines showing the import relationship. An import diagram is read from the bottom to the top, the upper modules being the clients of the modules below. We will be discussing these modules in the remainder of the section, but first we summarize the functionality of some important modules. Note that this list is not exhaustive. Depending on the underlying hardware and software platform, some additional modules might be included in the inner core. Often a set of modules to interface with the underlying operating system are included. Their source text modules are typically named according to the operating system in use (Windows, Macintosh, Linux, etc).



Figure 5.1	Extract of the Oberon Module Hierarchy

	Furthermore, a single large module is sometimes split into two smaller modules for the sake of simpler management. In such a case, a "0" is appended to the name of the lower of the two modules in the import hierarchy. For example, TextGadgets is split in modules TextGadgets0 and TextGadgets. To be more explicit, we might add that TextGadgets0 implements the base functionality of an editor whereas TextGadgets is an extension of such an editor. In this case the two modules are tightly coupled and should logically be regarded as a single module.
	The remainder of this chapter gives examples how to use the Oberon modules. These examples should be studied in conjunction with the module definitions.

Summary of the Oberon Module Hierarchy

Module Name	Purpose

Inner Core
	Kernel	Memory management and garbage collection
	Disk	Disk driver (PC Native only)
	FileDir	File directory support
	Files	File handling
	Modules	Oberon module loader and command execution

Outer Core
	Display	Display driver
	Printer	Printer driver
	Input	Timer, keyboard and mouse driver
	V24	RS-232 serial communication port driver
	Pictures	Bit mapped graphics handling
	Reals	Floating point number support
	Math	Mathematical functions for REALs
	MathL	Mathematical functions for LONGREALs
	Viewers	Implementation of Viewers of the display system
	Oberon	Event handling and task dispatching
	System	Command module with system related functions
	Configuration	Configuration control at system startup

Object Core
	Objects	Persistent object and library manager

Text System
	Fonts	Font loader
	Texts	Abstract data type implementation for texts
	Out	Standard text output routines
	In	Standard text input routines

Gadget Core
	Display3	Clipped display routines
	Printer3	Clipped printing routines
	Effects	Special effects like rubber banding, cursors, menus.
	Attributes	Attribute handling routines for gadgets
	Links	Link handling routines for gadgets
	Gadgets	Toolbox routines for implementing gadgets

Gadget Catalog
	BasicGadgets	Implementation of gadgets like Boolean, Integer,
		Button, Slider, etc.
	TextFields	Implementation of Captions and TextFields
	Icons	Implementation of Icons and Iconizers
	ListGadgets	Implementation of list gadgets
	Panels	Implementation of Panels
	TextGadgets	Implementation of a text editor
	Rembrandt	The bitmap editor gadget
	...	and several more modules implementing
		other gadgets

Document Catalog
	Documents	Toolbox for implementing documents
	Desktops	Manager of the overlapping display system
	TextDocs	Implementation of text documents
	PanelDocs	Implementation of panel documents
	RembrandtDocs	Bit map editor toolkit
	...	and so on for other document classes
	

5.3	Procedure Calls, Input and Output

Before examining some modules of the Oberon system, we have to understand how modules are typically used. Each module adds some functionality to the Oberon system and can be used either by client modules that import the module or by users who execute commands of that module.

Static Procedure Calls.	Writing an Oberon module in the Oberon language involves importing other modules using the IMPORT statement (and thus making the module a client of the imported module). Importing makes the exported features of the imported module accessible to the programmer. This allows the programmer to access the exported global variables, types and procedures of the module. Typically, communication between the importing and imported module is realized by calling procedures of the imported module and passing parameters. This link is statically defined when the importing module is compiled and is correct according to the rules of type safety. For example, the called procedures may manipulate abstract data types like bitmaps, texts and the like.
	From the user's standpoint, using a module involves calling exported commands of a module. A command is an exported procedure with no formal parameters. Suppose we have the following module, which writes a message to the system log text using module Out:

	MODULE Hello;

		IMPORT Out;

		PROCEDURE World*;
		BEGIN
			Out.String("Hello, world!"); Out.Ln()
		END World;

	END Hello.

	Hello.World

The asterisk marking ("*") of procedure World indicates that it is an exported procedure. In addition, the lack of formal parameters indicates that it is a command. This implies that the procedure World of module Hello can be called directly with an MM key click on the string Hello.World written somewhere on the Oberon display. This can be likened to you the user "importing" the module Hello, and calling World:

	MODULE User;

		IMPORT Hello;

		PROCEDURE MyAction*;
		BEGIN Hello.World
		END MyAction;

	END User.

Of course, the latter module does not exist, not even in the mind of the user, as users do not think about making modules when they execute commands! It does however illustrate quite well that executing a command is nothing more than calling a procedure. Modules that export lots of commands are called command modules, and are seldom imported by other modules.

Dynamic Procedure Calls.	Suppose that we have the strings "Hello" and "World", and want to execute the corresponding command. This is the situation a typical text editor is faced with when a user clicks with the MM key on a string displayed on the screen, as the text editor knows only about texts (and thus strings). The solution is to request the module loader in module Modules to locate the correct procedure, which can then be called:

	MODULE DynamicCall;

		IMPORT Modules;

		PROCEDURE DoIt*;
		VAR mod: Modules.Module; P: Modules.Command;
		BEGIN
			mod := Modules.ThisMod("Hello");	(* load module, if not already loaded. *)
			P := Modules.ThisCommand(mod, "World");	(* locate command. *)
			P	(* and execute command. *)
		END DoIt;

	END DynamicCall.

	A few things should be observed. First, we are using module Modules to do some work for us. This is done by statically calling procedures and using the types of that module. To find out exactly what the module Modules (and also Out, which we met earlier) can do for us, we look up its definition. There we see that type Modules.Command is a PROCEDURE, and thus P can be called directly. In the remainder of this chapter, we will assume that you look up the definition of modules we use in our examples without prompting you as we are doing now. If you are working in front of the computer, the definition is as far away as activating Watson (Chapter 2).
	A second observation is that module DynamicCall does not import the module Hello; the command has been activated dynamically. As the called module lies typically higher up in the module hierarchy than the calling module, an up-call is involved. There are other examples of "calling up" in the module hierarchy.

A few more comments on the module Hello.	The system log is a model object of type Texts.Text. The content of the log text is automatically shown in the log viewer which is opened when the system is started. Module Out offers a comprehensive set of procedures for writing (in reality "appending") text stretches to the log, without a need to know how text is maintained and managed by the system. Writing a string (Out.String) and a carriage return (Out.Ln) are only two examples. Putting the other procedures to work is straightforward.

Parameter Passing.	Typically, when statically calling an imported procedure, parameters are passed. But how are text parameters passed to commands? We know already that most Oberon commands have parameters that are written following the command in the form of a text stream. By convention, the text parameters are passed from the caller (or client) to the callee by temporarily assigning them to a global variable (which will be discuss later). Thus the caller (the text editor, for example), puts a pointer to the text parameter in this global variable and uses module Modules to call the command. The called command picks up the parameters from the global variable and processes them; simple but effective.
	To get beginners started as soon as possible with Oberon, the scanning of command parameters is however hidden or covered by a module called In. That is, the whole process of parameter passing that happens behind the scenes, is hidden from us (until the next section, at least). This is illustrated by Example1 which sums up a series of numbers:

	MODULE Example1;
		IMPORT In, Out;

		PROCEDURE Sum*;
		VAR x, total: REAL;

		BEGIN
			total := 0;
			In.Open;	(* Initialize parameter scanning. *)
			In.Real(x);	(* Scan a REAL parameter into x. *)
			WHILE In.Done DO	(* Was a REAL really encountered? *)
				total := total + x;
				In.Real(x)	(* Try scanning the next number. *)
			END;
			Out.String("The total is "); Out.Real(total, 10);
			Out.Ln
		END Sum;

	END Example1.

This example expects the parameters to be summed to be written as follows:

	Example1.Sum 4  8  1AFH  4.0E2~

Note the "~' which ends the parameter list. Not being a numeric value, In.Done is false after scanning "~", and thus the summing loop is terminated. (Did you already take a look at the definition of In?)
	In.Real delivers the next REAL value, resulting from the conversion of a textual stream of digits. All other procedures in module In have similar properties.


5.4	Texts

As most readers probably noticed while studying module In, this technique of scanning parameters is not very robust since the programmer has to assume that the correct parameters are passed to the command. A more reliable way of scanning parameters is implemented behind the scenes of module In, the investigation of which also reveals the "parameter scratchpad" introduced before. Also, module Out hides the complexity of writing text to the log, which is implemented behind the scenes with lower level modules.
	To understand what the modules In and Out do, we need to introduce to two further modules, namely Texts and Oberon. Module Texts defines an abstract data type that manages text streams. Module Oberon has a few system-wide tasks, one of which involves managing the previously mentioned global variable which is called Oberon.Par. Oberon.Par is a RECORD containing a reference to the parameter text (Oberon.Par.text), to the starting position in that text (Oberon.Par.pos), and diverse other fields describing the environment in which the command was executed. The parameter text starts at the position Oberon.Par.pos in the text, with the first character in a text having position zero. Further study of the component Scanner in module Texts shows that it is useful for scanning parameters. It parses the associated text for tokens. While parsing, white spaces (i.e. blanks, TAB characters and RETURN characters) are skipped. The same example can now be rewritten without the use of module In, by replacing it with a Scanner:

	MODULE Example2;
		IMPORT Oberon, Out, Texts;

		PROCEDURE Sum*;
		VAR total: REAL;
				S: Texts.Scanner;
		BEGIN
			total := 0;

			(* Open a Scanner at the starting position of the parameter. *)
			Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
			Texts.Scan(S);	(* Scan first parameter. *)
			WHILE (S.class = Texts.Int) OR (S.class = Texts.Real) DO
				IF S.class = Texts.Int THEN
					total := total + S.i
				ELSE
					total := total + S.x
				END;
				Texts.Scan(S)	(* Scan next parameter. *)
			END;

			Out.String("The total is "); Out.Real(total, 10); Out.Ln
		END Sum;

	END Example2.

	Example2.Sum 4  8 1AFH 4.0E2~

The field class of the scanner tells us what was scanned; that is, it identifies the type of the scanned symbol. Depending on its type, the scanned value must be retrieved from a different scanner field.
	In fact, module Texts provides much more than Scanners. In Example2, we still used module Out for writing output to the log, but Out is easily replaced with a Writer. Writers are used for efficiently creating large amounts of text. Module Out uses a Writer "behind the scenes" to write its output to the system log. A typical example of using a Writer is the following:

	MODULE Example3;
		IMPORT Oberon, Texts;
		VAR W: Texts.Writer;

		PROCEDURE Time*;
			VAR time, date: LONGINT;
		BEGIN
			Oberon.GetClock(time, date);
			Texts.WriteString(W, "The date and time are ");
			Texts.WriteDate(W, time, date);
			Texts.WriteLn(W);
			Texts.Append(Oberon.Log, W.buf)	(* Append W's text buffer to the log *)
		END Time;

	BEGIN Texts.OpenWriter(W)	(* Initialize Writer at module load time. *)
	END Example3.

	Example3.Time

Usually, only one shared writer is declared per module. The text written to a Writer is temporarily kept in the writer's buffer W.buf. Then, the writer's buffer is appended (Texts.Append) to a text and subsequently cleared in the operation (a side effect). Further writing to the Writer starts filling up the buffer again until it is cleared again. There is practically no limit to the size of a buffer or a text. Finally, notice how the system log is represented by a global variable called Oberon.Log of type Texts.Text.

The Text selection.	The text selection is an integral part of the Oberon system. The current text selection is the text stretch last selected by the user. More than one selection may be visible, but only the most recently selected stretch (according to system time) is important to us. The procedure Oberon.GetSelection returns the required information on the latest selection: the text itself, the starting and the ending position of the selection, and the time (according to Oberon.Time) when the selection was made. To obtain the latest selection, Oberon.GetSelection broadcasts a special message to all the text editors active in the system to return their selection. At the moment though, the exact behavior can be ignored.
	What can we do with the selection? We already know about the Texts.Scanner, so we can use it to scan for tokens in the selection. We can also use a Texts.Reader to read through the selection character by character. Readers are new in our discussion, so we present an example of a Reader calculating some statistics about the selection:

	MODULE Example4;
	IMPORT Oberon, Texts;
	VAR W: Texts.Writer;

	PROCEDURE Count*;
	VAR T: Texts.Text;
			beg, end, time: LONGINT;
			letters, digits, others: INTEGER;
			ch: CHAR;
			R: Texts.Reader;
	BEGIN
		Oberon.GetSelection(T, beg, end, time);
		IF time >= 0 THEN	(* is a selection present? *)
			letters := 0; digits := 0; others := 0;
			Texts.OpenReader(R, T, beg);	(* start reading at position beg in text T. *)
			Texts.Read(R, ch);
			WHILE beg < end DO
				CASE ch OF
					"A" .. "Z", "a" .. "z": INC(letters);
					| "0" .. "9": INC(digits)
				ELSE INC(others)
				END;
				INC(beg);
				Texts.Read(R, ch)
			END;

			Texts.WriteString(W, "# digits = "); Texts.WriteInt(W, digits, 10); Texts.WriteLn(W);
			Texts.WriteString(W, "# letters = "); Texts.WriteInt(W, letters, 10); Texts.WriteLn(W);
			Texts.WriteString(W, "# others = "); Texts.WriteInt(W, others, 10); Texts.WriteLn(W);
			Texts.Append(Oberon.Log, W.buf)
		END
	END Count;

	BEGIN	Texts.OpenWriter(W)
	END Example4.

	Since the selection is always a valid text stretch (starting at the character position beg and ending just before character position end), we do not have to be concerned about reading past the end of the text. If Oberon.GetSelection fails to find a selected text stretch, the time field contains a negative value. Each text T has T.len characters, and when the reader R reads the T.len'th character, the boolean flag R.eot indicates that the end of the text has been reached. The condition beg < end can be replaced by ~R.eot to read past the end of the selection right up to the end of the text containing the selection.

Opening a text viewer.	How do texts get on the display anyway? Usually, an end-user opens a text file by executing a Desktops.OpenDoc command. We can open a text file also under program control with the following module:

	MODULE Example5;
	IMPORT Oberon, Texts;

	PROCEDURE Open*;
	VAR
		S: Texts.Scanner;
		T: Texts.Text;
		beg, end, time: LONGINT;

	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Texts.Scan(S);
		IF (S.class = Texts.Char) & (S.c = "^") THEN
			Oberon.GetSelection(T, beg, end, time);
			IF time >= 0 THEN	(* is a selection present? *)
				Texts.OpenScanner(S, T, beg);
				Texts.Scan(S)
			END
		END;
		IF S.class = Texts.Name THEN	(* was a valid file name scanned? *)
			NEW(T); Texts.Open(T, S.s);
			Oberon.OpenText(S.s, T, 250, 200)
		END
	END Open;

	END Example5.

This module is invoked with

	Example5.Open Example4.Mod~

or

	Example5.Open ^		[the name of a text file is selected]

to open the text file whose name is passed as a parameter (and scanned with the scanner above). During parameter scanning, we explicitly test for the case when a "^" is used as a parameter. In this case, we have to re-open the scanner on the current text selection, as Oberon command conventions indicate. The statement NEW(T) creates an empty text descriptor on the heap, which is subsequently filled with text by Texts.Open(T, S.s). S.s contains the name of the file from where the text is retrieved. Should we require an empty text instead (i.e. one containing no characters), we should replace the latter with Texts.Open(T, ""). The procedure Oberon.OpenText presents the text T in a text document ready for editing. The first argument to Oberon.OpenText is the title of the document, followed by the text to be displayed and the width and height in pixels of the viewer. The latter is regarded as a hint to the system where to open the text document viewer. For example, should the width be wider than the system track, the system will open the viewer in the user track. Hint: the width ratio of the user and the system tracks is 5 to 3.
	Multiple calls to Oberon.OpenText with the same text T as parameter will create a fresh viewer in each case, and that each will be displaying the same text. Thus, changes made in one text document will be reflected in the others automatically. We say that the viewers are the view components, and the text T is the model component. On the other hand, multiple executions of Example5.Open create fresh viewers displaying separate texts.

Retrieving the marked text.	Once a text is displayed by a text document, how can we get back to the text itself again? By convention, Oberon requires the user to mark the intended text with the star marker ("*") which is set by hitting the F1 key on the keyboard when the mouse focus is located inside the document's viewer. A helper procedure Oberon.MarkedText returns the marked text.

	MODULE Example6;
	IMPORT Fonts, Oberon, Texts;

	PROCEDURE Highlight*;
	VAR T: Texts.Text; fnt: Fonts.Font;
	BEGIN
		T := Oberon.MarkedText();	(* get marked text *)
		IF T # NIL THEN	(* was a text found? *)
			fnt := Fonts.This("Syntax10m.Scn.Fnt");
			Texts.ChangeLooks(T, 0, T.len, {0}, fnt, 0, 0)	(* change font of entire text *)
		END
	END Highlight;

	END Example6.

	Example6.Highlight

In this example we introduce fonts. Font management is done under control of the Fonts module. In the present case, Fonts.This loads a 10 point Syntax screen font, which is then applied to the whole text T (characters 0 to T.len) with Texts.ChangeLooks. ChangeLooks can also be used to change the color and the vertical offset of a text stretch. More details can be found in the definition of Texts.
	Before continuing our examples for manipulating texts, we need to cover some necessary theory first. The following two sections introduce the display space, messages and broadcasting.


5.5	The Display Space

In earlier chapters, the display space was introduced. In essence, the display space is a data structure containing visual and non-visual objects. The visual objects, called frames, are the gadgets such as documents, Buttons, Scrollbars, etc. you see on the display. The non-visual objects are the model gadgets linked to these gadgets. We should emphasize here the abstract nature of the display space we are referring to. The display space should not be confused with the geometrical space of the display screen. To understand the display space, we have to discuss the nature of the single elements of the display space, and the nature of the connections between them.

The type hierarchy.	Before going into detail about the structure of the display space, we first investigate the type hierarchy of the visual and non-visual objects. All visual objects are extensions of the type Display.Frame. In turn, each frame is an extension of a more basic type called Objects.Object. The non-visual objects are also extensions of Objects.Object, but not of Display.Frame.



Figure 5.2	The Object type hierarchy
			The lines of Figure 5.2 show the type extension relationship between objects. To simplify the programming of gadgets, two further base types form the basis of the visual and model gadgets. These two types, Gadgets.Frame and Gadgets.Object are extensions of Display.Frame and Objects.Object respectively. Thus when programming gadgets, we are faced with the type hierarchy depicted in Figure 5.3.
	
Figure 5.3	Base system / Gadgets system relationship

	The double horizontal line of Figure 5.3 signifies a split between the base system and the Gadgets system. There is a good reason for emphasizing this split. The base system provides the mininum for implementing a framework of components. The Gadgets system "fills in" part of the functionality in this framework, that is, it adds rules and user interface conventions. Theoretically, we can imagine yet another type of user interface system built on the same base but implementing a different type of user interface framework. In fact, the textual user interface of the Oberon system is such a framework which existed before the development of the Gadgets system. This also illustrates that such a dichotomy turns out useful for guaranteeing compatibility with older applications, as both gadgets-enabled and older applications are different aspects of the same underlying object model.
	Before continuing with the display space structure, it is informative to show the type definitions of Objects.Object and Display.Frame, although the meaning of several of the RECORD fields is not obvious yet, and thus partially hidden:

	Handler = PROCEDURE (obj: Object; VAR M: ObjMsg);

	Object = POINTER TO ObjDesc;
	ObjDesc = RECORD
		... some more fields ...
		handle: Handler	(* Message handler. *)
	END;

	Frame = POINTER TO FrameDesc;
	FrameDesc = RECORD (Objects.ObjDesc )
		next, dsc: Frame;
		X, Y, W, H: INTEGER
	END;

The definition of Object reveals that each object has a message handler, which is responsible for interpreting the messages that are sent to it. Furthermore, we see that frames are type extensions of objects with the additional fields next, dsc, X, Y, W and H, which are described in the next paragraph.

The Display space structure.	Frames have a location and a size: the record fields F.X and F.Y contain the position of the frame F, and the record fields F.W and F.H its width and height. When a frame is located in the display space, it is always nested in another frame. The situation can be clarified in the following way, but for the sake of simplicity we shall confine the description to the tiled display space model used by the textual interface. The display itself is a large (imaginary) frame that covers the whole display surface. It has the location (0, 0) and size (Display.Width and Display.Height). (By the way, the origin of the Oberon display is in the bottom left corner, in contrast to many other systems.) This "root" frame is divided into two tracks, the user and the system tracks. Each track is a frame nested or contained in the root frame. The tracks are further divided into viewers, which are frames too (nested in their respective tracks). Each viewer is divided into two further frames, the menu bar frame and the main frame. The main frame might for instance contain a text editor frame. Inside this text editor frame we have the text itself, and possibly further frames signifying the visual objects that "float" in the text. These frames might contain further frames, and so on to any nesting depth.


Figure 5.4	Example structure of the display space

	The nested nature of the display space is extremely important in the system and should be well understood. Figure 5.4 gives a diagrammatic view of the situation. Frames containing other frames as children are called container gadgets. Frames not containing any further frames are elementary gadgets. Each parent frame is completely responsible for its direct descendant frames and thus indirectly responsible for its indirect descendants. By convention, the "nested" structure of the display space is defined by the two fields dsc and next of Display.Frame. The dsc field of a container points to the first child of that container, and is the start of a list of direct descendants linked by the next field. The following code fragment shows how the children of a container F are traversed:

	PROCEDURE Traverse (F: Display.Frame);
	VAR f: Display.Frame;
	BEGIN
		f := F.dsc;
		WHILE f # NIL DO
			... do something with f ...
			f := f.next
		END
	END Traverse;

Remark.	The property of parental control dictates which of these fields a frame may modify when receiving a message. A frame F is allowed to change its own F.dsc record field and the next fields of its direct descendants. But a frame should never change its own next field. This property also requires that you should never interfere with the dsc-next list of a container; although visible to the outside world, it is under complete control of the container itself. Later, we explain how external influences can be applied to containers.

	A further complication of the display space is the location of model gadgets. We already know that frames can possibly have a model linked to them. The visual gadgets, for example, reserve a field called obj to refer to a model gadget. As many frames can refer to the same model object, the use of these fields "close" the structure of the display space at the bottom (Figure 5.5). The general structure of the display space is that of a directed acyclic graph (DAG). In this Figure we have a Panel floating in two TextGadgets: the Panel containing a Button and a CheckBox both linked to a Boolean model.


Figure 5.5	Example structure of the display space with model objects

In our previous explanation, we mentioned that the location of a frame F in the display space is determined by the record fields F.X and F.Y. We have to specify exactly what this means in the context of the display space. By convention, F.X and F.Y are the relative coordinates of a frame in its parent (i.e. container) frame. As the Figure 5.6 illustrates, the X and Y fields of a frame measure the offset of its bottom-left corner relative to the top-left corner of its parent frame. Since the Oberon display origin is in the left bottom corner of the display, the Y offset of a gadget is always a negative number. This setup provides the best efficiency when calculating the coordinates of a gadget.

Figure 5.6	Frame coordinate system

We should mention that a parent frame clips away those parts of its children which lie outside the rectangle of the parent. The relative coordinates of a frame in a container allow us to move that container and all its descendants directly by modifying only the relative coordinates of the parent in its own container.


5.6	Messages and Broadcasting

Now that the structure of the display space has been presented in detail, we can discuss how objects (everything extended from Objects.Object) communicate with each other in the display space. Recall that every object in the Oberon system has a message handler, responsible for "handling" the messages sent to that object. There exists a large number of message types. For example, there are messages to request an object to make a copy of itself, to store itself to a file, to display or print itself, and so on. However, not every message is applicable to all objects. For example, model gadgets, that is, non-visual objects, do not understand a "display yourself" message.
	Messages are divided into classes. For the moment, we mention two important ones: object messages and frame messages. Object messages are those messages that all objects must respond to. This class consists of a very small collection of messages like "copy yourself", "store yourself" and so on. Frame messages are those messages that frames respond to. That class includes ones like "display yourself, "print yourself" and "move your position".
	Objects might not understand some of the messages sent to them. Why would we send a message to an object if it does not understand it anyway? The answer lies in the display space. Let us take the example of multiple text documents showing the same text (evoked in Example5). We already know that when we change the contents of a text (using module Texts), each text document displaying it is magically updated. Behind the scenes this is solved by a special message protocol between the text document (a view) and the text object (a model). This protocol is "special" in that only text documents and text objects are aware of it; they are "insiders", so to say.

Model-view consistency.	Let us trace what happens when a character is inserted into a text or more correctly from a programming standpoint, when a text buffer is inserted into a text. The user of module Texts does this with a call to Texts.Insert. Behind the scenes, Texts.Insert has to inform all the text documents displaying the text that a change has taken place. Now, by convention, texts do not know what text document(s) they are attached to. The only possibility left open to the text is to broadcast a "text T has changed" message to all objects in the display space. Since text documents are listening to messages of the type "text T has changed" (where T is the text they are linked to), they can update themselves when this broadcast message is received. The broadcast functions in the following manner. First, the message is sent to the display root. As the root does not understand the message (because it knows nothing about texts), the only logical thing it can do is to forward the message to the tracks it contains, in the hope that these can have something to do with the message. However, the tracks are just as clueless, and are forced to forward the message to the viewers they contain. The same thing happens again, so each viewer forwards the message to its (two) sub-frames. The message thus travels through the entire display space in a depth-first way. Luckily, the text documents located in the display space understand the message, and can update the display with the character typed (which is specified in the message by indicating the part of the text that has changed).
	This is the general scheme Oberon uses to inform views that a model has changed. If no view is interested in the model that has changed, the message travels through the whole display space without effect.

Types of broadcast.	In reality, there are two types of broadcasts: true broadcast and directed broadcast. True broadcasts reach all frames in the display space. Directed broadcasts are addressed to a certain destination frame in the display space. This might sound a little paradoxical. Why do we need to broadcast a message into the display space if we know the frame that should receive it? Why not simply send the message directly to the intended frame (without going through the display root, tracks, viewers etc)? Although several reasons exist (one of them related to the Oberon display model), only one reason will be mentioned here. As messages travel in the display space from the root frame to track, to viewer, and so on, at any point a container frame can make a decision if it wants to handle, ignore, change or forward a message. Thus a frame can influence the messages its descendants "see". This is again the all important property of parental control. Should a parent frame not control the message a child frame sees, the child might "misbehave". Parental control might force a child frame to move itself only in a restricted way in a container; or prevent a child frame from deleting itself.

Terminating a broadcast.	Under certain circumstances, it is necessary to terminate a broadcast early. This is typically the case when it is known that no further frame could have an interest in the message. Thus, Oberon provides a way to invalidate a message. An invalidated message is not forwarded by containers, thus terminating the broadcast abruptly.


5.7	A Message Protocol

After this excursion into the display space, messages and broadcast, we continue with our examples for manipulating texts. These examples are generally applicable to other objects too. To communicate with a text editor frame located somewhere in the display space, we have to send messages to it. These messages are related to the visual aspects of the text, such as the caret or the selection. In general, we can say that each type of visual gadget responds to messages. Often, a frame responds not only to a single message protocol but also to a set of message protocols. For example, the text editor-like frames (in module TextFrames) respond to the text message protocol, in addition to the protocol for objects (object messages) and for frames (frame messages). We need to know only that text editor frames respond to the text message protocol, but we do not have to import the text editor modules. This allows somebody to create a new text editor frame at a later point in time without invalidating existing modules. In short, the examples below function with all text editors, future and past.

Messages as first class citizens. In contrast to nearly all other systems, messages in Oberon usually are statically allocated RECORDs that is, RECORDs that are temporarily allocated on the activation stack. A message is sent to an object by passing it as a VAR parameter to the message handler of that object. A speciality of Oberon is that type extension is applied also to message RECORDs. The base message type is defined in module Objects:

	ObjMsg = RECORD
		stamp: LONGINT;
		dlink: Object
	END;

stamp and dlink are administrative fields which we shall ignore for the moment. Frame messages are needed to communicate with (text editor) frames and additional information must be supplied to these frames. The frame message type extension is defined in module Display:

	FrameMsg = RECORD ( Objects.ObjMsg )
		F: Frame;
		x, y: INTEGER;
		res: INTEGER
	END;

Except for the F field of the FrameMsg, let us further ignore the other message fields. The F field of a message specifies the target frame of a directed broadcast. When it is set to NIL, no target is specified and a true broadcast is involved.
	Finally, the messages of the text frame protocol are, in turn, extensions of FrameMsg. Let us take a look at one of them, the CaretMsg, which is defined in module Oberon and which is used to manipulate the text caret remotely:

	CaretMsg = RECORD ( Display.FrameMsg )
		id: INTEGER;	(* get, set, reset *)
		car: Display.Frame;	(* Destination frame, returned text editor frame. *)
		text: Texts.Text;	(* Text represented by car. *)
		pos: LONGINT	(* Caret position. *)
	END;

Abstractly, we see from the discussion above that Oberon uses a type extension hierarchy for messages too. This allows us to extend the message protocols of objects without changing or recompiling the whole system. Before proceeding with the text message protocol, we illustrate the message hierarchy in Figure 5.7.


Figure 5.7	Extract of the Message type hierarchy

Reminder.	The introduction of the message type hierarchy illustrates the importance of hierarchies in the Oberon system. At the start of this chapter, we investigated the module hierarchy, which forms the basis of code re-use in the Oberon system. In the introduction to the display space, we got to know the object type extension hierarchy (for reusing and extending object classes), and the display hierarchy of container/child and model/view relationships between objects (the run-time system organization). Now, we have just become acquainted with the message hierarchy that defines the protocols used to communicate with objects. Later, we will describe another hierarchy that organizes "templates" of pre-configured objects.
	This hierarchical system organization is important since it forms the basis of an extensible system. Let us summarize what we would like to extend and how we do it in Oberon. To extend the code of the system, we write a new module that uses (i.e. imports) existing modules. To extend an object with new functionality, we make a sub-type (or class) of that object. To extend the run-time system with functionality, we insert an object in the display space. To extend the way we communicate with objects, we add new message protocols to the message type hierarchy.

	To communicate with a text editor and thus manipulate its caret, we need to define a CaretMsg, fill out the RECORD fields of the CaretMsg message correctly, and then broadcast the message into the display space. The general scheme of declaring, filling out and broadcasting a message is illustrated by the following code fragment:

	PROCEDURE DoIt;
	VAR M: Oberon.CaretMsg;	(* define message *)
	BEGIN
		(* fill out the message fields *)
		M.F := ... ;
		M.id := ... ;

		(* Broadcast the message *)
		Display.Broadcast(M)

		(* ... process return values ... *)
	END DoIt;

The Example7 in the next section will offer a practical application of this scheme.
	To use messages in the Oberon system a programmer requires a knowledge of how the message fields are interpreted by their receivers. The fields of the object and display messages have a fixed meaning, and their semantics will be explained together with the following example. We now review the meaning of the individual fields of the CaretMsg (the first six fields belong to the base message types Objects.ObjMsg and Display.FrameMsg):

stamp	A time stamp set by the Display.Broadcast procedure to indicate
	the time the message was broadcast. Time, in this sense,
	is simply a counter incremented each time a message is broadcast.
dlink	A pointer to the object that forwarded the message to the sender.
F	The destination frame in the display space for which this message
	is intended. A NIL value indicates that the message is addressed to
	all frames in the display space.
x, y	The absolute screen coordinates of the container frame of the
	receiver.
res	A number that indicates if the message is valid or not. Invalid
	messages are not forwarded further in the display space (termina-
	ted broadcast). An invalid message has a res value of zero or
	more. Display.Broadcast automatically sets res to a negative value
	before the message is broadcast.
id	A message selector specifying which sub-operation the destination
	frame must complete. In this case we can either set the caret,
	retrieve the current caret position, or reset, i.e. remove, the caret.
car	When id is set to get, the car field returns the frame that contains
	the caret (after the message broadcast).
text	Either the text model of the frame that contains the caret when
	id = get (text and car are consistent), or the text of the destination
	frame otherwise.
pos	The caret position in the text of the destination frame or of the
	returned frame.

After this introduction, a short discussion of the message fields is in order.
	First, as user/sender of messages, fields like stamp, dlink, x, and y are of secondary importance as they are updated automatically while the message travels through the display space. These fields need not be filled in before broadcasting a message. The only fields that are of interest to us at the moment are F (the destination frame) and the four fields of the CaretMsg itself.
	Second, the semantics of fields change depending on the message selector id. In some cases, the fields of the CaretMsg are out parameters, and sometimes they are in parameters. Out parameters deliver results from the destination frame(s) to the message broadcaster or sender. The parameter values are available in the message RECORD itself after the message broadcast. In parameters are used to pass parameters from the sender to the destination frame.

id	Meaning of the fields

get	Message broadcast to all frames, thus F := NIL.
	car, out parameter with the frame that has the caret (if any).
	text, out parameter with the text model of car that has the caret.
	pos, out parameter with the position of the caret in text.
set	Message broadcast to a specific frame, thus F := someFrame.
	car, in parameter with the frame F where to set the caret.
	text, in parameter with the text model of car.
	pos, in parameter with the position of the caret in text.
reset	Message broadcast to a specific frame, thus F := someFrame.
	car, in parameter with the frame F where to reset the caret.
	text, in parameter with the text model of car.
	pos, ignored.

The description also shows that a frame might be displaying more than one text at the same time, and we should specify which of these texts are meant. This generality is however seldom used in the Oberon system (but might be in the future). Consequently, in the set and reset cases, the text field is mostly redundant but it is checked for correctness anyway.
	Finally, observe that the meaning of some fields of the base message types have not been explained completely yet (dlink and stamp, in particular); this explanation will be deferred till later.

The SelectMsg.	This message of the text frame protocol controls the text selection. Our knowledge of messages in general can now be easily applied to the SelectMsg, which is also defined in module Oberon:

	SelectMsg = RECORD ( Display.FrameMsg )
		id: INTEGER;	(* get, set, reset *)
		time: LONGINT;	(* Time of the selection. *)
		sel: Display.Frame;	(* Destination frame, returned frame. *)
		text: Texts.Text;	(* Text represented by sel. *)
		beg, end: LONGINT	(* Text stretch of the selection. *)
	END;

Most of the fields should look familiar from comparison with the definition of the CaretMsg. Instead of car, sel indicates the frame containing the selection. The time field specifies the (true) time of the selection (not to be confused with the message time stamp), while beg and end specify the extent of the text selection. Otherwise, most of the principles of the CaretMsg apply to the SelectMsg. In particular, the SelectMsg is also always broadcast.

The ConsumeMsg.	This text frame protocol message controls the insertion of a text stretch at the caret and is also defined in module Oberon:

	ConsumeMsg = RECORD ( Display.FrameMsg )
		text: Texts.Text;	(* Text to be inserted. *)
		beg, end: LONGINT	(* Text stretch to be inserted. *)
	END;

The RecallMsg.	This text frame protocol message controls the insertion of a last deleted text stretch at the caret and is also defined in module Oberon:

	RecallMsg = RECORD ( Display.FrameMsg )
	END;


5.8	Text Protocol Examples

Font Search Tool.	Our next objective is to write a command which searches a text for a specified font, starting at the current position of the caret, and to re-position the caret after the first character in that font. The search starts at the caret, if set. The font name is the sole command parameter. To aid the understanding, we should mention that the lib field of a Reader R is a pointer to the font of the last character read.

	MODULE Example7;

	IMPORT Display, Oberon, Out, Texts;

	PROCEDURE SearchFont*;
	VAR ch: CHAR; C: Oberon.CaretMsg;
		R: Texts.Reader; S: Texts.Scanner;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Texts.Scan(S);
		IF S.class = Texts.Name THEN
			C.id := Oberon.get; C.F := NIL; C.car := NIL; C.text := NIL;
			Display.Broadcast(C);	(* get caret position *)
			IF C.text # NIL THEN
				Texts.OpenReader(R, C.text, C.pos);
				Texts.Read(R, ch);
				WHILE ~R.eot & (R.lib.name # S.s) DO Texts.Read(R, ch) END;
				IF ~R.eot THEN
					C.id := Oberon.set; C.F := C.car; C.pos := Texts.Pos(R);
					Display.Broadcast(C)
				ELSE
					Out.String("Font not found"); Out.Ln
				END
			ELSE
				Out.String("No caret set"); Out.Ln
			END
		END
	END SearchFont;

	END Example7.

The module can be activated with:

	Example7.SearchFont Syntax10.Scn.Fnt

Finding at which position in a text the caret is set, is done by broadcasting a CaretMsg, with the car field set to NIL, to all the documents in the display space. If a caret is found, we read through the text with a Reader until the font is found. The font descriptor has a name field (R.lib.name) containing the font name. If the WHILE loop terminates before reaching the end of the text, we know that we were successful, and we can set the caret again. Setting the caret outside the visible part of the text on the display will scroll the text automatically, so that the caret position becomes visible. After broadcasting the first caret message, the fields car and text are already initialized for the second caret message broadcast.

Insert text Tool.	This example makes use of the messages described earlier to insert a text stretch at the caret. The first command copies the selection to the caret via a buffer and terminates by selecting the copied text. The second one copies the selection to the caret using a ConsumeMsg. The third one inserts the last deleted text stretch using a RecallMsg.

	MODULE Example8;

	IMPORT Display, Oberon, Out, Texts;

	PROCEDURE CopySelection*;
	VAR T: Texts.Text; B: Texts.Buffer; beg, end, time: LONGINT;
			C: Oberon.CaretMsg; S: Oberon.SelectMsg;
	BEGIN
		Oberon.GetSelection(T, beg, end, time);
		(* This procedure, which is provided with the system, does indeed
			broadcast a SelectMsg. Its implementation is equivalent to:

			S.id := Oberon.get; S.F := NIL; S.time := -1; S.text := NIL;
			Display.Broadcast(S);
    		T := S.text; beg := S.beg; end := S.end; time := S.time
    	*)
		IF time >= 0 THEN
			NEW(B);
			Texts.OpenBuf(B);
			Texts.Save(T, beg, end, B);	(* make a copy of the selection in buffer B *)
			C.id := Oberon.get; C.F := NIL; C.car := NIL; C.text := NIL;
			Display.Broadcast(C);	(* get caret position *)
			IF C.text # NIL THEN
				Texts.Insert(C.text, C.pos, B);	(* insert the selection at the caret *)
				S.id := Oberon.set;
				S.F := C.car; S.sel := C.car; S.text := C.text; S.time := -1;
				S.beg := C.pos; S.end := C.pos + (end - beg);
				Display.Broadcast(S);
			ELSE Out.String("No caret set"); Out.Ln
			END
		ELSE Out.String("No selection."); Out.Ln
		END
	END CopySelection;

	PROCEDURE CopyToCaret*;
	VAR T: Texts.Text; beg, end, time: LONGINT;
			C: Oberon.ConsumeMsg;
	BEGIN
		Oberon.GetSelection(T, beg, end, time);
		IF time >= 0 THEN
			C.F := NIL; C.text := T; C.beg := beg; C.end := end;
			Display.Broadcast(C)
		END
	END CopyToCaret;

	PROCEDURE Recall*;
	(* The same functionality is provided by the command TextDocs.Recall *)

	VAR R: Oberon.RecallMsg;
	BEGIN
		R.F := NIL; Display.Broadcast(R)
	END Recall;

	END Example8.

	Example8.CopySelection

	Example8.CopyToCaret

	Example8.Recall	You have to delete a text stretch before using this
		command otherwise nothing happens.

In all cases, the caret is automatically repositioned after the last character inserted.


5.9	Introducing Gadgets

In our discussions so far, we have discussed not only how to use texts but also how the system is structured (typing and run-time organization) and how to communicate with frames in the display space (message broadcasting). This is already enough background knowledge to explore gadget manipulation as the next topic. By gadget manipulation we mean creating, destroying, inserting, changing etc. gadgets that already exist. In the user guide you learned how to manipulate gadgets interactively with the mouse and Columbus. This section explains how gadgets are manipulated under program control.

The Gadget types.	Earlier it was mentioned that gadgets are extensions of Objects.Object and Display.Frame. The gadget extension of Display.Frame is called a visual gadget, and the gadget extension of Objects.Object is called a model gadget. We now take a look at the corresponding types in module Gadgets:

	(* Base type of the model gadgets *)
	Object = POINTER TO ObjDesc;
	ObjDesc = RECORD (Objects.ObjDesc)
		attr: Attributes.Attr;	(* Attribute list. Private variable. *)
		link: Links.Link;	(* Link list. Private variable. *)
	END;

	(* Base type of the visual gadgets *)
	Frame = POINTER TO FrameDesc;
	FrameDesc = RECORD (Display.FrameDesc)
		attr: Attributes.Attr;	(* Attribute list. Private variable. *)
		link: Links.Link;	(* Link list. Private variable. *)
		state: SET;
		mask: Display3.Mask;
			(* Cached display mask. Can be NIL to indicate no/invalid mask. *)
		obj: Objects.Object;	(* Model object, if any. *)
	END;

Both types export a field attr and a field link which will be described later on (cf. Decorations). Furthermore, the visual gadgets have a state field containing four boolean flags with information about the gadget state, a mask field that remembers the visible area of the gadget (for display clipping purposes), and a pointer called obj to the model gadget attached to the visual gadget (if any). These fields are only of interest when programming new gadgets. The selected flag indicates if the gadget is selected, the lockedsize flag indicates if the width and the height of the gadget is constant, the lockedcontents flag locks all the children of the gadget against further editing and the transparent flag indicates if the gadget has a transparent background.
	We now focus on what gadgets are available and how to manipulate them. We pick a gadget we would like to use from the Standard Gadgets Reference, find out what its generator procedure is, and use this information to find the module that implements this gadget. Then we use Watson to retrieve the module definition with the types and operations of that gadget. After doing this, we have enough information to use that gadget.
	We select two standard gadgets, Integer and Slider, for further study. These gadgets have generators BasicGadgets.NewInteger and BasicGadgets.NewSlider respectively, implying that both of them are implemented in the same module BasicGadgets. Using Watson, we can extract the definitions of these two gadgets from their module:

		Integer = POINTER TO IntegerDesc;
		IntegerDesc = RECORD (Gadgets.ObjDesc)
			val: LONGINT;	(* current value *)
		END;

		Slider = POINTER TO SliderDesc;
		SliderDesc = RECORD (Gadgets.FrameDesc)
			min, max, val: LONGINT;	(* Minimum, maximum and current value *)
		END;

We immediately infer from their base types that a model and a visual gadget are involved. Each gadget has some local fields storing LONGINT values. Before doing any manipulation, we have either to create new instances of these gadgets or to locate already existing gadgets of these types, for example in a user interface Panel.

Attributes.	Each gadget class typically defines several instance variables, some of which, called attributes, are distinguished from other instance variables by being visible and modifiable at run-time by the end-user using Columbus. Attributes are properties of gadget instances that define their state, representation and behavior. Each attribute has a name and a typed value. Allowed types are string (ARRAY OF CHAR), LONGINT, REAL, LONGREAL CHAR, BOOLEAN and SET, a subset of the Oberon language elementary types. The accessibility of attributes by the end-user places a responsability on the programmer of the class to "export" only those internal details of a gadget that can easily be understood and that can be of possible use to the Oberon user.

Creating new instances of gadgets.	There are quite a few ways of creating an instance of a gadget under module control. As the name generator indicates, simply calling the generator procedure creates a new gadget instance of that type. This is also the way the Gadgets.Panel creates a new gadget (with the help of module Modules). The trick to know is that a generator always assigns the newly created gadget to the global variable called Objects.NewObj, from where the caller is expected to pick it up:

	IMPORT BasicGadgets, Objects;

	PROCEDURE CreateSlider;
	VAR S: BasicGadgets.Slider;
	BEGIN
		BasicGadgets.NewSlider;
		S := Objects.NewObj(BasicGadgets.Slider);

		(* and set fields directly *)
		S.val := 0; S.min := 0; S.max := 1000
	END CreateSlider;

A type guard is required to make sure that an object of the right type is assigned to the local variable S. However, a gadget is not located in the display space just after creating it - it is said to be off-screen. It must be inserted into the display space explicitly, as indicated later. While in this off-screen state, we may manipulate the fields of a gadget directly as is done in the example, although this is not a recommended practice.
	For the curious, we now illustrate how NewSlider works. This is also the way to create a Slider without calling the generator procedure:

	IMPORT BasicGadgets;

	PROCEDURE CreateSlider;
	VAR S: BasicGadgets.Slider;
	BEGIN
		NEW(S); BasicGadgets.InitSlider(S);	(* allocate and initialize *)

		(* and set fields directly *)
		S.val := 0; S.min := 0; S.max := 1000
	END CreateSlider;

In this case, we have to allocate an own Slider with NEW and then initialize it. By convention, for each gadget we have a corresponding InitX procedure, where X is the type of the gadget. The task of the InitX procedure is to install the message handler of the gadget and to initialize its RECORD fields to a consistent state. Afterwards, it is ready for use.
	There is however a problem with the approach above: we are using the module BasicGadgets by importing it directly. This makes an extremely strong coupling between our new code and module BasicGadgets. Should module BasicGadgets change in future, we might have to recompile or even adjust our module too. In Oberon, however, we can use gadgets without importing them. This idea plays an important role in an extensible system and will be observed many times in the remainder of the book. The trick is to use a special procedure called Gadgets.CreateObject to create a gadget from the generator string:

	IMPORT Gadgets;

	PROCEDURE CreateSlider;
	VAR obj: Objects.Object;
	BEGIN
		obj := Gadgets.CreateObject("BasicGadgets.NewSlider")
	END CreateSlider;

Behind the scenes, Gadgets.CreateObject uses the module loader to load and execute the generator procedure of a gadget, and thus avoids importing a gadget implementation directly.
At this point, the attentive reader will be wondering how we can access the private RECORD fields of the Slider without importing module BasicGadgets, and without defining a variable of type BasicGadgets.Slider. The answer is found in the special attribute message. This message is used by Columbus to inspect and change the state of gadgets.

Attribute Handling. The attribute mechanism, which was introduced in Chapter 3,  has two aspects. First, a message mechanism is used to set, retrieve and enumerate the attributes of a gadget. This is the interface or the "outside" of a gadget. Second, a gadget is responsible for storing attributes internally. This is the implementation or the "inside" of a gadget. From the outside, the actual implementation or storage of the gadget attributes is not visible. As users of the gadget, we are only interested in the attribute interface to a gadget and not in how it is implemented (more about the implementation is found in the sections about programming a gadget).
	In a similar fashion to Texts.Scanner, the attribute mechanism uses a single RECORD message type to pass attributes of a selection of basic Oberon types:

	AttrMsg = RECORD ( Objects.ObjMsg )
		id: INTEGER;	(* get, set or enum. *)
		Enum: PROCEDURE (name: ARRAY OF CHAR);
			(* Called by object to enumerate attribute names. *)
		name: Name;	(* Name of the attribute to be set or retrieved (ARRAY OF CHAR). *)
		res: INTEGER;	(* Return result: < 0 no response, >= 0 action completed. *)
		class: INTEGER;	(* Attribute class (Inval, Int, Real, LongReal, Char, Bool or String). *)
		i: LONGINT;
		x: REAL;
		y: LONGREAL;
		c: CHAR;
		b: BOOLEAN;
		s: ARRAY 64 OF CHAR
	END;

	Again we observe a message selector id that determines whether we want to read, to write or to enumerate attributes. After sending an attribute message, a zero or positive res value indicates that the message was handled successfully by the receiving object. The AttrMsg and all messages of the base object protocol (defined in module Objects) are sent directly to an object, and is not broadcast into the display space. This involves calling the message handler of an object directly. Here is how to get or retrieve the Value attribute of an Integer gadget:

	PROCEDURE Example*;
	VAR obj: Objects.Object; M: Objects.AttrMsg;
	BEGIN
		obj := Gadgets.CreateObject("BasicGadgets.NewInteger");

		M.id := Objects.get;
		M.name := "Value";	(* attribute to be retrieved *)
		M.res := -1;	(* init result code *)
		obj.handle(obj, M);	(* direct message send *)

		IF M.res >= 0 THEN	(* success ? *)
			Out.String("The Value attribute of the Integer is ");
			IF M.class = Objects.String THEN Out.String(M.s)
			ELSIF M.class = Objects.Int THEN Out.Int(M.i, 0)
			ELSE
				Out.String("(Unknown type)")
			END
		ELSE
			Out.String("Object did not understand the message")
		END;
		Out.Ln
	END Example;

This example illustrates a few things. First, a direct send to a gadget involves calling the handler of an object directly and passing the object itself as the first parameter and the message as a second parameter. In general, a typical message send has the structure:

	x.handle(x, M)

where M is the message and x is the destination object. Verify the type of Objects.Handler with Watson to assure yourself of this fact. If we did not pass the receiving object as first parameter, there would be no way for a message handler to find out which object it is bound to.
	After the message is sent, the res field indicates if the gadget was able to return the requested attribute. If it did return succesfully, the class field indicates the type of the attribute and in which field corresponding to that type the attribute value is returned. That is, an attribute of type string is returned in field M.s, whereas an attribute of type integer is returned in M.i, and so forth.
	Setting or writing an attribute involves doing the operation above in reverse:

	PROCEDURE Example*;
	VAR obj: Objects.Object; M: Objects.AttrMsg;
	BEGIN
		obj := Gadgets.CreateObject("BasicGadgets.NewInteger");

		M.id := Objects.set;
		M.name := "Value";	(* attribute to be written *)
		M.class := Objects.Int;	(* type of the attribute *)
		M.i := 42;
		M.res := -1;	(* init result code *)
		obj.handle(obj, M);	(* direct message send *)

		IF M.res >= 0 THEN	(* success ? *)
			Out.String("Attribute was set")
		ELSE
			Out.String("Attribute could not be set")
		END;
		Out.Ln
	END Example;

The situation where a user tries to set an attribute with the wrong type, for example when assigning an existing string attribute to an integer value, is worth some consideration. According to the ground rules of object orientation, the exact behavior depends on the object handling the message. It could either try to convert the integer into a string representation or simply refuse the operation, but we would never know for sure without inspecting the description of the gadget. A related point is what happens when an attribute is set that does not exist at the time the message is sent. In the current implementation this is often regarded as a combined create and set operation. This behavior hints at the fact that the attributes of a gadget can be a dynamic and growing set of attributes. The alert reader will suspect that the attr field of gadgets must provide the solution.
	The only other selector value of the attribute message is enum used for enumerating the gadget attributes. This is done by passing a call-back procedure to the gadget, which then dutifully calls the call-back for each attribute it has:

	PROCEDURE MyCallback (name: ARRAY OF CHAR);
	BEGIN
		Out.String("Gadget has an attribute called ");
		Out.String(name);
		Out.Ln
	END MyCallBack;

	PROCEDURE Example*;
	VAR obj: Objects.Object; M: Objects.AttrMsg;
	BEGIN
		obj := Gadgets.CreateObject("BasicGadgets.NewInteger");

		M.id := Objects.enum;
		M.Enum := MyCallback;
		M.res := -1;	(* init result code *)
		obj.handle(obj, M)	(* direct message send *)
	END Example;

As suspected, this is the mechanism Columbus uses to figure out which attributes a gadget has.
	At this point it is instructional to illustrate how to manipulate the Integer gadget (or for that matter any other gadget) directly without the attribute message. This is of course a valid option for the programmer, except that a strong dependency on an Integer object is then created. This implies that a change to a different type of gadget is not possible without rewriting some code. As will be shown later in the manipulation of gadgets in a user interface, this would result in an unneeded type dependency between program code and a user interface.

	IMPORT BasicGadgets, Gadgets, Objects;

	PROCEDURE Example*;
	VAR obj: Objects.Object;
	BEGIN
		obj := Gadgets.CreateObject("BasicGadgets.NewInteger");
		WITH obj: BasicGadgets.Integer DO
			obj.val := obj.val + 1
		END
	END BasicGadgets;

Locating a gadget in the display space.	Manipulating existing gadgets in the display space is the basis of all applications created with the Gadgets system. Once a gadget is located in the display space, we can manipulate it either directly by reading and setting its record fields (a strong dependency) or indirectly by using the attribute mechanism (a weak dependency). How do we locate a gadget?
	There are essentially three ways of locating gadgets: by position, by state (the current gadget selection), or by name.
	Given a certain X, Y position on the display, we can ask exactly what gadget is located at that position. By convention, such a position is picked with the star marker. The definition of the module Oberon reveals that the marker's coordinates are Oberon.Pointer.X, Oberon.Pointer.Y and that the procedure Oberon.MarkedFrame returns the marked frame. This knowledge leads to the following program fragment:

	MODULE Example9;
	IMPORT Display, Oberon, Objects, Out;

	PROCEDURE Info* (obj: Objects.Object);
	VAR A: Objects.AttrMsg;
	BEGIN
		A.id := Objects.get; A.name := "Gen"; A.res := -1;
		obj.handle(obj, A);	(* Retrieve the generator procedure name *)
		Out.String(A.s); Out.Ln
	END Info;

	PROCEDURE Locate*;
	VAR F: Display.Frame;
	BEGIN
		F := Oberon.MarkedFrame();
		Info(F)
	END Locate;

	END Example9.

As we already know that communication with the display space is through message broadcasting, the procedure Oberon.MarkedFrame makes us suspect that a message broadcast must be hidden behind it. In fact, the Display.LocateMsg does the job for us.

		LocateMsg = RECORD ( FrameMsg )
			loc: Frame;	(* Result. *)
			X, Y: INTEGER;	(* Absolute location. *)
			u, v: INTEGER	(* Relative coordinates in loc. *)
		END;

This message is broadcast to locate the frame positioned at the absolute coordinates X, Y on the display. Here is the implementation copied from the module Oberon.

	(** Returns the star (F1) marked frame. *)
	PROCEDURE MarkedFrame*(): Display.Frame;
		VAR L: Display.LocateMsg;
	BEGIN
		L.loc := NIL; L.X := Pointer.X; L.Y := Pointer.Y; L.F := NIL; L.res := -1;
		Display.Broadcast(L);
		RETURN L.loc
	END MarkedFrame;

The L.loc field returns the frame located at the position L.X, L.Y, and the L.u, L.v fields return the relative position of L.X, L.Y inside the located frame.
	Now that the gadget is located by its frame, all that remains is to identify it. This is best done by the name of its generator procedure found in the Gen attribute as is done in the Info procedure. This procedure is exported because it will be used again in further examples. Knowingly, the attribute message returns a collection of basic Oberon types from which to select. Thus a cautious programmer would surely include some test of the result field res and of the class field before proceeding with writing the attribute value to the log. In fact, the necessary test and type conversion are supplied by a collection of procedures found in module Attributes. The following modified Example9 makes use of one of them:

	MODULE Example9bis;
	IMPORT Attributes, Display, Oberon, Out;

	PROCEDURE Locate*;
	VAR F: Display.Frame; generator: ARRAY 32 OF CHAR;
	BEGIN
		F := Oberon.MarkedFrame();
		Attributes.GetString(F, "Gen", generator);
		Out.String(generator)
	END Locate;

	END Example9bis.

The procedures which take care of preparing and issuing an attibute message follow the pattern:

		GetType(obj: Objects.Object; name: ARRAY OF CHAR; VAR x: T);
for retrieving the value x of an attribute name from an object obj, and converting it to type T. The following conversions are performed:

	Type	T	Attribute classes converted

	Int	LONGINT	Int, String, Real, LongReal
	Real	REAL	Real, String, LongReal, Int
	LongReal	LONGREAL	LongReal, String, Real, Int
	Bool	BOOLEAN	Bool, String, Char
	String	ARRAY OF CHAR	String, Int, Bool, Real, LongReal, Bool

Assigning a new value to an attribute is possible with the corresponding "Set" procedures:

		SetType(obj: Objects.Object; name: ARRAY OF CHAR; x: T);

for setting the value of an attribute name in an object obj, and converting the type T to the attribute class understood by the object. The same conversions are performed.
	We shall soon see that the name of a gadget, that is, the value of its Name attribute, is of central importance. This remark comes right in time to mention two procedures of the Gadgets module that serve the purpose of setting and retrieving the Name attribute under program control:

		GetObjName (obj: Objects.Object; VAR name: ARRAY OF CHAR);
		NameObj (obj: Objects.Object; name: ARRAY OF CHAR);

	The second way of locating a gadget in the display space is by state, finding out whether a gadget is selected or not. Just as the module Texts provides a procedure for obtaining the current text selection, the module Gadgets provides a way to find the gadget selection, or more correctly the frame selection. Whereas the text selection just consisted of a text with a starting and ending position, the gadget selection might consist of a set of gadgets. How is such a set returned? So far, we have not mentioned some fields defined in the base type Objects.Object.

	Object = POINTER TO ObjDesc;
	ObjDesc = RECORD
		stamp: LONGINT;	(* Time stamp of last message processed by object. *)
		dlink,	(* Next object in the message thread. *)
		slink: Object;	(* Next object in a list of objects. *)
		lib: Library; ref: INTEGER;	(* Library and reference number of object. *)
		handle: Handler	(* Message handler. *)
	END;

One of them, called slink, strings objects together in a list, allowing us to visit them by following the chain. There is no restriction on the type of objects included in such a list. Accordingly, when requesting the current gadget selection, a list of frames is returned. By convention, the selection can consist only of children of one and the same container. This means that two different "threads" are maintained for each container. The dsc-next thread contains all the children, whereas the slink thread contains only the selected children of the container.
	Here is a procedure to display the generator procedure names of the selected gadget(s):

	MODULE Example10;

	IMPORT Gadgets, Objects, Example9;

	PROCEDURE Locate*;
	VAR obj: Objects.Object; time: LONGINT;
	BEGIN
		Gadgets.GetSelection(obj, time);
		IF time >= 0 THEN
			WHILE obj # NIL DO
				Example9.Info(obj);
				obj := obj.slink
			END
		END
	END Locate;

	END Example10.

There is one caveat though. The slink is such a useful mechanism for stringing objects together that it is used for more than one purpose. Although the s in slink suggests "selection link" at first glance, it really stands for static link. This relates to the fact that the slink chain is valid only for the periods between message broadcasts that use the chain. It would be even better to say "temporary" instead of static, to be quite correct: a programmer should thus never assume that the slink chain remains intact for an indefinite period of time. A container typically builds the slink chain when requested, by traversing its children and checking whether they are selected or not, and inserting them into the chain accordingly. A gadget is selected when the constant Gadgets.selected is a member of the state field of a gadget.
	As expected, Gadgets.GetSelection is implemented by a message broadcast:

	PROCEDURE GetSelection* (VAR objs: Objects.Object; VAR time: LONGINT);
	VAR SM: Display.SelectMsg;
	BEGIN time := -1; objs := NIL;
		SM.id := Display.get; SM.F := NIL;
		SM.sel := NIL; SM.obj := NIL; SM.time := -1;
		Display.Broadcast(SM);
		IF (SM.time >= 0) & (SM.obj # NIL) THEN
			time := SM.time; objs := SM.obj
		END
	END GetSelection;

	In a way similar to that in which the Oberon.SelectMsg controls the text selection, the Display.SelectMsg controls the selection of gadgets. The obj field points to a selected object. Further selected objects in the same container follow in a chain which extends from there. The sel field points to the containing frame.

		SelectMsg = RECORD ( FrameMsg )
			id: INTEGER;	(* get, set, reset. *)
			time: LONGINT;	(* Time of the selection. *)
			sel: Frame;	(* Parent of selection. *)
			obj: Objects.Object	(* List of objects involved. *)
		END;

	The third way of locating a gadget in the display space is by name. Although we discuss this technique last, it is definitely the most popular and useful way. Locating a gadget by name involves broadcasting an Objects.FindMsg into the display space. As each gadget receives the FindMsg, it checks whether the object requested matches its name, and returns itself accordingly. Whereas most other broadcasted messages travel in a depth-first fashion through the display space, the FindMsg does a breadth-first traversal. This means that the "nearest" gadget from the root of the display space is located.

		FindMsg = RECORD ( ObjMsg )
			name: Name;
			obj: Object	(* Result object, if found. *)
		END;

	Unfortunately, the find technique as sketched here is flawed. The reason is that a user might decide to open the same document twice, thus the named gadget in the document appears twice in the display space. Although separate gadget instances are involved, they have the same name, and are thus difficult to separate. To eliminate the name ambiguity we have to determine where in the display space the search must start, in other words, at what "virtual" root. Typically, such a root is the document instance from where a command is executed. The situation can be clarified as follows.
	Suppose a document D contains a gadget named X. Opening D twice results in two viewers (D1 and D2), each with an instance of gadget X. We immediately have the problem of separating the two X's (X1 and X2) from each other. Which of these is meant?
	In principle, the user of one of the documents D decides which X is meant. For example, clicking on a button in D1 means the X of document D1 (thus selecting D1 as search context), or clicking on a button in D2 means the X of document D2 (thus selecting D2 as search context). In fact, the scheme used is slightly more general than this. First, the search context or virtual root is determined not only by clicking on a button in a document, but also by executing any command from a user interface element in a document. More concretely, executing a command from a user interface involves executing the Cmd or ConsumeCmd attribute of a gadget manipulated. Second, the direct container of the gadget executing the command is used as search context, not the document. This allows a fine-grained searching capability and allows a document to contain multiple containers with descendants having the same name. Before a gadget executes a command, it deposits a reference to its direct container in the global variable Gadgets.context. This variable specifies the search context and is used in the following manner to locate a gadget in that context:

	MODULE Example11;
	IMPORT BasicGadgets, Gadgets, Objects, Out, Example9;

	PROCEDURE Locate*;
	VAR obj: Objects.Object;
	BEGIN
		obj := Gadgets.FindObj(Gadgets.context, "Test");
		IF (obj # NIL) & (obj IS BasicGadgets.CheckBox) THEN
			WITH obj: BasicGadgets.CheckBox DO
				IF obj.val THEN Out.String("The CheckBox is checked.")
				ELSE Out.String("The CheckBox is not checked.")
				END
			END
		ELSE Out.String("Test not found.")
		END;
		Out.Ln; Out.String("Executor: ");
		Example9.Info(Gadgets.executorObj);
		Out.Ln
	END Locate;
	
	END Example11.

This example assumes that a gadget named "Test" exists in the context of the command executed. This situation is easily built interactively by inserting a CheckBox and a Button into a Panel, naming the CheckBox "Test" and adding the command Example11.Locate to the Button.
	Additional global variables of the Gadgets module contain references to objects that are of interest when executing a command from a user interface. Among those variables, we may cite Gadgets.executorObj which is a reference to the gadget that executed the command.
	As suspected, Gadgets.FindObj is just a convenient front-end for a message send:

	PROCEDURE FindObj (context: Objects.Object; name: ARRAY OF CHAR): Objects.Object;
	VAR obj: Objects.Object; M: Objects.FindMsg;
	BEGIN
		obj := NIL;
		IF context # NIL THEN (* search by find message *)
			M.obj := NIL; COPY(name, M.name); context.handle(context, M);
			obj := M.obj
		END;
		RETURN obj
	END FindObj;

	In our example, a strong and unneeded dependency was created on a CheckBox gadget. There are two solutions in this case. First, we can program a cascade of IF statements to check the type of the found object. In an extensible system you will however have to keep updating the IF statements when new gadgets become part of the system. A better solution, used in the next example, would be to retrieve, update and then set the Value attribute using the AttrMsg mechanism instead of importing a specific gadget. Completion of this exercise will quickly illustrate that programming without dependencies can result in blown up code sequences. In this case we would have to take into account that attributes are typed too. This is an unfortunate side effect of statically typed programming languages. In the pragmatic world, most Gadgets programmers make some tradeoff between complete generality and tight user interface coupling.

Display Updates.	Only one ingredient is missing before you can link an application module to its user interface. We already know how to locate a gadget in the display space (using one of three techniques), and how to read and change its attributes and RECORD fields (by AttrMsg or directly). What is missing now is a way to redisplay a gadget should the value of one of its attributes have changed. More specifically, we have to redisplay a gadget should a changed attribute have an influence on the visual representation of a gadget. This does not happen automatically when we change a setting in the gadget and for a good reason: should we change several attributes at the same time, an immediate update would cause an unneeded display flickering as the gadget would be redisplayed each time. Thus, by convention, the instance responsible for changing a gadget has also the responsibility of updating the display when all changes have been completed. A display update is trivially accomplished by a call to Gadgets.Update:

	MODULE Example12;
	IMPORT Attributes, Gadgets, Objects;

	PROCEDURE Update*;
	VAR obj: Objects.Object; val: BOOLEAN;
	BEGIN
		obj := Gadgets.FindObj(Gadgets.context, "Test");
		IF obj # NIL THEN
			Attributes.GetBool(obj, "Value", val);
			Attributes.SetBool(obj, "Value", ~val);
			Gadgets.Update(obj)
		END
	END Update;

	END Example12.

	Behind the scenes, one of two messages is broadcast into the display space by Gadgets.Update. In our case, we are manipulating a visual gadget directly, so it suffices to broadcast a Display.DisplayMsg 

		DisplayMsg = RECORD ( FrameMsg )
			device: INTEGER;	(* screen, printer *)
			id: INTEGER;	(* full, area, contents. *)
			u, v, w, h: INTEGER	(* Area to be restored. *)
		END;

to redisplay our gadget:

	PROCEDURE MyFrameUpdate (obj: Display.Frame);
	VAR D: Display.DisplayMsg;
	BEGIN
		D.device := Display.screen;
		D.id := Display.full;
		D.F := obj;
		Display.Broadcast(D)
	END MyFrameUpdate;

	In this code fragment the message is broadcast in a directed way to the frame. The id field is set to a value Display.full, which requests a complete redisplay.
	More generally, the DisplayMsg unifies the functions of displaying and printing  a gadget in a single message. The screen variant is a request to a visual gadget to display itself either completely (variant full), or to display a rectangular area of itself (variant area). In the latter case, the area u, v, w, h inside the destination frame is redrawn. As usual, the u and v coordinates are relative to the top-left corner of the destination gadget, thus v is negative. The printer variant requests a gadget to print a display approximation or snapshot of itself on the printer (variant full), or to print its data contents (variant contents). This can be a multi-page document, as for example in the case of a text document.
	We might also be manipulating a model gadget in the display space, which as a non-visual object, cannot respond to a DisplayMsg. In this case, we have to introduce a new message, as explained in the following section.

	PROCEDURE MyModelUpdate (obj: Display.Frame);
	VAR M: Gadgets.UpdateMsg;
	BEGIN
		M.obj := obj; M.F := NIL;
		Display.Broadcast(M)
	END MyModelUpdate;

Here it is important to note that a true broadcast is used and that M.obj specifies the model gadget that has changed.

Manipulating model gadgets.	Earlier, we used Gadgets.FindObj to find a gadget in the display space. The same Gadgets.FindObj can also be used to locate a named model gadget in the display space, and just as before, we can manipulate the state of that model gadget. A call to Gadgets.Update is then used to broadcast a Gadgets.UpdateMsg into the display space to indicate that the model has changed its value, and that each view depending on this model should update its representation accordingly:

	MODULE Example13;
	IMPORT Attributes, Gadgets, Objects;

	PROCEDURE Increment*;
	VAR obj: Objects.Object; val: LONGINT;
	BEGIN
		obj := Gadgets.FindObj(Gadgets.context, "Counter");
		IF obj # NIL THEN
			Attributes.GetInt(obj, "Value", val);
			Attributes.SetInt(obj, "Value", (val + 1));
			Gadgets.Update(obj)
		END
	END Increment;

	END Example13.

Thus, depending on the type of the gadget that has changed (model or visual), a Gadgets.UpdateMsg or a Display.DisplayMsg is broadcast into the display space (hidden in Gadgets.Update). The reader will notice that the Texts.UpdateMsg is an analogue of Gadgets.UpdateMsg in the text sub-system of Oberon.
	In general, it is a better idea to manipulate model gadgets rather than visual gadgets in a user interface. The reason is that your application module is insulated against model representation changes (i.e. a new view for an existing model) in the user interface.

Manipulation of gadgets in the display space.	Typically, user interfaces are constructed interactively using the Gadgets.Panel. In some cases however, we need to construct them by program. This requires mechanisms for inserting, deleting and moving gadgets in the display space.
	A straightforward way to add a gadget to the display space is to request it to be inserted at the current caret position. This moves the gadget from off-screen to on-screen:

	MODULE Example14;
	IMPORT Gadgets, Objects;

	PROCEDURE Insert*;
	VAR obj: Objects.Object;
	BEGIN
		obj := Gadgets.CreateObject("BasicGadgets.NewButton");
		Gadgets.Integrate(obj)
	END Insert;

	END Example14.

	Gadgets.Integrate is a convenient front-end for hiding the message broadcast that happens behind the scenes:

	PROCEDURE Integrate (obj: Objects.Object);
	VAR C: Display.ConsumeMsg;
	BEGIN
		IF obj # NIL THEN
			C.id := Display.integrate;
			C.obj := obj; C.F := NIL;
			Display.Broadcast(C)
		END
	END Integrate;

The Display.ConsumeMsg is a general mechanism for adding gadgets to the display space.

		ConsumeMsg = RECORD ( FrameMsg )
			id: INTEGER;	(* Drop, integrate. *)
			u, v: INTEGER;	(* Relative coordinates in destination when drop. *)
			obj: Objects.Object	(* List of objects to be consumed *)
		END;

This message comes in two varieties. The integrate mechanism inserts a gadget at the caret (if any), and the drop mechanism inserts a gadget at a specific relative position u, v in a specific gadget. The following example shows how to insert a gadget exactly at the star marker:

	MODULE Example15;
	IMPORT Display, Gadgets, Oberon;

	PROCEDURE Drop*;
	VAR F: Display.Frame; u, v: INTEGER;
		C: Display.ConsumeMsg;
	BEGIN
		Gadgets.ThisFrame(Oberon.Pointer.X, Oberon.Pointer.Y, F, u, v);

		C.F := F;
		C.id := Display.drop;
		C.obj := Gadgets.CreateObject("BasicGadgets.NewButton");
		C.u := u; C.v := v;	(* relative position in container *)
		Display.Broadcast(C)
	END Drop;

	END Example15.

In this example, notice how the relative coordinates of the star marker inside the located gadget are used as the position of the inserted gadget. An interesting question is what happens if a programmer tries to insert a gadget into an elementary gadget. Again the concept of parental control, or parental eavesdropping comes to our rescue. The container of the elementary gadget can monitor the ConsumeMsg, and determine if the child actually did consume the gadget (M.res >= 0). If not, the container can take the gadget for itself, causing it to appear overlapping the elementary gadget.
	The ConsumeMsg also allows you to insert more than one gadget into the display space. As explained before, the slink field is used to link all gadgets together. Here is an example of its use:

	MODULE Example16;
	IMPORT Display, Gadgets, Oberon, Objects;

	PROCEDURE Drop*;
	VAR F: Display.Frame; u, v: INTEGER;
		C: Display.ConsumeMsg; obj, obj1: Objects.Object;
	BEGIN
		Gadgets.ThisFrame(Oberon.Pointer.X, Oberon.Pointer.Y, F, u, v);

		obj := Gadgets.CreateObject("BasicGadgets.NewCheckBox");
		obj1 := Gadgets.CreateObject("BasicGadgets.NewButton");
		obj1(Gadgets.Frame).X := obj(Gadgets.Frame).W + 10;	(* position it *)

		obj.slink := obj1;	(* link gadgets together *)
		C.F := F;
		C.id := Display.drop;
		C.obj := obj;
		C.u := u; C.v := v;
		Display.Broadcast(C)
	END Drop;
	
	END Example16.

	The setting of the X coordinate of the second gadget prevents both gadgets from being inserted on top of each other. The list of gadgets in the slink chain forms a local coordinate system where the relative position between gadgets is maintained in their new container.

	Removing a gadget from the display space uses the remove variant of the Display.ControlMsg:

	MODULE Example17;
	IMPORT Display, Oberon;

	PROCEDURE Remove*;
	VAR F: Display.Frame; R: Display.ControlMsg;
	BEGIN
		F := Oberon.MarkedFrame();
		R.id := Display.remove; R.F := F;
		Display.Broadcast(R)
	END Remove;

	END Example17.

The Display.ControlMsg unifies two unrelated functions in a single message. The remove variant removes the destination gadget from the display space. The restore and suspend variants are of informational nature, as sketched below.

		ControlMsg = RECORD ( FrameMsg )
			id: INTEGER	(* Remove, suspend, restore. *)
		END;

To remove many gadgets from the display space, the destination frame is interpreted as the head of the list of slink connected frames to be removed. This is a break in style as the destination frame is interpreted as a list. After removing the necessary children, the container updates its display representation. The suspend variant warns that all frames from the destination downwards in the display space will be temporarily removed from the display space: only those frames located in the display space receive message broadcasts. The restore variant informs the gadget that it is about to be reached by broadcast again, allowing it to re-synchronize with its model.
	Finally, it remains for us to specify how to change the location of a gadget; there are two possibilities. First, a gadget can be moved from one container to another in a drag-and-drop fashion. This is accomplished with a remove from the old container followed by a consume into the new container, with the messages introduced before. Second, a gadget may change its position (or size) inside the same container with the Display.ModifyMsg.

    ModifyMsg = RECORD (FrameMsg)
      id: INTEGER;	(* Reduce, extend, move. *)
      mode: INTEGER;	(* Modes display, state. *)
      dX, dY, dW, dH: INTEGER;	(* Change from old coordinates (delta). *)
      X, Y, W, H: INTEGER	(* New coordinates. *)
    END;

The following example shows how to move the selected gadget a number of pixels to the right:

	MODULE Example18;
	IMPORT Display, Gadgets, Objects;

	PROCEDURE Move*;
	VAR F: Objects.Object; time: LONGINT; M: Display.ModifyMsg;
	BEGIN
		Gadgets.GetSelection(F, time);
		IF time >= 0 THEN
			WITH F: Display.Frame DO
				M.F := F; M.id := Display.move; M.mode := Display.display;
				M.X := F.X + 10; M.Y := F.Y; M.W := F.W; M.H := F.H;

				M.dX := M.X - F.X; M.dY := M.Y - F.Y;
				M.dW := M.W - F.W; M.dH := M.H - F.H;
				Display.Broadcast(M)
			END
		END
	END Move;

	END Example18.

The RECORD fields of the ModifyMsg have the following meaning:

id	Either Display.move, Display.extend, or Display.reduce. Display.move
	requests a translation, whereas Display.extend and Display.reduce
	request a translation or change in size (in the Gadgets system
	both options are regarded the same).
mode	state requests an update of coordinates whereas
	display requests an update of coordinates and an immediate
	redisplay of the gadget.
X, Y, W, H	New relative location and size of the gadget inside its container.
dX, dY, dW, dH	Change from previous coordinates (must be set).

	The mode field allows optimization of a move operation. In the implementation above, the gadget is moved immediately after the message broadcast. If we had to move a thousand gadgets this could take unnecessary time for each update. When we set the mode flag to Display.state, however, the gadget is moved but not displayed immediately. A call to Gadgets.Update then updates the container of the gadget in one go:

	MODULE Example19;
	IMPORT Display, Gadgets, Objects;

	PROCEDURE Move*;
	VAR SM: Display.SelectMsg; M: Display.ModifyMsg; obj: Objects.Object;
	BEGIN
		SM.id := Display.get; SM.F := NIL; SM.sel := NIL; SM.obj := NIL;
		SM.time := -1;
		Display.Broadcast(SM);

		IF SM.time >= 0 THEN
			obj := SM.obj;
			WHILE obj # NIL DO
				M.F := obj(Display.Frame);
				M.id := Display.move; M.mode := Display.state;
				M.X := M.F.X + 10; M.Y := M.F.Y; M.W := M.F.W; M.H := M.F.H;

				M.dX := M.X - M.F.X; M.dY := M.Y - M.F.Y;
				M.dW := M.W - M.F.W; M.dH := M.H - M.F.H;
				Display.Broadcast(M);

				obj := obj.slink
			END;
			Gadgets.Update(SM.sel)
		END
	END Move;

	END Example19.

	This example illustrates how the Display.SelectMsg is used to return the parent of the selection (SM.sel). A call to Gadgets.GetSelection is not possible here as it does not return the parent.

Link Handling.	Recall that gadgets have attributes that configure their state and behavior. The attribute message (Objects.AttrMsg) allows us to inspect and manipulate attributes. When a gadget is located in the display space though, a gadget also knows about gadgets in its vicinity, for example its brother, or its model. This knowledge is made explicit with links. A link is a one-way connection between a gadget and its "friends" (i.e. the other gadgets that it knows about). The "Model" link of a gadget, for example, is a connection to the gadget's model (if any). Links, like attributes, have names. Every visual visual gadget for example has a Model link. Some other links might be "decorations" that are added to a gadget. The analogue message to the Objects.AttrMg is the Objects.LinkMsg. It has the following definition:

	LinkMsg = RECORD (Objects.ObjMsg)
		id: INTEGER;	(* get, set or enum. *)
		Enum: PROCEDURE (name: ARRAY OF CHAR);
			(* Called by object to enumerate link names. *)
		name: Name;	(* Link name. *)
		res: INTEGER;	(* Return result: < 0 = no response, >= 0 action completed. *)
		obj: Object	(* Value of the link to be set, or link result. *)
	END;

The message is used to set, retrieve and enumerate links between objects. As the LinkMsg has a similar behavior to the AttrMsg, we won't go into details about it. However, the class field is absent, since only objects can be set or retrieved. Although each gadget has an obj field in which the object to be set or retrieved as a link is passed, this field is not exclusively used as reference to the gadgets model. This is in accordance with the principle of complete control that a gadget may possess; it may manage its own internal state as it sees fit. The latter prerogative forces us to use the link message to build or inspect the structures existing between gadgets. The primary usage of the link message is to either inspect or set the model of a gadget. Gadgets.CreateViewModel, for instance, uses it to create a view/model pair in one go.
	Module Links provides a more convenient procedural interface for setting and getting links which hide the messaging mechanism:

	GetLink(obj: Objects.Object; name: ARRAY OF CHAR; VAR ob1: Objects.Object);
	SetLink(obj: Objects.Object; name: ARRAY OF CHAR; ob1: Objects.Object);

Decorations.	Experience shows that it is often useful to "attach" new attributes to objects that the objects did not originally define. The attached attributes live with the predefined attributes and are usually ignored by the object itself, as it would not know what to do with them. A similar facility of attaching links also exists, enabling the user or programmer to connect objects to others. Just as for attributes the object is not aware of links that have been attached to it. The types Gadgets.Object and Gadgets.Frame, introduced at the beginning of this section, export a field attr that references an abstract data structure that keeps track of these attributes. The same holds true for the common field link that manages the link data structure.

The Attribute Scanner.	We shall now make a small digression to discuss a useful tool that simplifies the scanning of text parameters. Technically it has little to do with gadgets, except that it is delivered as a part of the Gadgets system to expand the macro characters of commands executed by gadgets.
	Module Attributes provides a Scanner very similar to that of module Texts. The Texts.Scanner has already been introduced earlier in this chapter, so the general behavior of the Attributes.Scanner can be inferred directly. The attribute scanner has some useful features that distinguish it from the text scanner. First, the attribute scanner can also scan objects that float in the parameter text. For these a new scanner class called Attributes.Obj is introduced. The scanned object is returned in the obj field of the scanner. Second, the attribute scanner expands macro characters appearing in commands directly as the text is scanned. The most useful feature is the automatic expansion of the text selection macro character "^". The attribute scanner automatically replaces ^ with the selection. In this case, the selection is more precisely defined as the text stretch starting at the first selected character and ending at the first whitespace character past the end of the selection, that is, the last word is automatically included. The use of the attribute scanner is recommended, since it eliminates the need to test explicitly for a "^" as a parameter. Compare the next example with Example5 written earlier using the Texts.Scanner:

	MODULE Example20;
	IMPORT Attributes, Oberon, Texts;

	PROCEDURE Open*;
	VAR S: Attributes.Scanner;
			T: Texts.Text;
	BEGIN
		Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Attributes.Scan(S);
		IF S.class = Attributes.Name THEN	(* was a valid file name scanned? *)
			NEW(T); Texts.Open(T, S.s);
			Oberon.OpenText(S.s, T, 250, 200)
		END
	END Open;

	END Example20.

	Example20.Open Example4.Mod~
	Example20.Open ^

How to find objects in text.	Gadgets floating in text can be detected in two different ways. First, using the attribute scanner which recognizes objects as belonging to the class Attributes.Obj, among other things. Second, and somewhat more efficiently, using a Finder which detects exclusively objects. It is thus quite easy to hop from object to object, ignoring the surrounding text.

	MODULE Example21;
	IMPORT Attributes, Oberon, Objects, Texts, Example9;

	PROCEDURE ScanObjects*;
	VAR S: Attributes.Scanner;
	BEGIN
		Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Attributes.Scan(S);
		WHILE ~S.eot DO
			IF S.class = Attributes.Obj THEN
				Example9.Info(S.o)
			END;
			Attributes.Scan(S)
		END
	END ScanObjects;

	PROCEDURE FindObjects*;
	VAR F: Texts.Finder; obj: Objects.Object;
	BEGIN
		Texts.OpenFinder(F, Oberon.Par.text, Oberon.Par.pos);
		Texts.FindObj(F, obj);
		WHILE ~F.eot & (obj # NIL) DO
			Example9.Info(obj);
			Texts.FindObj(F, obj)
		END
	END FindObjects;

	END Example21.

	Example21.ScanObjects ~
	Example21.FindObjects ~

Gadget Construction.	In general, the creation of new gadgets with Gadgets.CreateObj, the changing of attributes with Objects.AttrMsg, and the construction of links with Objects.LinkMsg, are enough to build interesting gadget constellations. However, many Gadgets system modules provide procedures to glue gadgets together. For example, the Iconizer gadgets provide a way of creating an Iconizer out of the two "cards" appearing on each side of it (see the description in the Standard Gadgets Reference). Now, take a look at a complete example for building little pop-up menus. It shows all the features of the Gadgets system we have described so far, including the use of exported comments (an exported comment statement has the form (** ... *) ).

MODULE Popups; (* jm 14.11.94 *)

(**
This is an example program to show how you can combine gadgets together by program control. The same effect can also be obtained completely interactively with the graphical user interface.

Insert a popup at the caret with the command:

	Popups.Insert "My menu"

The module builds a small popup menu from a Panel with a descriptive text on one side, and a TextNote on the other side. The Iconizer can be opened in-place and text entered inside the TextNote. You may also change the "Cmd" attribute of the TextNote to directly open what you click on with:

	Gadgets.ChangeAttr Cmd "Desktops.OpenDoc #Point" ~

Note: There is one problem though: should the command be executed from a TRAP viewer, the popup will not close again.
*)

IMPORT
	Attributes, Display, Gadgets, Icons, Oberon, Objects, Panels,
	TextFields, TextGadgets, Texts;

PROCEDURE InsertFrame (F, f: Display.Frame; u, v: INTEGER);
VAR C: Display.ConsumeMsg;
BEGIN
	C.id := Display.drop; C.F := F; C.obj := f; C.u := u; C.v := v; C.res := -1; C.dlink := NIL;
	F.handle (F, C)
END InsertFrame;

PROCEDURE Build* (desc: ARRAY OF CHAR; T: Texts.Text; W, H: INTEGER): Objects.Object;
VAR F: Icons.Iconizer; close: Panels.Panel; open: TextGadgets.Frame;
	caption: TextFields.Caption; t: Texts.Text;
BEGIN
	NEW (close); Panels.InitPanel (close);
	close.W := W; close.H := H;

	Attributes.StrToTxt (desc, t);
	NEW (caption); TextFields.InitCaption (caption, t);

	IF caption.W + 20 >= close.W THEN close.W := caption.W + 20 END;

	InsertFrame (close, caption, close.W - caption.W - 5, -close.H + 3);

	Attributes.SetBool (close, "Locked", TRUE);
	NEW (open); TextGadgets.Init (open, T, TRUE);

	NEW (F); Icons.MakeIconizer (F, close, open);
	Attributes.SetBool (F, "Popup", TRUE);
	RETURN F
END Build;

PROCEDURE Insert*;
VAR S: Attributes.Scanner; T: Texts.Text;
BEGIN
	Attributes.OpenScanner (S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan (S);
	IF (S.class = Attributes.Name) OR (S.class = Attributes.String) THEN
		NEW (T); Texts.Open (T, "");
		Gadgets.Integrate (Build (S.s, T, 60, 25))
	END
END Insert;

END Popups.

We suggest that you use the commented module definitions to trace exactly what happens in the example above. Of course, the program is not strictly needed; everything that this program does can be done interactively or with the help of a LayLa description as is shown in Chapter 6.

Copying Objects.	Although it might seem a harmless operation at first sight, copying an object is definitely not a simple thing. This is because only the object knows how to copy itself and at the same time an object does not have complete knowledge of the data structure it finds itself in. This conflict between local and global knowledge makes it difficult to make an exact copy of a complicated data structure.
	Both shallow and deep copies are initiated by sending an Objects.CopyMsg to the root object of the data structure to be copied:

	CopyMsg = RECORD (Objects.ObjMsg)
		id: INTEGER;	(* Copy style: Objects.deep or Objects.shallow. *)
		obj: Object	(* Result of the copy operation. *)
	END;

The receiver returns a copy of itself in the obj field of the message. To implement a deep copy, a receiver container forwards the CopyMsg to its children, which in turn return copies of themselves, which are then inserted into the newly created container.
	When the data structure being copied is a tree, the technique above works well. We have however to make special provision for the case when the data structure is a DAG or a graph; that is, the recursively propagated CopyMsg arrives through two or more paths at the same object, which promptly makes two or more copies of itself (although only one copy should be made, of course). The solution is to distinguish between the first time and the remainder of the times an object receives the CopyMsg by using the message time stamp. Should an object receive the CopyMsg a second time, it returns the copy it made the first time. Only in this way can perfect deep copies be guaranteed. For the moment though we can ignore the exact behavior of an object on the CopyMsg; more important to know is that the message time stamp should be set correctly when a deep copy is to be made.
	The following example makes a deep copy of the selection, inserting the result at the caret:

	PROCEDURE Copy*;
	VAR M: Display.SelectMsg; p, nl: Objects.Object; time: LONGINT;
			C: Objects.CopyMsg;
	BEGIN
		Gadgets.GetSelection(p, time);
		IF time > 0 THEN
			nl := NIL;
			Objects.Stamp(C);	(* set the message time stamp *)
			WHILE p # NIL DO
				C.id := Objects.deep; p.handle(p, C);
				C.obj.slink := nl; nl := C.obj;
				p := p.slink
			END;
			Gadgets.Integrate(p)
		END;
	END Copy;

We keep in nl a reference to the last copied gadget to link it to the next gadget copied. Also notice how all the instances of CopyMsg sent have the same time stamp. This procedure is exactly what is provided by Gadgets.Copy which frees the programmer from setting up an Objects.CopyMsg.

The Message Thread.	We have discussed so far how to create gadgets, manipulate them and copy them. All of these operations have a direct relation to the display space. Truly, the exact structure of the display space is hidden from the gadget programmer, as each container takes the responsibility for its children, and we should never interfere from the outside directly in the matters of a container. Instead, we should broadcast messages to influence gadgets in the display space. Also not mentioned explicitly so far is that a child seldom knows in what container it is located (i.e. there is no direct back pointer). This is an important design decision in the Gadget system, and forms the basis of the complete integration property of gadgets.
	The lack of knowledge a gadget has about the display space it is located in, sometimes conspires against us. In some cases, a gadget should at least know the container it is located in (to find its siblings using the FindMsg), and in less frequent cases the document it is located in. In principle, a gadget needs to know about all its ancestors right up to the display space root, but admittedly in practice it will seldom be the case. Since an object obtains control only when a message is sent to it, and most often, through a message broadcast, is suffices to "remember" the path that a message travelled to reach it. This we call the message thread.
	The message thread is a list of objects (often visual gadgets) through which a message travelled through the display space to reach a gadget. The list is constructed in a backwards fashion from the receiver to its container, then to the container of that container and so on all the way up to the display root at the top. As a gadget knows that it received a message, the gadget itself must not be inserted into the message thread; the message thread thus starts at the container of the receiver. The start of the message thread is passed inside of the message itself; this is the function of the dlink field which points to the container of the message receiver. The thread continues through the dlink field of the Objects.Object base type. The following example shows how to visit all the ancestors of a gadget in turn:

	MODULE Example22;
	IMPORT Gadgets, Objects, Example9;

	PROCEDURE ShowThread*;
	VAR obj: Objects.Object;
	BEGIN
		obj := Gadgets.context;
		WHILE obj # NIL DO
			Example9.Info(obj); obj := obj.dlink
		END
	END ShowThread;
	
	END Example22.

	We use Gadgets.context as the starting point of the message thread. This global variable is set when a gadget executes a command, and is exactly the dlink value of the InputMsg that caused the command to be executed in the first place (when you clicked on the gadget). The exact behavior of the InputMsg is discussed in the section on programming visual gadgets.


5.10	Persistency and Libraries

Files.	The prerequisite for persistent objects is a file system; the objects have to be written to a file in order not to disappear forever when the machine is switched off. Thus, before we can introduce the persistency mechanism of Oberon, we have to introduce the Oberon file system and its two unique features.
	First, a distinction is made between a file (a potentially infinite collection of bytes) and the way that file is accessed. The latter is called a Rider. The rider access mechanism can be set to a certain location in the file (offset from the beginning of the file), from where data can be read or written, advancing the rider forward by one position for each byte read or written. More than one rider can be positioned on the same file, each rider having potentially a different position. During reading, the rider sets an end-of-file flag when the end of the file is reached. Writing beyond the end of a file with a rider enlarges the file.
	The second unique feature is that files can be anonymous (nameless) in Oberon. In fact, a newly created file does not appear in the file directory under its name until it is explicitly registered. The separation of a file and its location (directory) provides two interesting possibilities to the Oberon programmer. It is possible to write temporary data to an anonymous file without making the file visible to any other Oberon module. The atomic nature of the register operation allows a file to appear suddenly in the directory, possibly replacing a file in a flash. When an open named file is suddenly deleted by another module, the file becomes anonymous, but it is still possible to access it without fear of an unexpected system behavior. Unregistered anonymous files are simply deleted from disk when they are not used anymore.
	The Oberon Files module provides the interface to the Oberon file system. To ensure portability of documents between all Oberon platforms, the Files module provides a way to store the basic types of the Oberon programming language in a machine independent way. The types File and Rider are the only exported types of the Files module:

	TYPE
		File = POINTER TO Handle;
		Rider = RECORD
			eof: BOOLEAN;	(* Rider has reached the end of the file. *)
			res: LONGINT;	(* Rider operation result code. *)
		END;

Note that the file representation is hidden; Files.Handle is not exported. The following functions allow us to open or to create a file:

	(* Open an existing file. The same file descriptor is returned if a file is opened multiple times. *)
	PROCEDURE Old (name: ARRAY OF CHAR): File;

(* Creates a new file with the specified name. The same file descriptor is not returned with multiple calls to New with the same file name (this results in multiple copies of a file with the same name. i.e. the files are not registered in the directory). *)
	PROCEDURE New (name: ARRAY OF CHAR): File;

	From now on, the examples will be presented as "no frills" texts concentrating on the essential but nevertheless offering "bare-bone" workable modules and procedures. Usable implementations would require the construction of conditional statements testing and acting on conditions such as "is this string a valid name?", "does this file exist already?", "is the caret set?", "is there a selection?", etc. The examples are offered as workable solutions under the express condition that the rules dictated by the programs are adhered to. If not, a trap is around the corner.

	The following example module shows how to set a rider and how to read and write data using the rider. This is a typical example of how to access files:

	MODULE Example23;
	IMPORT Files, Oberon, Texts, RandomNumbers;
	VAR F: Files.File; R: Files.Rider;
			S: Texts.Scanner; W: Texts.Writer;
			i, max: LONGINT; res: INTEGER; r: REAL;

	PROCEDURE StoreData*;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		F := Files.Old(S.s);
		IF F = NIL THEN	(* the file does not exist, a new file is created *)
			F := Files.New(S.s);
			Files.Set(R, F, 0)
		ELSE	(* the file exists already, data is appended *)
			Files.Set(R, F, Files.Length(F))
		END;
		i := 0; max := ENTIER(RandomNumbers.Uniform() * 10);
		WHILE i < max DO
			Files.WriteReal(R, RandomNumbers.Uniform()); INC(i)
		END;
		Files.Register(F)
	END StoreData;

	PROCEDURE ProcessFile*;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		F := Files.Old(S.s);
		Files.Set(R, F, 0);
		Files.ReadReal(R, r);
		WHILE ~R.eof DO
			(* .... *)
			Files.ReadReal(R, r)
		END
	END ProcessFile;

	PROCEDURE StoreTemp*;
	BEGIN
		F := Files.New("");
		Files.Set(R, F, 0);
		i := 0; max := ENTIER(RandomNumbers.Uniform() * 10);
		WHILE i < max DO
			Files.WriteReal(R, RandomNumbers.Uniform()); INC(i)
		END;
(*	Files.Register(F);	Do NOT register *)
		Files.Set(R, F, 0)
			(* Process the file as shown in ProcessFile ... *)
	END StoreTemp;

	PROCEDURE RenameFile*;
	VAR oldName: ARRAY 64 OF CHAR;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		COPY(S.s, oldName);
		Texts.Scan(S);
		Files.Rename(oldName, S.s, res)
	END RenameFile;

	PROCEDURE DeleteFile*;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		Files.Delete(S.s, res)
	END DeleteFile;

	END Example23.

	Example23.StoreData Test	- Create the file and store data in it,
										if it already exists append some data
	Example23.ProcessFile Test	- Process the file
	Example23.RenameFile Test testNew	- Rename the file Test to TestNew
	Example23.DeleteFile Test	- Delete the file

	Example23.StoreTemp	- Create a temporary file and process it from the start

A temporary file is created with Files.New and is never registered. Its name may be the empty string "". The disk space is reclaimed at the time of the next session. When a file is deleted or renamed, we recommend the handling of the res (result code) be expanded to cope with possible error situations.
	The description above provides enough knowledge for simple file operations. There are however several other operations; these can be studied in the Files definition and won't be repeated here.

How to store and load text from a file.

	MODULE Example24;
	IMPORT Display, Files, Oberon, Texts;
	VAR F: Files.File; R: Files.Rider; S: Texts.Scanner; W: Texts.Writer;

	PROCEDURE StoreText*;
	VAR beg, end, time, len: LONGINT; T, TS: Texts.Text; B: Texts.Buffer;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		Oberon.GetSelection(TS, beg, end, time);	(* get the selection *)
		F := Files.New(S.s);
		Files.Set(R, F, 0);
		NEW(B); Texts.OpenBuf(B);
		Texts.Save(TS, beg, end, B);	(* copy the selection to the buffer B *)
		NEW(T); Texts.Open(T, "");
		Texts.Append(T, B);
		Texts.Store(T, F, Files.Pos(R), len);
		Files.Register(F);
		Files.Close(F);
	END StoreText;

	PROCEDURE LoadText*;
	VAR T: Texts.Text; C: Oberon.CaretMsg; B: Texts.Buffer;
			len: LONGINT; ch: CHAR;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		F := Files.Old(S.s);
		Files.Set(R, F, 0);
		C.id := Oberon.get; C.F := NIL; C.car := NIL; C.text := NIL;
		Display.Broadcast(C);	(* where is the caret? *)
		NEW(T);
		Files.Read(R, ch);	(* Read the 1-byte block identifier. *)
		IF ch = Texts.TextBlockId THEN	(* It must be a text block *)
			Texts.Load(T, F, Files.Pos(R), len);
			NEW(B); Texts.OpenBuf(B);
			Texts.Save(T, 0, T.len, B);
			Texts.Insert(C.text, C.pos, B)
		END
	END LoadText;

	END Example24.

	Example24.StoreText Test1		- The selected text is stored in Test1.
	Example24.LoadText Test1 ~

The store and the load processes are asymmetric: at load time, the rider must be positioned after the first byte, that is the block identifier which was written by the store procedure.

Introductory technical background information on libraries.	Although it is possible to store a single gadget in a file (for example a container without its children), the most often used case is to store a collection of gadgets like a document. To store and then later reload a gadget collection to and from a disk file requires two problems to be solved.
	First, we have to store the data belonging to each gadget, for example the value field of a TextField or of a Slider. Preferably the data format must be organized in such a way that we can read the data into a different Oberon implementation independent of byte ordering. Since the Files module provides a platform-independent way to store multi-byte basic types, the solution is already present.
	The second and more difficult aspect is to store the relationships (references) between gadgets in a document. We have to keep track of the model connected to a view, or of the children of a container, so that a load results in exactly the same structure as was stored (this is similar to making a deep copy of a gadget). At run-time, references between objects in the heap are by memory addresses, in other words a pointer from one object to another contains the address of the referenced object. As we cannot influence the address at which an object is allocated, we cannot store addresses to a file; the address would be invalid as soon as we try to load the objects from the file. The solution to this problem is to use a different format for storing pointers. Converting to and from POINTER notation to this format is called pointer swizzling.
	The idea is quite simple. Before storing a data structure, each object in that data structure is given a number. Instead of storing the address of a reference, we can store the number of the referenced object. At load time we need a way to convert the number read back into a pointer. Of course, this scheme could use the address as the reference number, although in practice the magnitude of pointer addresses makes it impractical. During loading, a reference number can be converted into a POINTER only if the referenced object has already been created. This suggests two requirements of our storage scheme: there is a partial ordering between objects during storing and loading, and we need auxiliary data structures to keep track of POINTERs and reference numbers. These two problems are solved in Oberon by introducing libraries, and a two-phase store and load protocol.

Libraries.	In essence, a library is a dynamically growing array of objects and the reference number of an object is nothing else than the index of that object in a library. A more formal definition of a library can thus be given: a library is an abstract class whose instances are collections of objects. Within the scope of a library, reference numbers identify objects uniquely and invariantly. The action of binding an object to a library gives it a reference number. Once objects are bound to a library, they can be made permanent by storing the whole library contents on disk. Both loading and storing of libraries is built in a standard way into module Objects. Unbound objects are called free.
	Libraries provide a useful mechanism to organize a collection of objects. We can imagine functions that pick selected gadgets straight from the library according to reference number. This idea is incorporated into the Oberon system by creating two types of libraries: private and public. Private libraries are used by applications only for persistent data structures. They are unnamed, hence are also dubbed anonymous, and are typically hidden somewhere in the data files of an application. Public libraries by contrast are used as general object repositories. Public libraries are named and are stored in files with the extension .Lib. Whereas private libraries can be loaded multiple times into memory (each library having different object instances), public libraries are loaded when demanded and then cached in memory until not used anymore. That is, loading a public library with the same name twice, returns the same library each time.
	Each object knows its library and reference number:

	Object = POINTER TO ObjDesc;
	ObjDesc = RECORD
		stamp: LONGINT;	(* Time stamp of last message processed by object. *)
		dlink,	(* Next object in the message thread. *)
		slink: Object;	(* Next object in a list of objects. *)
		lib: Library; ref: INTEGER;	(* Library and reference number of object. *)
		handle: Handler	(* Message handler. *)
	END;

A free object has a NIL value in the lib field. Here follows a partial definition of a library as found in module Objects:

	Library = POINTER TO LibDesc;
	LibDesc = RECORD
		name: Name;	(* name of the library. Private library when "", else public library. *)
		dict: Dictionary;	(* Object names. *)
		maxref: INTEGER;	(* Highest reference number used in library. *)

		(* Return a free reference number. *)
		GenRef: PROCEDURE (L: Library; VAR ref: INTEGER);

		(* Return the object with the indicated reference number. *)
		GetObj: PROCEDURE (L: Library; ref: INTEGER; VAR obj: Object);

		(* Insert an object under the indicated reference number. *)
		PutObj: PROCEDURE (L: Library; ref: INTEGER; obj: Object);

		(* Free object with indicated reference number. *)
		FreeObj: PROCEDURE (L: Library; ref: INTEGER);
	END

To allow the extension of libraries, the four procedures listed above are defined as methods (procedure variables of Objects.LibDesc). At this moment it is enough to know that an object will bind itself to a library when we send the Objects.BindMsg to it:

	BindMsg = RECORD (Objects.ObjMsg)
		lib: Library	(* Library where object should be bound. *)
	END;

A container gadget forwards the BindMsg to its children and a visual gadget linked to a model gadget forwards the BindMsg to the model so that they are bound to the same library. The implementation of the BindMsg typically looks as follows (and is an auxiliary procedure in module Gadgets which makes use of the methods GenRef and PutObj defined above):

	PROCEDURE BindObj (obj: Objects.Object; lib: Objects.Library);
	VAR ref: INTEGER;
	BEGIN
		IF lib # NIL THEN
			IF (obj.lib = NIL) OR (obj.lib.name[0] = 0X) & (obj.lib # lib) THEN
				lib.GenRef(lib, ref);
				IF ref >= 0 THEN
					lib.PutObj(lib, ref, obj);
				END
			END
		END
	END BindObj;

In general, it is irrelevant in what type of library (public or private) objects are located. As a rule, each object is a member of at most one library and an object belonging to a public library cannot be rebound to any other library, whereas an object belonging to a private library can be rebound to another private or public library. The IF statement ensures the binding rules: the object to bind must be free or may be bound already to another private library.
	At this stage, it is not essential to know how objects store references to each other when stored inside a library; we will discuss this when we describe programming new gadgets. For the moment, we show how to store a selected gadget into a library which is then stored in a file and how to load it back from there and insert it at the caret:

	MODULE Example25;
	IMPORT Files, Gadgets, Oberon, Objects, Texts;
	VAR F: Files.File; R: Files.Rider; S: Texts.Scanner;

	PROCEDURE StoreGadget*;
	VAR B: Objects.BindMsg;
			time, len: LONGINT; obj: Objects.Object;
	BEGIN
		Gadgets.GetSelection(obj, time);
		IF time >= 0 THEN
			Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
			F := Files.New(S.s);
			Files.Set(R, F, 0);
			NEW(B.lib); Objects.OpenLibrary(B.lib);
			obj.handle(obj, B);	(* bind the object to the library *)
			Files.WriteInt(R, obj.ref);	(* Note the reference number *)
			Objects.StoreLibrary(B.lib, F, Files.Pos(R), len);
			Files.Register(F)
		END
	END StoreGadget;

	PROCEDURE LoadGadget*;
	VAR obj: Objects.Object; L: Objects.Library;
			ref: INTEGER; len: LONGINT; ch: CHAR;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		F := Files.Old(S.s);
		Files.Set(R, F, 0);
		NEW(L); Objects.OpenLibrary(L);
		Files.ReadInt(R, ref);	(* Obtain the object reference number. *)
		Files.Read(R, ch); (* Skip the 1-byte block identifier. *)
		Objects.LoadLibrary(L, F, Files.Pos(R), len);
		L.GetObj(L, ref, obj);
		Gadgets.Integrate(obj)
	END LoadGadget;

	END Example25.

	Example25.StoreGadget Test1
	Example25.LoadGadget Test1 ~

The two procedures LoadLibrary and StoreLibrary of module Objects load and store a library from and to a file. The library is positioned at pos in file F and has a length len. The bound objects and dictionary are packaged inside the extent [pos, pos+len) of the file. The first procedure requests each of the objects to read their contents from the file and the second to write their contents to the file using a Rider. The two requests are combined in the Objects.FileMsg with variants load and store.

		FileMsg = RECORD (ObjMsg)
			id: INTEGER;	(* load or store *)
			len: LONGINT;	(* Length of the object data on loading. *)
			R: Files.Rider	(* Rider with which to load or store data. *)
		END;

The FileMsg which is used behind the scene, passes a Files.Rider to the object which should store or read data.

Dictionaries.	We already know that an object can be given a name, which is used to find the object in a user interface made of a collection of gadgets. A similar (but not the same) idea is used to locate objects in a public library. Since the exact reference number of an object in a public library might change due to editing of the library (which can be done using the Libraries.Panel), we must be careful when noting and storing references to public objects. To guard against such unexpected changes, we can associate a name (a string) with a reference number in the library. Using that given name, we can then retrieve the reference number from the dictionary, which is finally used to locate the object itself. The collection of (name, reference number) pairs of a public library is called a dictionary and is realized as an abstract type connected to a library. Note that we do not say that a dictionary name is associated with an object in a public library; just the name and the corresponding reference number are remembered. Of course, from the reference number in the dictionary we can retrieve the object having that reference number. In effect we are creating another way to name an object (a public object, to be precise). It is important to realize that this name is not the same as the name of the object. The latter is an attribute of an object. Thus the name of an object can differ from the public name of the object.

	The maintenance of the (reference, name) dictionary pairs is performed using the following primitives of module Objects:

	(* Associate a name with a reference number. *)
	PROCEDURE PutName (VAR D: Dictionary; key: INTEGER; name: ARRAY OF CHAR);

	(* Get name associated with a key/reference number. *)
	PROCEDURE GetName (VAR D: Dictionary; key: INTEGER; VAR name: ARRAY OF CHAR);

	(* Given an object name, return the object reference number from the dictionary. *)
	PROCEDURE GetRef (VAR D: Dictionary; name: ARRAY OF CHAR; VAR ref: INTEGER);

	Dictionaries have been designed in such a way that they can be used for another purpose too. The main idea is to use them also as repositories of often used strings; these strings are called atoms and are associated with negative reference numbers, which are then called keys. That explains why the second parameter of two of the above procedures is named "key" instead of "ref" as would be expected. This feature is used to reduce the file size of libraries, but at the same time it does complicate the dictionary interface a little bit. For the moment, it is of little interest to us. The following procedure in the module Objects is used to obtain a key for an atom. Note the analogy with the method GenRef mentioned earlier.

	(* Allocate a key (any integer < 0) to a name. *)
	PROCEDURE GetKey (VAR D: Dictionary; name: ARRAY OF CHAR; VAR key: INTEGER);

	The maintenance of the (key, atom) dictionary pairs is performed using the three primitives defined above.

Public Gadgets.	As explained in the previous paragraph, the dictionary mechanism allows us to name objects in public libraries. These objects are called public objects. By convention, we refer to a public object in the form L.O, where L is the library name and O is the object name (dictionary name). Public objects have the useful property of having only one instance at any time in the system. This is an effect of public libraries being loaded only once and then cached. This makes public objects predestined to be shared between Oberon applications. Perhaps the most often used library is the Icons.Lib; it contains numerous pictures representing useful icons. Libraries are used also to store the menu bars that documents typically use. In concept, a hierarchy of public libraries can be imagined, each object using objects in other libraries. The library hierarchy has an analogue in the module hierarchy, where one libary imports another library. In practice though, the library hierarchy is flat with only one level, although nothing prevents you from using them in the more general way.
	Just as we can locate a named object in a user interface, so we can locate a public object specified in L.O notation using the procedure Gadgets.FindPublicObj. This procedure has the following implementation:

	PROCEDURE FindPublicObj (name: ARRAY OF CHAR): Objects.Object;
	VAR obj: Objects.Object; libname, objname: ARRAY 64 OF CHAR;
		i, j, k, ref: INTEGER; lib: Objects.Library;
	BEGIN
		obj := NIL; i := 0; j := 0;
		WHILE (name[i] # ".") & (name[i] # 0X) DO libname[j] := name[i]; INC(j); INC(i)
		END;
		IF name[i] = 0X THEN RETURN NIL END;
		libname[j] := 0X; k := j; INC(i); j := 0;
		WHILE (name[i] # " ") & (name[i] # 0X) DO objname[j] := name[i]; INC(j); INC(i)
		END;
		objname[j] := 0X;
		libname[k] := "."; libname[k+1] := "L"; libname[k+2] := "i"; libname[k+3] := "b";
		libname[k+4] := 0X;
		lib := Objects.ThisLibrary(libname);
		IF lib # NIL THEN
			Objects.GetRef(lib.dict, objname, ref);
			IF ref # MIN(INTEGER) THEN lib.GetObj(lib, ref, obj) END
		END;
		RETURN obj
	END FindPublicObj;

As can be seen, the biggest task is to take the name L.O apart to load the library L.Lib using Objects.ThisLibrary. Objects.ThisLibrary searches for the library in the public library cache first, and loads the public library from the disk file L.Lib if it is not there yet.

In conclusion, we show how to insert a newly created object into a public library "Test.Lib" and name it "Pluto", and how to find it again under the name "Test.Pluto" with Gadgets.FindPublicObj. If the library does not already exist, it is automatically created when Objects.ThisLibrary is executed.

	MODULE Example26;
	IMPORT Gadgets, Oberon, Objects, Texts;
	VAR S: Texts.Scanner; L: Objects.Library; obj: Objects.Object;
		B: Objects.BindMsg; C: Objects.CopyMsg;

	PROCEDURE MakePublic*;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Texts.Scan(S);
		L := Objects.ThisLibrary(S.s);
		obj := Gadgets.CreateObject("Panels.NewPanel");
		B.lib := L;
		obj.handle(obj, B);
		Texts.Scan(S);
		Objects.PutName(L.dict, obj.ref, S.s);
		L.Store(L)	(* Optional: make the addition persistent. *)
	END MakePublic;

	PROCEDURE GetPublic*;
	BEGIN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Texts.Scan(S);
		obj := Gadgets.FindPublicObj(S.s);
		C.id := Objects.deep; Objects.Stamp(C);
		obj.handle(obj, C);
		Gadgets.Integrate(C.obj)
	END GetPublic;

	END Example26.

	Example26.MakePublic Test.Lib Pluto
	Example26.GetPublic Test.Pluto


5.11	Programming New Gadgets

Proficient programmers will often notice that they require a special gadget implementation for a special-purpose application. It might also be the case that the new gadget required should function approximately like an existing gadget with a few exceptions. The programmer must thus choose either to program a new gadget from scratch or to extend an existing gadget. Different skill levels are required depending on the classification of the programmed component as model, elementary, container, camera-view or document gadget. For example, model gadgets are easier to program than elementary visual gadgets, which are easier to program than a visual gadget that contains other gadgets.
	Extensive experience has shown that programming gadgets involves applying a set of standard design patterns. A design pattern in Oberon is a proposal how to solve a specific class of problems. In the most concrete form, a design pattern is a skeletal piece of source code that is copied and then modified for own purposes. This is a typical "fill in the blank" approach adopted by component frameworks. One does not start from scratch when programming a gadget, but some kind of prepared skeleton is already available. This allows programmers to create a partially functional gadget in no time at all. Most importantly, it allows them to develop objects incrementally by only adding features to things that already work. Surprisingly large parts of most gadgets are always the same and can thus be shared by most gadgets. They may be treated as skeletons with no blanks to fill in. Using design patterns or reusing code saves memory and simplifies programming. In more general terms, design patterns are guidelines for building software. They are intended to be general enough to be reused in many situations.
	The supporting examples make use of these generally applicable design patterns in the development of new gadgets. Though the design patterns are easily recognizable, most examples contain noticeable variations suggesting that there is still ample room left for creativity by programmers with their own ideas. By combining design patterns in innovative ways, you can quickly create new patterns that are robust and easily understood.


5.11.1	Gadget structure and implementation steps

A component consists of a type definition, message definitions, procedures to copy and initialize an object, and the ubiquitous message handler. Here is an outline of the typical module structure required for implementing an object MyObject:

MODULE Example;
	IMPORT Objects;

	TYPE
		MyObject* = POINTER TO MyObjectDesc;
		MyObjectDesc* = RECORD (Objects.Object);
			(* extended fields *)
		END;

		MyMsg* = RECORD (Objects.ObjMsg)
			(* message arguments *)
		END;

	PROCEDURE Copy* (VAR F: Objects.CopyMsg; from, to: MyObject);
		(* Copy fields of from to to *)

	PROCEDURE Handler* (F: Objects.Object; VAR M: Objects.ObjMsg);
		(* Message handler *)

	PROCEDURE Init* (obj: MyObj);	(* install message handler *)
	BEGIN
		obj.handle := Handler;
		(* initialize own fields *)
	END Init;

	PROCEDURE New*;	(* Component generator *)
	VAR obj: MyObject;
	BEGIN
		NEW(obj); Init(obj); Objects.NewObj := obj
	END New;

END Example.

Two internal views of objects are possible, namely that of the implementer of the component intending to create a new object from scratch and that of a person who wants to extend an existing base object class. The primary and probably most arduous task of the implementer is the implementation of the message handler. Depending on the class of object, different message types are to be handled. The simplest objects respond only to the object messages whereas the visual objects respond to both the object messages and the frame messages.
	To extend a component, you must export at least the object type, the message handler as well as the Copy and Init procedures of the base object. If this condition is not fulfilled, other programmers will not be able to extend your new components. The object extension must watch out that calling the Init procedure of the base object is done before initializing the extension and that the correct message handler is written over that of the base object class. Often the base type is Gadgets.Object for model gadgets, and Gadgets.Frame for visual gadgets. These base types (or better said classes) implement the standard functionality for model and visual gadgets respectively. This suggests the following implementation steps for a new gadget:

0.	choose an existing gadget type as a base,
1.	extend it with instance variables,
2.	create a new message type or extend an existing one,
3.	create a generator procedure,
4.	create an initialization procedure,
5.	create a message handler.

In many circumstances some of these steps may not be required at all, thus easing the construction exercise quite a bit.


5.11.2	Default message handling

Even though module Objects defines the AttrMsg, BindMsg, CopyMsg, FileMsg, FindMsg and LinkMsg it does not provide any support for handling these messages. In a similar manner, module Display defines the set of frame messages but does not provide further support for handling them. Some aspects of these messages have consequently been factored out into default message handlers. Handlers for extensions of Gadgets.Object and Gadgets.Frame are provided in module Gadgets. The handlers are called Gadgets.objecthandle and Gadgets.framehandle respectively. A custom designed message handler must pass control to the default handlers, and messages not understood by this message handler should be passed to the default message handler for interpretation. The following paragraphs state the default handling of the object messages by Gadgets.objecthandle and Gadgets.framehandle.

AttrMsg - The default handling includes the universal Name attribute of a gadget and the management of the attached attributes.

BindMsg - The default handling binds the object and all the objects that the attached links reference. This is done in the BindObject procedure which was described in the section on libraries.

CopyMsg - The default handling creates a copy of an object and copies the fields belonging to the base types, that is, handle and attributes. This is done in the CopyObject procedure.

FileMsg - The default handling stores or loads the fields of the base types. An object should always read exactly as many bytes as it had written previously.

FindMsg - The default handling checks if the searched for object match self, and should this be the case, return itself.

LinkMsg - The default handling involves the handling of links that have been attached to a gadget. The type Gadgets.Frame contains a field obj that refers to the model of the gadget and is seen as a link called "Model" by clients.

The following paragraphs state the default handling of the frame messages by Gadgets.framehandle.

Display.ConsumeMsg - The default handling consists in executing the command in the ConsumeCmd attribute if the gadget has one.

Display.ControlMsg - The default handling forwards the message to the gadget's model.

Display.DisplayMsg - The default handling draws a rectangular mask.

Display.LocateMsg - The default handling locates the marked gadget by its frame coordinates, width and height.

Display.ModifyMsg - The default handling includes changing the relative position or the size of a child in a container. This is done in the Adjust procedure.

Display.SelectMsg - The default handling consists in changing the state field of a gadget from selected to not selected or vice-versa. Containers typically interpret pressing the MR key as selecting/deselecting a gadget.

Oberon.InputMsg - This message is so special that it and its handling deserves a special description.

The input message Oberon.InputMsg

    InputMsg = RECORD (Display.FrameMsg)
      id: INTEGER;	(* consume, track *)
      keys: SET;	(* Mouse buttons. *)
      X, Y: INTEGER;	(* Mouse position. *)
      ch: CHAR;	(* Character typed. *)
      fnt: Fonts.Font;	(* Font of typed character. *)
      col, voff: SHORTINT	(* Color and vertical offset of typed character. *)
    END;

The input message delivers mouse (variant track) and keyboard events (variant consume) to the display space. It is repeatedly broadcast into the display space by the Oberon.Loop for each input event. Here resides a particularity of the message: the input message is interpreted by the handler which so to speak "consumes" it. All its fields are out parameters. Normally, a programmer does not write a piece of code sending out such a message. In the case of a mouse event, the fields X and Y indicate the absolute mouse position (cursor hotspot) and keys the mouse key state (which mouse buttons are pressed). The mouse keys are numbered 0, 1, 2 for right, middle, and left respectively. The display space normally forwards this message only to the frame located at position X, Y on the display. In the case of a keyboard event, the ASCII keycode is contained in the ch field (check the description of module Input for special keycodes). The fields fnt, col and voff give information about the requested font, color index and vertical offset in pixels.
	The default handling of mouse events is contained in the procedure Gadgets.Trackframe given below:

	PROCEDURE TrackFrame* (F: Display.Frame; VAR M: Oberon.InputMsg);
	VAR keys: SET; x, y, w, h: INTEGER; R: Display3.Mask;
	BEGIN
		WITH F: Frame DO
			IF ~(selected IN F.state) & (middle IN M.keys) THEN
				(* only when not selected and middle key *)
				x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H;
				IF InActiveArea(F, M) THEN
					(* usable areas, corner, sides may be part, TRUE if locked *)
					IF HasCmdAttr(F, "Cmd") THEN
						MakeMask(F, x, y, M.dlink, R);
						Effects.TrackHighlight(R, keys, M.X, M.Y, x, y, w, h);
						IF InActiveArea(F, M) & (keys = {1}) THEN
							ExecuteAttr(F(Frame), "Cmd", M.dlink, NIL, NIL)
						END;
						M.res := 0
					ELSIF ~IsLocked(F, M.dlink) THEN MoveFrame(F, M)
					ELSE Oberon.DrawCursor(Oberon.Mouse, Effects.Arrow, M.X, M.Y)
					END
				ELSIF Effects.InCorner(M.X, M.Y, x, y, w, h) & ~(lockedsize IN F.state) THEN
					SizeFrame(F, M)
				ELSIF Effects.InBorder(M.X, M.Y, x, y, w, h) OR
						Effects.InCorner(M.X, M.Y, x, y, w, h) THEN
					MoveFrame(F, M)
				ELSE Oberon.DrawCursor(Oberon.Mouse, Effects.Arrow, M.X, M.Y)
				END
			ELSE Oberon.DrawCursor(Oberon.Mouse, Effects.Arrow, M.X, M.Y)
			END
		END
	END TrackFrame;

Only the MM key is handled. Once selected, a gadget does not respond to mouse events; the parent takes control of these events. When the mouse is located in a corner, the gadget is resized. When the mouse is located in the border around the gadget, the gadget is moved.
	We suggest that you exercise this behavior with a Clock gadget inserted into a Panel. The final touch can be given by using Columbus to add a Cmd attribute to the Clock and by assigning the value "System.Time" to this attribute.


5.11.3	The class inheritance design pattern

Class inheritance means using an existing type by exchanging only the message handler. This technique can be used only if the new gadget does not have own instance variables, and has the advantage that the type hierarchy is "flatter". The immediate consequence is that the steps 1 and 2 in the list of activities above is not required and that step 4 may also be left out, unless the initialization provided by the base object is not suitable.
	As an example, we suggest creating a new class of "seek buttons" equipped with the functionality to seek sequentially through an audio file of unknown size. Clearly, a "pop-up" Button can be envisaged as first approximation assuming that a delta displacement could be initiated by the execution of a command hidden in its Cmd attribute. But on second thought, progress through the file would be controlled by an unpredictably large number of Button clicks. A better approach would be to allow the execution of such a command as long as the Button is pressed. The following source text produces the desired effect:

	MODULE SeekButtons;
	IMPORT BasicGadgets, Display, Display3, Gadgets, Input, Oberon, Objects;
	CONST middle = 1;

	PROCEDURE Handler* (F: Objects.Object; VAR M: Objects.ObjMsg);
		VAR x, y, w, h: INTEGER; Q: Display3.Mask; keysum: SET;
	BEGIN
		WITH F: BasicGadgets.Button DO
			IF M IS Oberon.InputMsg THEN
				WITH M: Oberon.InputMsg DO
					IF (M.F = NIL) OR (M.F = F) THEN
						IF (M.id = Oberon.track) & (M.keys = {middle}) &
								Gadgets.InActiveArea(F, M) THEN

							(* calculate the gadget's absolute display coordinates *)
							x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H;

							Gadgets.MakeMask(F, x, y, M.dlink, Q);
							Display3.Rect3D(Q, Display3.topC, Display3.bottomC,
														x+1, y+1, w-2, h-2, 1, Display.invert);
							keysum := M.keys;
							REPEAT
								Input.Mouse(M.keys, M.X, M.Y);
								Gadgets.ExecuteAttr(F, "Cmd", M.dlink, NIL, NIL);
								keysum := keysum + M.keys
							UNTIL M.keys = {};
							Display3.Rect3D(Q, Display3.topC, Display3.bottomC,
														x+1, y+1, w-2, h-2, 1, Display.invert);
							M.res := 0
						ELSE BasicGadgets.ButtonHandler(F, M)
						END
					END
				END
			ELSIF M IS Objects.AttrMsg THEN
				WITH M: Objects.AttrMsg DO
					IF (M.id = Objects.get) & (M.name = "Gen") THEN
						M.class := Objects.String; M.s := "SeekButtons.New"; M.res := 0
					ELSE BasicGadgets.ButtonHandler(F, M)
					END
				END
			ELSE BasicGadgets.ButtonHandler(F, M)
			END
		END
	END Handler;

	PROCEDURE New*;
		VAR obj: BasicGadgets.Button;
	BEGIN
		NEW(obj); BasicGadgets.InitButton(obj); obj.handle := Handler; Objects.NewObj := obj
	END New;

	END SeekButtons.

The generator procedure New instantiates and initializes a standard Button and replaces the handler by a new one. The first important function of this handler is to supply the value of the Gen attribute on a "get" request in an AttrMsg. This is essential for Columbus and for loading the gadget from disk. This function will be omnipresent in the construction of new gadgets. The second and only other function of the handler is to react to an MM key sollicitation differently than a standard Button. When the MM key is pressed in the "active" area of the Button, this visual gadget must redraw itself to appear pressed with a 3D effect until the key is released. For this purpose:

1 - the gadget's absolute display coordinates are calculated. Earlier in the discussion about the display space structure, we learned that F.X and F.Y are the relative coordinates of a frame in its parent frame and that F.Y is negative. The absolute coordinates of the parent's top-left corner are returned in M.x and M.y by the system. Hence the local variables x, y, w and h are set to the absolute display coordinates of the visual gadget for later use in the message handler,
2 - the display mask Q is calculated (see below),
3 - the drawing primitive Display3.Rect3D is used.

As long as the key is pressed, the handler queries which key is pressed and executes the command contained in the Cmd attribute. Behind the scene, ExecuteAttr sends an Objects.AttrMsg to retrieve the attribute. Then, the Button must again redraw itself to appear as a popped up Button. Since nothing can have changed in the display space in the mean time, the same mask is used. Apart fom this, the handler dutifully forwards all other messages to the Button handler which is equipped with all the remaining functionality required.

Display masks

The procedure Gadgets.MakeMask performs the calculation of the display mask Q through which the gadget must draw itself. The mask generation is hidden from gadget programmers, but its mechanism deserves a special description. The imaging model of Gadgets is based on rectangles and drawing is performed with masks. As the calculation of a display mask can be an expensive process, the Gadgets framework adopts a demand-driven approach for generating masks. Each and every visual gadget has its own display mask cached in its mask field: it specifies which parts of the gadget are visible, but at any one instant, a gadget has either a valid display mask, or it it has no mask at all. During editing operations in the display space, the visible part to draw may change due to new gadgets overlapping the gadget. When a modification is applied to a gadget's shape, its mask is dropped by a process called invalidating. Only when a gadget wants to draw itself, it requests a new display mask by calling Gadgets.MakeMask to activate the mask generation process. This strategy means that a gadget can operate for long periods of time without a valid mask, at least until it wants to draw something on the display.
	Mask calculation is a service a container provides for its children. A call to to this service sometimes finds a gadget without a valid mask. In that case, a Display3.UpdateMaskMsg, with the destination set to the gadget frame identified by the F field is broadcast into the display space.

		UpdateMaskMsg = RECORD (Display.FrameMsg)
		END;

All containers monitor the message, checking if it is addressed to one of their children. Should one of their own children be involved, its mask is calculated. Finally, a Display3.OverlapMsg is sent directly to the child, informing it that its new mask has been calculated. In the example, it is returned in Q.

		OverlapMsg = RECORD (Display.FrameMsg)
			M: Mask;		(** Use NIL to indicate to a frame that its current mask is invalid. *)
		END;

	To prevent numerous UpdateMaskMsg from being broadcast when many children have invalid masks, a container automatically recalculates all invalid masks of its children when the first UpdateMaskMsg arrives. This is under the assumption that if one child requires a mask, the others will do as well in the near future.
	In our example, we are constructing a elementary visual gadget and therefore the existence of the two messages in question remains concealed in the Gadgets.MakeMask procedure. However, the two messages play a role in the construction of a container gadget.


5.11.4	The model gadget design pattern (interface inheritance)

Interface inheritance involves extending an existing type with new instance variables. In this section, we take a look at programming simple objects, typically model gadgets. Although the programming of model gadgets is not so spectacular as programming visual gadgets, the knowledge gained from programming them is directly applicable to programming visual objects. It is thus important to understand what follows.
	Here is an example of a model gadget Reminder hiding a text of up to 128 characters that may be attached to a document. When a document having such an attachment is opened in a viewer, the Reminder's text is presented in the system log. Reminder is a direct extension of Gadgets.Object with a single instance variable msg. Creating the generator and the Init procedures is straightforward, but the handler which recognizes three classical object messages and a yet unencountered message type is more elaborate than the handler described earlier.
	The AttrMsg handling is reduced to its minimum, just like in the previous example. No provision is made for getting, setting or enumerating the msg field. Consequently, this field cannot be inspected or manipulated with Columbus: it is set only by the Init procedure when the gadget is instantiated. It is interesting to meet here a rare case where a gadget hides instance variables from the outside world by not "advertizing" them through the enumeration procedure. The CopyMsg handling creates a new object instance and copies the handler and all the instance variables to the new object. The FileMsg handling stores all the instance variables to a file or loads them from a file. The rest of the serialization/deserialization of the object is done by the handler of the base object. The last message processed by the handler is defined in module Gadgets and was created specially for supporting attachments:

	CmdMsg = RECORD (Objects.ObjMsg)
		cmd: ARRAY 128 OF CHAR;
			(* Information to be passed, command to be executed; result returned. *)
		res: INTEGER (* result code *)
	END;

When a document is opened, the string "PREPARE" is assigned to the cmd field of a CmdMsg which is then broadcast to all the objects linked to the document. If one of these objects happens to be a Reminder, the object's handler sends the content of the msg field to the log as specified earlier. This will be explained in the section on programming documents.

	MODULE Reminders; (* jm 1.11.95 *)

	(** Example of an object attached to a document. The object remembers
	a message that is displayed in the log when the document is opened. *)

	IMPORT Attributes, Documents, Files, Gadgets, Oberon, Objects, Out;

	TYPE
		Reminder* = POINTER TO ReminderDesc;
		ReminderDesc* = RECORD (Gadgets.ObjDesc)
			msg*: ARRAY 128 OF CHAR
		END;

	PROCEDURE Copy*(VAR M: Objects.CopyMsg; from, to: Reminder);
	BEGIN
		Gadgets.CopyObject(M, from, to);
		to.msg := from.msg
	END Copy;

	PROCEDURE Handler* (obj: Objects.Object; VAR M: Objects.ObjMsg);
		VAR obj0: Reminder;
	BEGIN
		WITH obj: Reminder DO
			IF M IS Objects.AttrMsg THEN
				WITH M: Objects.AttrMsg DO
					IF (M.id = Objects.get) & (M.name = "Gen") THEN
						M.class := Objects.String; COPY("Reminders.New", M.s); M.res := 0
					ELSE Gadgets.objecthandle(obj, M)
					END
				END
			ELSIF M IS Objects.CopyMsg THEN
				WITH M: Objects.CopyMsg DO
					IF M.stamp = obj.stamp THEN M.obj := obj.dlink	(* copy msg arrives again *)
					ELSE (* first time copy message arrives *)
						NEW(obj0); obj.stamp := M.stamp; obj.dlink := obj0; Copy(M, obj, obj0);
						M.obj := obj0
					END
				END
			ELSIF M IS Objects.FileMsg THEN
				WITH M: Objects.FileMsg DO
					IF M.id = Objects.store THEN Files.WriteString(M.R, obj.msg)
					ELSIF M.id = Objects.load THEN Files.ReadString(M.R, obj.msg)
					END;
					Gadgets.objecthandle(obj, M)
				END
			ELSIF M IS Gadgets.CmdMsg THEN (* executed when the document is opened *)
				WITH M: Gadgets.CmdMsg DO
					IF M.cmd = "PREPARE" THEN
						Out.String("Reminder: "); Out.String(obj.msg); Out.Ln
					ELSE Gadgets.objecthandle(obj, M)
					END
				END
			ELSE Gadgets.objecthandle(obj, M)
			END
		END
	END Handler;

	PROCEDURE Init* (obj: Reminder; msg: ARRAY OF CHAR);
	BEGIN obj.handle := Handler; COPY(msg, obj.msg)
	END Init;

	PROCEDURE New*;
		VAR obj: Reminder;
	BEGIN NEW(obj); Init(obj, ""); Objects.NewObj := obj
	END New;

	(** Attach a reminder to a document. *)
	PROCEDURE Attach*;
		VAR D: Documents.Document; R: Attributes.Reader; ch: CHAR; obj: Reminder;
				s: ARRAY 128 OF CHAR; i: INTEGER; M: Objects.LinkMsg;
	BEGIN
		D := Documents.MarkedDoc();
		IF D # NIL THEN
			Attributes.OpenReader(R, Oberon.Par.text, Oberon.Par.pos);
			Attributes.Read(R, ch);
			i := 0;
			WHILE ~R.eot & (ch # "~") & (i < LEN(s) - 1) DO
				s[i] := ch; INC(i);
				Attributes.Read(R, ch)
			END;
			s[i] := 0X;
			NEW(obj); Init(obj, s);
			M.id := Objects.set; M.name := "Reminder"; M.obj := obj; M.res := -1;
			D.handle(D, M);
			IF M.res >= 0 THEN Out.String("  done") ELSE Out.String("  failed") END; Out.Ln
		END
	END Attach;

	END Reminders.

Here are two examples of short messages that may be attached to a document:
	Meeting on Thursday ~
	The Align button does not work ~

The command	Reminders.Attach ^	reads up to 128 characters from the selection until a "~" or end of text and assigns this string to the msg field of a Reminder gadget which is then linked to the marked document.
	The message handler is a simple cascade of IF statements to determine the message type. As soon as the message type is determined, the message fields are opened up for access with the WITH statement. The receiver object is always passed as a first parameter to the message handler (named obj here). This message passing scheme is quite general and is applicable to objects that are not of type Objects.Object too. If needed, you can create a new object type and a message hierarchy independent of the Gadget system. What you gain by extending your objects from Objects.Object is compatibility with the Gadgets system. If you do this, you also have additional responsibilities though: your object should at least respond to the object messages.
	An earlier discussion introduced the problems of making a structure preserving deep copy of a part of the display space. As each object knows best how to copy itself, we are forced to forward the CopyMsg to each member of a complicated data structure so that that member may copy itself. As the global structure of an object data structure is not known, we have to reckon with the case when two more objects forward the same copy message to the same object. Using the message time stamp, we can uniquely identify if a copy message arrives twice at the same object. This is the goal of the standard handling of the copy message. The first time the copy message arrives, we make a copy of the object, remember the time stamp, and cache a reference to the copy returned in the dlink field of the object. If the time stamp indicates that the copy message arrives a second time (or more), we simply return a reference to the copy we made earlier. This behavior is standard for all objects, so that the IF statement executed on receiving the copy message never changes. Instead, we define a copy procedure to copy the fields of the type extension we introduce ourselves. As suspected, the call to Gadgets.CopyObject, copies the fields of the Gadgets.Object.
	To conclude the discussion of the example, we may add that typical gadgets introduce new messages (implementation step 3) for communicating with them. These are often defined in the module where the gadget type is defined, although there is no strong reason to do so. In this example, the message is defined in module Gadgets.


5.11.5	The visual gadget design pattern (interface inheritance)

The next example demonstrates the stepwise implementation of a visual gadget, a direct extension of Gadgets.Frame. We may categorize this new construction as "atomic" gadget in opposition to a visual container gadget.

Creating a new visual gadget as extension of an existing gadget type:

	TYPE
		Frame* = POINTER TO FrameDesc;
		FrameDesc* = RECORD (Gadgets.FrameDesc)
			col*: INTEGER	(* new instance variable *)
		END;

Creating a generator and an initialization procedure:

	(* needed to make further extensions of the gadget *)
	PROCEDURE Init* (F: Frame);
	BEGIN
		F.W := 50; F.H := 50;	(* only need to specify the width and the height *)
		F.col := 1;		(* initialize instance variable *)
		F.handle := Handle	(* install message handler *)
	END Init;

	PROCEDURE New*;
		VAR F: Frame;
	BEGIN
		NEW(F); Init(F);
		Objects.NewObj := F	(* global variable to return the generated gadget *)
	END New;

Creating a message handler for frame messages and object messages:

	PROCEDURE Handle* (F: Objects.Object; VAR M: Objects.ObjMsg);
		VAR x, y, w, h: INTEGER;
	BEGIN
		WITH F: Frame DO
			IF M IS Display.FrameMsg THEN
				WITH M: Display.FrameMsg DO
					IF (M.F = NIL) OR (M.F = F) THEN (* message addressed to this frame *)
						(* calculate the gadget's absolute display coordinates *)
						x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H;

						(* test and handle the frame message - Later on we shall see
							that the message may addressed to a particular device. *)
					ELSE	(* message not for this frame, forward it. *)
					END
				END
			ELSIF M IS Objects.AttrMsg THEN	...	(* handle object messages *)
			ELSIF M IS Objects.CopyMsg THEN	...
			ELSIF M IS Objects.FileMsg THEN	...
			ELSE Gadgets.framehandle(F, M)		(* delegate to default handler *)
			END
		END
	END Handle;

We save unnecessary work by testing the destination frame F as soon as possible for a true broadcast or a directed send to this gadget.

Adding an Objects.FileMsg handling:

			ELSIF M IS Objects.FileMsg THEN
				WITH M: Objects.FileMsg DO
					IF M.id = Objects.store THEN Files.WriteInt(M.R, F.col)
					ELSIF M.id = Objects.load THEN Files.ReadInt(M.R, F.col)
					END;
					Gadgets.framehandle(F, M)
				END

Gadgets.framehandle is called to store the fields of the base type. It is advisable to write a version code and to check it again on loading. This version code determines the data format that follows. The reason for this is quite simple. It is seldom that a gadget is finished; continual tweaking of the functionality eventually leads to a change of file format even though the gadget has been released long ago. To prevent the gadgets stored in the old format from becoming unloadable, we can always ensure that a gadget reads all the formats that it once wrote in its lifetime, but always writes the latest and actual format. The following example illustrates the principle:

		CONST
			VersionNo = 2; ModName = "Skeleton";

			....
			ELSIF M IS Objects.FileMsg THEN
				WITH M: Objects.FileMsg DO
					IF M.id = Objects.store THEN
						Files.WriteNum(R, VersionNo);
						Files.WriteInt(M.R, F.col)
					ELSIF M.id = Objects.load THEN
						Files.ReadNum(M.R, ver);
						IF ver = VersionNo THEN
							Files.ReadInt(M.R, F.col)
						ELSIF ver = 1 THEN
							...
						ELSE
							Texts.WriteString(W, "Version "); Texts.WriteInt(W, VersionNo, 3);
							Texts.WriteString(W, " of ");
							Texts.WriteString(W, ModName);
							Texts.WriteString(W, " cannot read version "); Texts.WriteInt(W, ver, 3);
							Texts.WriteLn(W);
							Texts.Append(Oberon.Log, W.buf);
							HALT(99)
						END
					END;
					Gadgets.framehandle(F, M)
				END

Copying a gadget:

	PROCEDURE Copy* (VAR M: Objects.CopyMsg; from, to: Frame);
	BEGIN
		to.col := from.col;	(* copy own instance variables *)
		Gadgets.CopyFrame(M, from, to)	(* copy base variables *)
	END Copy;

called from within the message handler (this code fragment is standard):

			VAR F1: Frame;
			...
			ELSIF M IS Objects.CopyMsg THEN
				WITH M: Objects.CopyMsg DO
					IF M.stamp = F.stamp THEN M.obj := F.dlink (*non-first arrival*)
					ELSE (*first arrival*)
						NEW(F1); F.stamp := M.stamp; F.dlink := F1;
						Copy(M, F, F1); M.obj := F1
					END
				END

The gadget visualization part is also a standard code fragment:

	PROCEDURE Handle* (F: Objects.Object; VAR M: Objects.ObjMsg);
	VAR x, y, w, h: INTEGER; Q: Display3.Mask;
	BEGIN
		WITH F: Frame DO
			IF M IS Display.FrameMsg THEN
				WITH M: Display.FrameMsg DO
					IF (M.F = NIL) OR (M.F = F) THEN (* message addressed to this frame *)
						x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H;

						IF M IS Display.DisplayMsg THEN
							WITH M: Display.DisplayMsg DO
							  IF M.device = Display.screen THEN
							    IF (M.id = Display.full) OR (M.F = NIL) THEN
							      Gadgets.MakeMask(F, x, y, M.dlink, Q);	(* create display mask *)
							      Restore(F, Q, x, y, w, h)
							    ELSIF M.id = Display.area THEN
							      Gadgets.MakeMask(F, x, y, M.dlink, Q);	(* create display mask *)
							      Display3.AdjustMask(Q, x+M.u, y+h-1 + M.v, M.w, M.h); (* clip mask *)
							      Restore(F, Q, x, y, w, h)
							      END
							    ELSIF M.device = Display.printer THEN Print(F, M)
							  END
							END

The procedure Gadgets.MakeMask hides the calculation of the display mask Q through which a gadget must draw itself. MakeMask is passed the absolute coordinates and the message thread, hence the visual gadget can request this calculation on receiving any frame message. When M.id is set to full, the entire frame is restored. Otherwise, the rectangular area u, v, w, h inside the destination frame is is to be redrawn and the mask is adjusted by clipping it. 

Restore is defined as:

	PROCEDURE Restore (F: Frame; Q: Display3.Mask; x, y, w, h: INTEGER);
		(* x and y are the absolute display coordinates of the mask *)
	BEGIN
		(* use clipped primitives in Display3 to draw the gadget *)
		Display3.ReplConst(Q, F.col, x, y, w, h, Display.replace);

		(* standard selection style *)
		IF Gadgets.selected IN F.state THEN
			Display3.FillPattern(Q, Display3.white, Display3.selectpat,
				x, y, x, y, w, h, Display.paint)
		END
	END Restore;

The drawing primitive Display3.ReplConst draws the gadget through the mask calculated earlier. When the selected flag is contained in the F.state field, the gadget shows itself in a white semi-translucent pattern. The attribute handling is also a standard code pattern:

		...
		ELSIF M IS Objects.AttrMsg THEN Attributes(F, M(Objects.AttrMsg))

with Attributes defined as:

	PROCEDURE Attributes (F: Frame; VAR M: Objects.AttrMsg);
	BEGIN
		IF M.id = Objects.get THEN	(* retrieve an attribute *)
			IF M.name = "Gen" THEN	(* generator attribute *)
				M.class := Objects.String;
				COPY("Skeleton.New", M.s);	(* must cite the generator procedure ! *)
				M.res := 0
			ELSIF M.name = "Color" THEN
				M.class := Objects.Int; M.i := F.col; M.res := 0
			ELSIF M.name = "Cmd" THEN
				Gadgets.framehandle(F, M);
				IF M.res < 0 THEN (* no such attribute, simulate empty string attribute *)
					M.class := Objects.String; M.s := ""; M.res := 0
				END
			ELSE Gadgets.framehandle(F, M)
			END
		ELSIF M.id = Objects.set THEN	(* set an attribute *)
			IF (M.name = "Color") & (M.class = Objects.Int) THEN
				F.col := SHORT(M.i); M.res := 0
			ELSE Gadgets.framehandle(F, M)
			END
		ELSIF M.id = Objects.enum THEN	(* To advertize attributes to Columbus *)
			M.Enum("Color"); M.Enum("Cmd");
			Gadgets.framehandle(F, M)
		END
	END Attributes;

It is mandatory to handle of the attribute classes and to set the res field correctly.

The code pieces above have been put together for inspection and for further experimentation in Skeleton.Mod. This module contains some further typical code patterns for handling mouse input and printing.

	MODULE Skeleton (*JM/ JG 26.7.94*);
	IMPORT Display, Display3, Effects, Files, Gadgets, Oberon, Objects, Printer, Printer3;
	CONST red = 1; middle = 1;

	TYPE
		Frame* = POINTER TO FrameDesc;
		FrameDesc* = RECORD (Gadgets.FrameDesc)
			col*: INTEGER
		END;

	(* To save memory we can use the framehandler to allocate the "Cmd" attribute
		only when one exists. We have however to simulate an attribute if
		none really exists (see the handling of "Cmd" in the "get" part below)
	*)
	PROCEDURE Attributes (F: Frame; VAR M: Objects.AttrMsg);
	BEGIN
		IF M.id = Objects.get THEN
			IF M.name = "Gen" THEN
				M.class := Objects.String; COPY("Skeleton.New", M.s); M.res := 0
			ELSIF M.name = "Color" THEN
				M.class := Objects.Int; M.i := F.col; M.res := 0
			ELSIF M.name = "Cmd" THEN
				Gadgets.framehandle(F, M);
				IF M.res < 0 THEN (* no such attribute, simulate one *)
					M.class := Objects.String; M.s := ""; M.res := 0
				END
			ELSE Gadgets.framehandle(F, M)
			END
		ELSIF M.id = Objects.set THEN
			IF (M.name = "Color") & (M.class = Objects.Int) THEN
				F.col := SHORT(M.i); M.res := 0
			ELSE Gadgets.framehandle(F, M)
			END
		ELSIF M.id = Objects.enum THEN
			M.Enum("Color"); M.Enum("Cmd"); Gadgets.framehandle(F, M)
		END
	END Attributes;

	PROCEDURE Restore (F: Frame; Q: Display3.Mask; x, y, w, h: INTEGER);
	BEGIN
		Display3.ReplConst(Q, F.col, x, y, w, h, Display.replace);
		IF Gadgets.selected IN F.state THEN
			Display3.FillPattern(Q, Display3.white, Display3.selectpat,
				x, y, x, y, w, h, Display.paint)
		END
	END Restore;

	PROCEDURE Print (F: Frame; VAR M: Display.DisplayMsg);
		VAR Q: Display3.Mask;

		PROCEDURE P (x: INTEGER): INTEGER;
		BEGIN RETURN SHORT(x * LONG(10000) DIV Printer.Unit)
		END P;

	BEGIN
		Gadgets.MakePrinterMask(F, M.x, M.y, M.dlink, Q);
		Printer3.ReplConst(Q, F.col, M.x, M.y, P(F.W), P(F.H), Display.replace)
	END Print;

	PROCEDURE Copy* (VAR M: Objects.CopyMsg; from, to: Frame);
	BEGIN to.col := from.col; Gadgets.CopyFrame(M, from, to)
	END Copy;

	PROCEDURE Handle* (F: Objects.Object; VAR M: Objects.ObjMsg);
		VAR x, y, w, h: INTEGER; F1: Frame; Q: Display3.Mask; keysum: SET;
	BEGIN
		WITH F: Frame DO
			IF M IS Display.FrameMsg THEN
				WITH M: Display.FrameMsg DO
					IF (M.F = NIL) OR (M.F = F) THEN (* message addressed to this frame *)
						x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H;
						IF M IS Display.DisplayMsg THEN
							WITH M: Display.DisplayMsg DO
								IF M.device = Display.screen THEN
									IF (M.id = Display.full) OR (M.F = NIL) THEN
										Gadgets.MakeMask(F, x, y, M.dlink, Q);
										Restore(F, Q, x, y, w, h)
									ELSIF M.id = Display.area THEN
										Gadgets.MakeMask(F, x, y, M.dlink, Q);
										Display3.AdjustMask(Q, x + M.u, y + h - 1 + M.v, M.w, M.h);
										Restore(F, Q, x, y, w, h)
									END
								ELSIF M.device = Display.printer THEN Print(F, M)
								END
							END
						ELSIF M IS Oberon.InputMsg THEN
							WITH M: Oberon.InputMsg DO
								IF (M.id = Oberon.track) & Gadgets.InActiveArea(F, M) &
									(M.keys = {middle}) THEN
									Gadgets.MakeMask(F, x, y, M.dlink, Q);
									Oberon.RemoveMarks(x, y, w, h);
									Display3.ReplConst(Q, Display3.FG, x, y, w, h, Display.invert);
									keysum := M.keys;
									REPEAT
										Effects.TrackMouse(M.keys, M.X, M.Y, Effects.PointHand);
										keysum := keysum + M.keys
									UNTIL M.keys = {};
									Oberon.RemoveMarks(x, y, w, h);
									Display3.ReplConst(Q, Display3.FG, x, y, w, h, Display.invert);
									IF keysum = {middle} THEN
										Gadgets.ExecuteAttr(F, "Cmd", M.dlink, NIL, NIL)
									END;
									M.res := 0
								ELSE Gadgets.framehandle(F, M)
								END
							END
						ELSE Gadgets.framehandle(F, M)
						END
					END
				END
			ELSIF M IS Objects.AttrMsg THEN Attributes(F, M(Objects.AttrMsg))
			ELSIF M IS Objects.CopyMsg THEN
				WITH M: Objects.CopyMsg DO
					IF M.stamp = F.stamp THEN M.obj := F.dlink (*non-first arrival*)
					ELSE (*first arrival*)
						NEW(F1); F.stamp := M.stamp; F.dlink := F1;
						Copy(M, F, F1); M.obj := F1
					END
				END
			ELSIF M IS Objects.FileMsg THEN
				WITH M: Objects.FileMsg DO
					IF M.id = Objects.store THEN Files.WriteInt(M.R, F.col)
					ELSIF M.id = Objects.load THEN Files.ReadInt(M.R, F.col)
					END;
					Gadgets.framehandle(F, M)
				END
			ELSE Gadgets.framehandle(F, M)
			END
		END
	END Handle;

	PROCEDURE Init* (F: Frame);
	BEGIN F.W := 50; F.H := 50; F.col := red; F.handle := Handle
	END Init;

	PROCEDURE New*;
		VAR F: Frame;
	BEGIN NEW(F); Init(F); Objects.NewObj := F
	END New;

	END Skeleton.

The printing primitives provided by the Printer3 module, a twin module of Display3, are used in the Print procedure.  The gadget mask calculated first by Gadgets.MakePrinterMask. Printer3 uses the same mask descriptors as Display3 but expects all coordinates to be specified in printer coordinates (often 300dpi).


5.11.6	The singleton design pattern

Both the visual and model gadgets of a user interface are stored in files on disk. The system allows you to open the same file many times and thus create multiple identical instances of the same gadgets. There are however cases where only one instance of a gadget is required, for example a gadget to store the time of day, or the sound track being played on an attached CD player. Such singleton gadgets are possible only in conjunction with model gadgets. In essence, each time the generator of a singleton gadget is called, the same gadget is returned.

	MODULE Timer;
	IMPORT BasicGadgets, Objects;

	VAR time: BasicGadgets.Integer;		(* can be of any type *)

	PROCEDURE Handler* (obj: Objects.Object; VAR M: Objects.ObjMsg);
	BEGIN
		IF M IS Objects.AttrMsg THEN
			WITH M: Objects.AttrMsg DO
				IF (M.id = Objects.get) & (M.name = "Gen") THEN
					M.class := Objects.String; COPY("Timer.NewTimer", M.s); M.res := 0
				ELSE BasicGadgets.IntegerHandler(obj, M)
				END
			END
		ELSIF M IS Objects.CopyMsg THEN
			WITH M: Objects.CopyMsg DO M.obj := time END
		ELSE BasicGadgets.IntegerHandler(obj, M)
		END
	END Handler;

	PROCEDURE NewTimer*;
	BEGIN (* return the only instance *)
		Objects.NewObj := time
	END NewTimer;

	BEGIN (* allocate gadget on loading *)
		NEW(time); BasicGadgets.InitInteger(time); time.handle := Handler
	END Timer.

Notice how much of the behavior is inherited, by class inheritance, from the BasicGadgets.Integer and how the same object is returned each time a CopyMsg is received.


5.11.7	The container gadget design pattern

Container gadgets contain other gadgets as descendants or children. Due to the dsc-next connection of descendants, a child can belong only to one parent. In comparison to elementary or "leaf" gadgets, containers have additional duties:

	1.	forwarding of unprocessed messages to descendants,
	2.	monitoring some of the messages sent to the descendants,
	3.	generating display masks for each descendant,
	4.	passing the correct display coordinates to descendants and
	5.	ensuring that the message thread from the display root to the
		descendants remains intact.

A container has full control over all its descendants. This means that when we ignore the messages sent directly to a gadget (normally those defined in the Objects module), all messages for descendants are delegated through the parent to the children, and the parent container has the right to pass through or even modify the messages. This is the consequence of filtering the message down from the display root in a hierarchical fashion to the containers and their descendants.
	The source code pieces used in the description are extracted from a complete Portraits module which appears at the end of this section. The module implements a container Portrait with a single component. When the gadget is instantiated, a Skeleton gadget is automatically installed as the component. The Skeleton acts as a sentinel indicating an empty Portrait. Another Skeleton may be dropped inside the Portrait, any number of times, to replace the contained Skeleton. Any visual gadget, including a transparent one, can also be dropped inside the container to replace the Skeleton, but only once. The component dropped inside or the sentinel Skeleton cannot be deleted, but either of them can be removed by moving it to another context. When this happens, a fresh sentinel Skeleton immediately fills the gap. This assumption allows the construction of a bare minimum solution requiring a source code text of reasonable size. 

The message handler of a typical container is structured as follows:

	PROCEDURE Handle* (F: Objects.Object; VAR M: Objects.ObjMsg);
      VAR x, y, w, h: INTEGER;
    BEGIN
		WITH F: Portrait DO
			IF M IS Display.FrameMsg THEN
				WITH M: Display.FrameMsg DO
					IF (M.F = NIL) OR (M.F = F) THEN (* message for this gadget *)
						x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H;

						(* test and handle the frame messages *)
					ELSE	(* message perhaps for content *)

						IF message for a child THEN
							... handle message for child
						ELSE ToContent(F, M.x + F.X, M.y + F.Y, M)
						END
					END
				END
			ELSIF M IS Objects.anyMsg THEN
				... handle object messages
			END
		END
	END Handle;

where "message for a child" determines if M.F (the message destination) is a child of F by traversing the dsc-next chain, and ToContent delegates the message to each child in turn as follows:

	(* x, y is the absolute display coordinates of the bottom-left corner of the container F *)
	PROCEDURE ToContent (F: Portrait; x, y: INTEGER; VAR M: Display.FrameMsg);
	VAR Mdlink, Fdlink: Objects.Object; tx, ty: INTEGER;
	BEGIN
	  tx := M.x; ty := M.y;	(* store old message origin *)
	  M.x := x; M.y := y + F.H - 1;	(* update message origin *)

	  F.dlink := M.dlink; M.dlink := F; F.dsc.handle(F.dsc, M);	(* store message thread data *)
	  F.dlink := M.dlink; M.dlink := F;	(* update the message thread *)

	  F.dsc.handle(F.dsc, M);	(* forward message *)

	  F.dlink := Fdlink; M.dlink := Mdlink;	(* restore message thread data *)
	  M.x := tx; M.y := ty	(* restore old message origin *)
	END ToContent;

The origin of the message must be changed before it is forwarded as a frame message travels through the display space. When ToContent is called, x and y contain the absolute coordinates of the bottom-left corner of the container but the coordinates of the top-left corner must be forwarded, hence the addition of the frame height to the current frame position.
	More efficient implementations are obtained by restructuring the handler, in particular by creating a special forwarding procedure to forward messages to all descendants. If this is not sufficient, the handling of the message thread can be removed. Although many steps are required to forward a message, this very seldom forms a bottleneck. More typically, bottlenecks are caused by the multitude of type tests required to determine the message type.
	A container must calculate the masks of its descendants from its own mask. The implementation for a container containing a single gadget is given here:

	(* Inform a gadget of its new mask *)
	PROCEDURE SetMask (F: Display.Frame; Q: Display3.Mask);
	VAR M: Display3.OverlapMsg;
	BEGIN
		M.M := Q; (* set mask *)
		M.x := 0; M.y := 0; M.F := F; M.dlink := NIL; M.res := -1;
			(* initialize rest of the message fields *)
		F.handle(F, M)
	END SetMask;

	PROCEDURE SetContentMask (F: Portrait);
	VAR Q: Display3.Mask;
	BEGIN
	  IF F.mask = NIL THEN	(* Portrait has no mask, so invalidate mask of the child *)
	  	SetMask(F.dsc, NIL)
	  ELSE
	  	Display3.Copy(F.mask, Q);	(* make a copy of the container's mask *)
	  	Q.x := 0; Q.y := 0;	(* reset the mask origin *)
	  	Display3.Intersect(Q, F.dsc.X, F.dsc.Y, F.dsc.W, F.dsc.H);
	  		(* intersect with the relative coordinates of the child *)

	  	Q.x := -F.dsc.X; Q.y := -(F.dsc.Y + F.dsc.H - 1);
	  		(* move the mask origin into the coordinate system of the child *)
	  	Display3.Shift(Q);
	  		(* and translate the mask by Q.x, Q.y into the coordinate system of the child *)
	  	SetMask(F.dsc, Q)
	  END
	END SetContentMask;

In the handler, we also have to check if the descendant requires a new mask:

	IF M IS Display3.UpdateMaskMsg THEN
		WITH M: Display3.UpdateMaskMsg DO
			IF M.F = F.dsc THEN SetContentMask(F)
			ELSE ToContent(F, M.x + F.X, M.y + F.Y, M)	(* don't forget to forward it *)
			END
		END

or if the container itself obtains a new mask:

	IF M IS Display3.OverlapMsg THEN
		WITH M: Display3.OverlapMsg DO
			F.mask := M.M; SetContentMask(F)
		END

Should a container be restored onto the display, the child must be displayed accordingly. Again for a single descendant, we have:

	PROCEDURE Restore
		(F: Portrait; Q: Display3.Mask; x, y, w, h: INTEGER; VAR M: Display.DisplayMsg);
	VAR N: Display.DisplayMsg;

		PROCEDURE ClipAgainst (VAR x, y, w, h: INTEGER; x1, y1, w1, h1: INTEGER);
		VAR r, t, r1, t1: INTEGER;
		BEGIN
			r := x + w - 1; r1 := x1 + w1 - 1; t := y + h - 1; t1 := y1 + h1 - 1;
			IF x < x1 THEN x := x1 END; IF y < y1 THEN y := y1 END;
			IF r > r1 THEN r := r1 END; IF t > t1 THEN t := t1 END;
			w := r - x + 1; h := t - y + 1;
		END ClipAgainst;

	BEGIN
		... restore the display areas belonging to F

		IF M.id = Display.area THEN 	(* only a rectangular area update *)
			N.F := F.dsc; N.u := M.u; N.v := M.v; N.w := M.w; N.h := M.h;
				(* in coordinate system of container *)
			ClipAgainst(N.u, N.v, N.w, N.h, F.dsc.X, F.dsc.Y, F.dsc.W, F.dsc.H);
				(* clip to child location *)
			DEC(N.u, border); INC(N.v, border)
				(* and translate to child coordinate system *)
		END;

		... restore the background before displaying a transparent gadget
		IF Gadgets.transparent IN F.dsc(Gadgets.Frame).state THEN
		Display3.ReplConst(Q, Display3.groupC, x + border, y + border,
		  w - 2*border, h - 2*border, Display.replace)
		END;
		.....
	  ToContent(F, x, y, N);

	   ... standard selection follows
	    IF Gadgets.selected IN F.state THEN ...
		    Display3.FillPattern(Q, Display3.white, Display3.selectpat, x, y, x, y, w, h,
		    Display.paint)
		END
	END Restore;

In the last two examples, a conversion of the coordinate system of the parent to that of the child takes place.

When a child is removed:

	PROCEDURE RemoveObj (obj: Display.Frame);
	VAR M: Display.ControlMsg;
	BEGIN M.id := Display.remove; M.F := obj; Display.Broadcast(M)
	END RemoveObj;

the handler must process the Display.ControlMsg:

	ELSIF M IS Display.ControlMsg THEN
		WITH M: Display.ControlMsg DO
			IF (M.id = Display.remove) & (M.F = F.dsc) THEN
				Skeleton.New; PutObj(F, Objects.NewObj(Display.Frame))
			ELSE ToContent(F, M.x + F.X, M.y + F.Y, M)
			END
		END

In this solution, removing the child can never realy succeed: a Sekeleton immediately takes its place. This is done on purpose to simplify the solution.

The handler must detect when a new child is inserted, removing the current child first. In the suggested solution, any visual gadget which is not a Skeleton will refuse to leave its place to another. This restriction can be lifted by omitting to test the condition F.dsc IS Skeleton.Frame. The correct coordinate handling is missing in the following code fragment:

	ELSIF M IS Display.ConsumeMsg THEN
		WITH M: Display.ConsumeMsg DO
			IF (M.id = Display.drop) & (M.F = F.dsc) & (F.dsc IS Skeleton.Frame) THEN
				RemoveObj(M.obj(Display.Frame));
                PutObj(F, M.obj(Display.Frame));
				M.res := 0
			ELSE ToContent(F, M.x + F.X, M.y + F.Y, M)
			END
		END

A container also has to handle the Display.LocateMsg that determines what is located at a certain position of the display:

	ELSIF M IS Display.LocateMsg THEN
		WITH M: Display.LocateMsg DO
			IF (M.loc = NIL) & Effects.Inside(M.X, M.Y, x, y, w, h) THEN
				ToContent(F, x, y, M);
				IF M.loc = NIL THEN	(* no descendant hit *)
				 	M.loc := F;
				 	M.u := M.X - x; M.v := M.Y - (y + h - 1);
				 		(* calculate the relative coordinates of the hit point *)
				 	M.res := 0
				END
			END
		END

The container may exercise parental control over mouse events signaled by an InputMsg. As soon as the mouse enters into the area a gadget (in this case a Skeleton) occupies on the screen, it starts to receive mouse events. It is completely up to the gadget to do whatever it pleases with these events. If the component simply delegates the handling of mouse events to the default handler Gadgets.framehandle and because that handler only processes MM key events, no response is given to MR and ML key events. In that case, the parent can take control of the mouse (here MR key events) or even prevent the mouse events from arriving at a child at all. A question arises out of this, namely who is responsible for handling certain events. In effect, a division of responsability is required; an example illustrates why this is necessary. When the user selects several gadgets in a container and wants to move them around as a whole, a single child does not know about the other selected gadgets and therefore the group editing operations are the responsability of the container and not of the children. A first approximation would be for the container not to let the selected child obtain mouse events and directly take control of editing. A more refined way is to have the child defer mouse operations under certain circumstances to the parent. This level of co-operation between parent and child gives the child some additional possibilities for controlling interactions.

          ELSIF M IS Oberon.InputMsg THEN
            WITH M: Oberon.InputMsg DO
              IF (M.id = Oberon.track) & ~(Gadgets.selected IN F.state) THEN
                IF Effects.Inside(M.X, M.Y, x + border, y + border,
                  w - 2*border, h - 2*border) THEN
                  ToContent(F, x, y, M);
                  (* Only the MM key is handled by the default handler. *)
                  IF (M.res < 0) & (M.keys = {0}) THEN
                    (* No response from child, container exercises parental control
                    of MR key events. *) 
                    TrackSelectChild(F, M, F.dsc)
                  END

Through the procedure TrackSelectChild, the container controls the selection and deselection of the component on recognizing simple MR key clicks. An MR + MM key interclick copies the component over to the caret as usual.

The other way to copy a gadget is by selecting it first and then to copy it to the caret with an ML + MM key interclick. This mouse action causes a Display.SelectMsg to be broadcast through the display space in order to get the most recent gadget selection. This message must also be processed by the handler which has the duty to inform the sender on the selection time of the component relatively to the other objects selected present in the display space. The selection of the component must be stored in a field of the container F.time in the first place. The second thing to do is to assign the current Oberon.Time() to this field when the component is selected (but not when it is selected and copied). There remains to the handler to decide whether the component was selected more recently than all other objects visited by the SelectMsg or not. 

          ELSIF M IS Display.SelectMsg THEN
            WITH M: Display.SelectMsg DO
              IF M.id = Display.get THEN
                ToContent(F, x, y, M);
                IF (F.time > M.time) & (Gadgets.selected IN F.dsc(Gadgets.Frame).state) THEN 
                  M.time := F.time; M.obj := F.dsc ; M.sel := F
                END
              ELSE Gadgets.framehandle(F, M)
              END
            END

When the child is selected, the user may want to clear all selections with the Esc key. In this case, an Oberon.ControlMsg with an id=neutralize is broadcast. Here is how the handler sends a reset request to the selected child:

          ELSIF M IS Oberon.ControlMsg THEN
            WITH M: Oberon.ControlMsg DO
              ToContent(F, x, y, M);
              IF M.id = Oberon.neutralize THEN
                IF Gadgets.selected IN F.dsc(Gadgets.Frame).state THEN
                SM.id := Display.reset; SM.F := F.dsc; SM.sel := F; SM.res := -1;
                F.dsc.handle(F.dsc, SM); Gadgets.Update(F.dsc)
                END
              END
            END

	In addition, a container has to intercept the Display.Modify message sent to its descendants, and update itself accordingly.
	As the whole process above is rather complicated to realize for containers with multiple descendants and all optimizations possible, the source text fragments have been written so that they can easily be extended with specific behavior. The NoteBook gadget is a container which may have any number of components or none at all. Seldom will you have to write new containers completely from scratch. Here follows the complete Portraits module text:

MODULE Portraits; (*JM/ JG 26.7.94*)
IMPORT Display, Display3, Effects, Gadgets, Oberon, Objects, Skeleton;
CONST border = 4;

TYPE
  Portrait = POINTER TO PortraitDesc;
  PortraitDesc = RECORD (Gadgets.FrameDesc)
    time*: LONGINT	(* time of selection *)
  END;

PROCEDURE SetMask (F: Display.Frame; Q: Display3.Mask);
VAR M: Display3.OverlapMsg;
BEGIN M.M := Q; M.x := 0; M.y := 0; M.F := F; M.dlink := NIL; M.res := -1;
  F.handle(F, M)
END SetMask;

PROCEDURE SetContentMask (F: Portrait);
  VAR Q: Display3.Mask;
BEGIN
  IF F.mask = NIL THEN SetMask(F.dsc, NIL)
  ELSE Display3.Copy(F.mask, Q); Q.x := 0; Q.y := 0;
    Display3.Intersect(Q, F.dsc.X, F.dsc.Y, F.dsc.W, F.dsc.H);
    Q.x := -F.dsc.X; Q.y := -(F.dsc.Y + F.dsc.H - 1); Display3.Shift(Q);
    SetMask(F.dsc, Q)
  END
END SetContentMask;

PROCEDURE ToContent (F: Portrait; x, y: INTEGER; VAR M: Display.FrameMsg);
  VAR Mdlink, Fdlink: Objects.Object; tx, ty: INTEGER;
BEGIN
  tx := M.x; ty := M.y;
  M.x := x; M.y := y + F.H - 1;
  Fdlink := F.dlink; Mdlink := M.dlink;
  F.dlink := M.dlink; M.dlink := F; F.dsc.handle(F.dsc, M);
  F.dlink := Fdlink; M.dlink := Mdlink;
  M.x := tx; M.y := ty
END ToContent;

PROCEDURE Modify (F: Portrait; VAR M: Display.ModifyMsg);
  VAR N: Display.ModifyMsg;
BEGIN
  N.id := Display.extend; N.F := F.dsc; N.mode := Display.state;
  N.X := border; N.Y := -M.H + 1 + border;
  N.W := M.W - 2 * border; N.H := M.H - 2 * border;
  N.dX := N.X - F.dsc.X; N.dY := N.Y - F.dsc.Y;
  N.dW := N.W - F.dsc.W; N.dH := N.H - F.dsc.H;
  N.x := 0; N.y := 0; N.res := -1; Objects.Stamp(N);
  F.dsc.handle(F.dsc, N);
  Gadgets.framehandle(F, M)
END Modify;

PROCEDURE ModifyContent (F: Portrait; VAR M: Display.ModifyMsg);
  VAR N: Display.ModifyMsg;
BEGIN
  IF M.stamp # F.stamp THEN F.stamp := M.stamp;
    N.id := Display.extend; N.F := F; N.mode := Display.display;
    N.X := F.X + M.dX; N.Y := F.Y + M.dY;
    N.W := M.W + 2 * border; N.H := M.H + 2 * border;
    N.dX := N.X - F.X; N.dY := N.Y - F.Y;
    N.dW := N.W - F.W; N.dH := N.H - F.H;
    Display.Broadcast(N)
  END
END ModifyContent;

PROCEDURE Restore (F: Portrait; Q: Display3.Mask; x, y, w, h: INTEGER; VAR M: Display.DisplayMsg);
  VAR N: Display.DisplayMsg;

  PROCEDURE ClipAgainst (VAR x, y, w, h: INTEGER; x1, y1, w1, h1: INTEGER);
    VAR r, t, r1, t1: INTEGER;
  BEGIN
    r := x + w - 1; r1 := x1 + w1 - 1; t := y + h - 1; t1 := y1 + h1 - 1;
    IF x < x1 THEN x := x1 END; IF y < y1 THEN y := y1 END;
    IF r > r1 THEN r := r1 END; IF t > t1 THEN t := t1 END;
    w := r - x + 1; h := t - y + 1;
  END ClipAgainst;

BEGIN
  Display3.Rect3D(Q, Display3.topC, Display3.bottomC, x, y, w, h, 1, Display.replace);
  Display3.Rect(Q, Display3.groupC, Display.solid, x + 1, y + 1, w - 2, h - 2, border - 2,
    Display.replace);
  Display3.Rect3D(Q, Display3.bottomC, Display3.topC,
    x + border - 1, y + border - 1, w - (border - 1) * 2, h - (border - 1) * 2, 1,
    Display.replace);
  IF M.id = Display.area THEN
    N.F := F.dsc; N.u := M.u; N.v := M.v; N.w := M.w; N.h := M.h;
    ClipAgainst(N.u, N.v, N.w, N.h, F.dsc.X, F.dsc.Y, F.dsc.W, F.dsc.H);
    DEC(N.u, border); INC(N.v, border)
  END;
  IF Gadgets.transparent IN F.dsc(Gadgets.Frame).state THEN
  	Display3.ReplConst(Q, Display3.groupC, x + border, y + border,
  	  w - 2*border, h - 2*border, Display.replace)
  END;
  N.device := M.device; N.id := M.id; N.F := F.dsc; N.dlink := M.dlink; N.res := -1;
  Objects.Stamp(N); ToContent(F, x, y, N);
  IF Gadgets.selected IN F.state THEN
    Display3.FillPattern(Q, Display3.white, Display3.selectpat, x, y, x, y, w, h,
    Display.paint)
  END
END Restore;

PROCEDURE Copy* (VAR M: Objects.CopyMsg; from, to: Portrait);
  VAR N: Objects.CopyMsg;
BEGIN
  Gadgets.CopyFrame(M, from, to);
  N.id := Objects.shallow; Objects.Stamp(N);
  from.dsc.handle(from.dsc, N); to.dsc := N.obj(Gadgets.Frame)
END Copy;

PROCEDURE Attributes (F: Portrait; VAR M: Objects.AttrMsg);
BEGIN
  IF (M.id = Objects.get) & (M.name = "Gen") THEN
    M.s := "Portraits.New"; M.class := Objects.String; M.res := 0
  ELSE Gadgets.framehandle(F, M)
  END
END Attributes;

PROCEDURE RemoveObj (obj: Display.Frame);
  VAR M: Display.ControlMsg;
BEGIN M.id := Display.remove; M.F := obj; Display.Broadcast(M)
END RemoveObj;

PROCEDURE PutObj (F: Portrait; obj: Display.Frame);
  VAR M: Display.ModifyMsg;
BEGIN
  F.dsc := obj; SetMask(F.dsc, NIL);
  M.id := Display.extend; M.mode := Display.display; M.F := F;
  M.X := F.X; M.Y := F.Y;
  M.W := F.dsc.W + border * 2; M.H := F.dsc.H + border * 2;
  M.dX := M.X - F.X; M.dY := M.Y - F.Y;
  M.dW := M.W - F.W; M.dH := M.H - F.H;
  Display.Broadcast(M)
END PutObj;

PROCEDURE TrackSelectChild (F: Portrait; VAR M: Oberon.InputMsg; child: Display.Frame);
VAR S: Display.SelectMsg; keysum: SET; C: Objects.CopyMsg;
BEGIN
	IF Gadgets.selected IN child(Gadgets.Frame).state THEN S.id := Display.reset
	ELSE S.id := Display.set
	END;
	S.F := child; S.sel := F; S.res := -1; Display.Broadcast(S);
	Gadgets.Update(child);
	keysum := {};
	REPEAT
		Effects.TrackMouse(M.keys, M.X, M.Y, Effects.Arrow); keysum := keysum + M.keys;
	UNTIL M.keys = {};
	IF (keysum = {0, 1}) & (S.id = Display.set) THEN  (* MR copy to focus *)
		Objects.Stamp(C);
		C.id := Objects.shallow; C.obj := NIL; child.handle(child, C);
		IF C.obj # NIL THEN Gadgets.Integrate(C.obj) END
	ELSE F.time := Oberon.Time()
	END;
	M.res := 0
END TrackSelectChild;

PROCEDURE Handle* (F: Objects.Object; VAR M: Objects.ObjMsg);
  VAR x, y, w, h: INTEGER; F1: Portrait; Q: Display3.Mask; obj: Objects.Object;
  	SM: Display.SelectMsg;
BEGIN
  WITH F: Portrait DO
    IF M IS Display.FrameMsg THEN
      WITH M: Display.FrameMsg DO
        IF (M.F = NIL) OR (M.F = F) THEN
          x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H;
          IF M IS Display.DisplayMsg THEN
            WITH M: Display.DisplayMsg DO
              IF M.device = Display.screen THEN
                IF (M.id = Display.full) OR (M.F = NIL) THEN
                  Gadgets.MakeMask(F, x, y, M.dlink, Q);
                  Restore(F, Q, x, y, w, h, M)
                ELSIF M.id = Display.area THEN
                  Gadgets.MakeMask(F, x, y, M.dlink, Q);
                  Display3.AdjustMask(Q, x + M.u, y + h - 1 + M.v, M.w, M.h);
                  Restore(F, Q, x, y, w, h, M)
                END
              ELSIF M.device = Display.printer THEN
              END
            END
          ELSIF M IS Oberon.InputMsg THEN
            WITH M: Oberon.InputMsg DO
              IF (M.id = Oberon.track) & ~(Gadgets.selected IN F.state) THEN
                IF Effects.Inside(M.X, M.Y, x + border, y + border,
                  w - 2*border, h - 2*border) THEN
                  ToContent(F, x, y, M);
                  (* If child does not respond, the container may exercise parental control
                    of mouse events. In this case, of MR key events.  *)
                  IF (M.res < 0) & (M.keys = {0}) THEN
                    TrackSelectChild(F, M, F.dsc)
                  END
                ELSE Gadgets.framehandle(F, M)
                END
              ELSE Gadgets.framehandle(F, M)
              END
            END
          ELSIF M IS Oberon.ControlMsg THEN
            WITH M: Oberon.ControlMsg DO
              ToContent(F, x, y, M);
              IF M.id = Oberon.neutralize THEN
                IF Gadgets.selected IN F.dsc(Gadgets.Frame).state THEN
                SM.id := Display.reset; SM.F := F.dsc; SM.sel := F; SM.res := -1;
                F.dsc.handle(F.dsc, SM); Gadgets.Update(F.dsc)
                END
              END
            END
          ELSIF M IS Display.ModifyMsg THEN Modify(F, M(Display.ModifyMsg))
          ELSIF M IS Display.LocateMsg THEN
            WITH M: Display.LocateMsg DO
              IF (M.loc = NIL) & Effects.Inside(M.X, M.Y, x, y, w, h) THEN
                ToContent(F, x, y, M);
                IF M.loc = NIL THEN
                  M.loc := F; M.u := M.X - x; M.v := M.Y - (y + h - 1); M.res := 0
                END
              END
            END
          ELSIF M IS Display3.OverlapMsg THEN
            WITH M: Display3.OverlapMsg DO
              F.mask := M.M; SetContentMask(F)
            END
          ELSIF M IS Display.SelectMsg THEN
            WITH M: Display.SelectMsg DO
              IF M.id = Display.get THEN
                ToContent(F, x, y, M);
                IF (F.time > M.time) & (Gadgets.selected IN F.dsc(Gadgets.Frame).state) THEN 
                  M.time := F.time; M.obj := F.dsc ; M.sel := F
                END
              ELSE Gadgets.framehandle(F, M)
              END
            END
          ELSIF M.F # NIL THEN Gadgets.framehandle(F, M)
          ELSE ToContent(F, x, y, M)
          END
        ELSE (* message perhaps for content *)
          IF M IS Display3.UpdateMaskMsg THEN
            WITH M: Display3.UpdateMaskMsg DO
              IF M.F = F.dsc THEN SetContentMask(F)
              ELSE ToContent(F, M.x + F.X, M.y + F.Y, M)
              END
            END
          ELSIF M IS Display.ControlMsg THEN
            WITH M: Display.ControlMsg DO
              IF (M.id = Display.remove) & (M.F = F.dsc) THEN
                Skeleton.New; PutObj(F, Objects.NewObj(Display.Frame))
              ELSE ToContent(F, M.x + F.X, M.y + F.Y, M)
              END
            END
          ELSIF M IS Display.ModifyMsg THEN
            IF M.F = F.dsc THEN ModifyContent(F, M(Display.ModifyMsg))
            ELSE ToContent(F, M.x + F.X, M.y + F.Y, M)
            END
          ELSIF M IS Display.ConsumeMsg THEN
            WITH M: Display.ConsumeMsg DO
              IF (M.id = Display.drop) & (M.F = F.dsc) & (F.dsc IS Skeleton.Frame) THEN
                RemoveObj(M.obj(Display.Frame));
                PutObj(F, M.obj(Display.Frame));
                M.res := 0
              ELSE ToContent(F, M.x + F.X, M.y + F.Y, M)
              END
            END
          ELSE ToContent(F, M.x + F.X, M.y + F.Y, M)
          END
        END
      END
    ELSIF M IS Objects.AttrMsg THEN Attributes(F, M(Objects.AttrMsg))
    ELSIF M IS Objects.BindMsg THEN
      F.dsc.handle(F.dsc, M); Gadgets.framehandle(F, M)
    ELSIF M IS Objects.CopyMsg THEN
      WITH M: Objects.CopyMsg DO
        IF M.stamp = F.stamp THEN M.obj := F.dlink (*non-first arrival*)
        ELSE (*first arrival*)
          NEW(F1); F.stamp := M.stamp; F.dlink := F1; Copy(M, F, F1); M.obj := F1
        END
      END
    ELSIF M IS Objects.FileMsg THEN
      WITH M: Objects.FileMsg DO
        IF M.id = Objects.store THEN
          Gadgets.WriteRef(M.R, F.lib, F.dsc)
        ELSIF M.id = Objects.load THEN
          Gadgets.ReadRef(M.R, F.lib, obj);
          IF (obj # NIL) & (obj IS Gadgets.Frame) THEN F.dsc := obj(Gadgets.Frame)
          ELSE Skeleton.New; F.dsc := Objects.NewObj(Gadgets.Frame)
          END
        END;
        Gadgets.framehandle(F, M)
      END
    ELSE Gadgets.framehandle(F, M)
    END
  END
END Handle;

PROCEDURE New*;
  VAR F: Portrait;
BEGIN
  NEW(F); F.handle := Handle; F.W := 50; F.H := 50;
  Skeleton.New; F.dsc := Objects.NewObj(Display.Frame);
  Objects.NewObj := F
END New;

END Portraits.


5.11.8	The document design pattern

A document is a container gadget with a single descendant. A TextDoc contains a TextGadget, a PanelDoc contains a Panel, a RembrandtDoc contains a RembrandtFrame etc. The document gadget provides a file name, a storage mechanism, an icon, and has the capability of generating a menu bar. Programming a new document normally involves class inheritance, that is, the document handler is exchanged and no type extension is made. A document has a generator procedure to generate an empty instance of that document type. In addition, two methods for loading and storing, implement the persistency mechanism. These two methods should not be confused with the FileMsg, which in this case stores nothing more than the document name, an attribute of the document.
	A document can either be stored locally on disk, be present on remote machines, or be generated on the fly at load time. Locally stored documents often use the newer Oberon document format, which prepends a standard header to the document file:

	0F7X  7X  "Generator string"  X Y W H   (document content follows)

	This header contains the generator of the loading document instance. The X Y W H fields are used for determining a preferred position and size on the display, and can be copied to the document coordinates. This is visible in the Load and Store methods defined below.
	Compatibility with documents in the existing document formats is obtained by defining a lookup table consisting of (generator, file extension) pairs. Remote documents are identified using uniform resource locators (URL) known from the world-wide web. The appropriate document generators are defined in a lookup table consisting of (generator, URL format) pairs, where URL format is "http", "ftp" etc. The tables of (generator, file extension) and (generator, URL format) pairs are managed by the Documents module. For testing purposes, the tables can be extended by adding entries to the file Oberon.Text for Native Oberon or to the Registry for the other Oberon implementations. This file is parsed once the Documents module is loaded.
	The DocumentSkeleton module implements a trivial example of document containing a Panel, only the color of which is stored. The meaning of the piece of code in bold typeface is explained later.

	MODULE DocumentSkeleton; (* jm 25.10.93 *)
	IMPORT Attributes, Desktops, Display, Documents, Files, Gadgets,
					Links, Oberon, Objects, Texts, ColorDriver;
	CONST Menu = "Desktops.StoreDoc[Store] DocumentSkeleton.Cycle[Cycle]";

	VAR W: Texts.Writer;

	PROCEDURE Cycle*;
		VAR doc: Documents.Document; F: Gadgets.Frame; col: LONGINT;
	BEGIN
		doc := Desktops.CurDoc(Gadgets.context);
		IF (doc # NIL) & (doc.dsc IS Gadgets.Frame) THEN
			F := doc.dsc(Gadgets.Frame);
			Attributes.GetInt(F, "Color", col);
			Attributes.SetInt(F, "Color", (col + 1) MOD 4);
			Gadgets.Update(F)
		END
	END Cycle;

	PROCEDURE NextColor (doc: Documents.Document; col: INTEGER);
		VAR F: Gadgets.Frame;
	BEGIN
		F := doc.dsc(Gadgets.Frame);
		Attributes.SetInt(F, "Color", col);
		Gadgets.Update(F)
	END NextColor;

	PROCEDURE Load (D: Documents.Document);
		VAR
		obj: Objects.Object;
		tag, x, y, w, h, col: INTEGER;
		name: ARRAY 64 OF CHAR; F: Files.File; R: Files.Rider; ch: CHAR;
		CM: Gadgets.CmdMsg;
	BEGIN
		obj := Gadgets.CreateObject("Panels.NewPanel");
		WITH obj: Gadgets.Frame DO
			x := 0; y := 0; w := 250; h := 200; col := 1; (* default *)

			F := Files.Old(D.name);
			IF F # NIL THEN
				Files.Set(R, F, 0);
				Files.ReadInt(R, tag);
				IF tag = Documents.Id THEN
					Files.ReadString(R, name);
					Files.ReadInt(R, x); Files.ReadInt(R, y); Files.ReadInt(R, w); Files.ReadInt(R, h);

					Files.Read(R, ch);
					IF ch # 0F7X THEN (* attachments *)
						Documents.LoadAttachments(R, D.attr, D.link);
						IF D.link # NIL THEN
							CM.cmd := "PREPARE"; CM.res := -1; CM.dlink := D; Objects.Stamp(CM);
							Links.Broadcast(D.link, CM)
						END;
						Files.ReadInt(R, col)
					END
				END
			ELSE (* COPY("DefaultName", D.name) *)
			END;
			D.X := x; D.Y := y; D.W := w; D.H := h;
			Attributes.SetInt(obj, "Color", col);
			Documents.Init(D, obj)
		END
	END Load;

	PROCEDURE Store (D: Documents.Document);
		VAR obj: Gadgets.Frame; F: Files.File; R: Files.Rider; col: LONGINT;
	BEGIN
		obj := D.dsc(Gadgets.Frame);
		Texts.WriteString(W, "Store "); Texts.Append(Oberon.Log, W.buf);
		IF D.name # "" THEN
			F := Files.New(D.name);
			IF F = NIL THEN HALT(99) END;

			Files.Set(R, F, 0);
			Files.WriteInt(R, Documents.Id); Files.WriteString(R, "DocumentSkeleton.NewDoc");
			Files.WriteInt(R, D.X); Files.WriteInt(R, D.Y);
			Files.WriteInt(R, D.W); Files.WriteInt(R, D.H);

			IF (D.attr # NIL) OR (D.link # NIL) THEN (* attachments *)
				Documents.StoreAttachments(R, D.attr, D.link)
			END;
			Attributes.GetInt(obj, "Color", col);
			Files.WriteInt(R, SHORT(col));
			Files.Register(F);
			Texts.Write(W, 22X); Texts.WriteString(W, D.name); Texts.Write(W, 22X)
		ELSE Texts.WriteString(W, "[Untitled document]")
		END;
		Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
	END Store;

	PROCEDURE Handler (D: Objects.Object; VAR M: Objects.ObjMsg);
	BEGIN
		WITH D: Documents.Document DO
			IF M IS Objects.AttrMsg THEN
				WITH M: Objects.AttrMsg DO
					IF M.id = Objects.get THEN
						IF M.name = "Gen" THEN
							M.class := Objects.String; M.s := "DocumentSkeleton.NewDoc"; M.res := 0
						ELSIF M.name = "Adaptive" THEN
							M.class := Objects.Bool; M.b := FALSE; M.res := 0
						ELSIF M.name = "Icon" THEN
							M.class := Objects.String; M.s := "Icons.Tool"; M.res := 0
						ELSE Documents.Handler(D, M)
						END
					ELSE Documents.Handler(D, M)
					END
				END
			ELSIF M IS Objects.LinkMsg THEN
				WITH M: Objects.LinkMsg DO
					IF (M.id = Objects.get) & (M.name = "DeskMenu") THEN
						M.obj := Gadgets.CopyPublicObject("TestMenus.DeskMenu", TRUE);
						IF M.obj = NIL THEN M.obj := Desktops.NewMenu(Menu) END;
						M.res := 0
					ELSIF (M.id = Objects.get) & (M.name = "SystemMenu") THEN
						M.obj := Gadgets.CopyPublicObject("TestMenus.DeskMenu", TRUE);
						IF M.obj = NIL THEN M.obj := Desktops.NewMenu(Menu) END;
						M.res := 0
					ELSIF (M.id = Objects.get) & (M.name = "UserMenu") THEN
						M.obj := Gadgets.CopyPublicObject("TestMenus.DeskMenu", TRUE);
						IF M.obj = NIL THEN M.obj := Desktops.NewMenu(Menu) END;
						M.res := 0
					ELSE Documents.Handler(D, M)
					END
				END
			ELSIF M IS ColorDriver.ColorMsg THEN
				NextColor(D, M(ColorDriver.ColorMsg).col)
			ELSIF M IS Display.DisplayMsg THEN
				WITH M: Display.DisplayMsg DO
					IF (M.device = Display.printer) & (M.id = Display.contents) & (D.dsc # NIL) THEN
						(* print *)
					ELSE Documents.Handler(D, M)
					END
				END
			ELSE Documents.Handler(D, M)
			END
		END
	END Handler;

	PROCEDURE NewDoc*;
		VAR D: Documents.Document;
	BEGIN
		NEW(D); D.Load := Load; D.Store := Store; D.handle := Handler;
		D.W := 250; D.H := 200; Objects.NewObj := D
	END NewDoc;

	BEGIN Texts.OpenWriter(W)
	END DocumentSkeleton.

Desktops.OpenDoc (DocumentSkeleton.NewDoc)

The generator procedure generates an empty instance of Documents.Document and installs the load and store methods and the handler which are all typical in document modules. The document possesses two "read-only" attributes Adaptive and Icon. The Adaptive attribute set to FALSE in the present case indicates that a fixed size camera-view of the document will be presented. When the value TRUE is returned, the document will adapt its size to that of the viewer. Also when the viewer is resized, the document is resized. Normally, a TextDoc or a LogDoc are adaptive, whereas a PanelDoc or a Columbus document are not adaptive. The Icon attribute indicates what public object should be regarded as its pictorial icon representation. The document should return a string attribute in the form L.O, where L identifies the public library, and O the object in that library. The gadget identified this way is then packed by the desktop inside an Icon gadget in a Finder gadget or when Desktops.MakeIcon command is executed.
	Each document requires a menu bar with commands associated with the document type when opened with Desktops.OpenDoc. This menu bar is gathered from the links "DeskMenu", "SystemMenu" and "UserMenu" when the command is executed. The menu can be constructed with the procedure Dekstops.NewMenu or can be taken from a public library. The string given as parameter in the procedure must contain a sequence of Oberon commands. By immediately following a menu command with a word in square brackets, that word will be used as the menu bar button caption. A typical menu string might look as follows:

	"MyDoc.Search[Search] MyDoc.Save[Store]"

In the example given, the menu string appears in the Menu constant and that menu is indeed used as long as no TestMenus public library exists. The Desktops.NewMenu procedure automatically adds the Buttons [Close], [Hide] and [Grow] and a NamePlate to the menu bar.
	For more flexibility, documents may also define their own menu bars by "exporting" them as public objects from a public library. The public library should contain three menu bars for the Desktop, System track and User track respectively. These menus should have the names "DeskMenu", "SystemMenu" and "UserMenu" respectively. For example, the text documents have such a library (called "TextDocs.Lib"). When the library is missing, the default menu bars are used. Programmers must add support for this feature in their Document handlers. The desktop uses the LinkMsg to request the document to return its menu bar. You should always return a deep copy of the menu bar from the library. It is best to lock the menu bars and to set the Panel's Border attribute to 0. The menu bar can have any height and content.
	The example document supports attachments, a concept which has been introduced and used earlier in this chapter.


5.11.9	Defining a new message type

Up to now we have been exploiting the message collection belonging to the standard Oberon distribution. Creating an ad-hoc message was listed among the implementation steps for a new gadget. The following ColorDriver introduces a new message type ColorMsg and provides the capability to change the color of all the open documents having DocumentSkeleton.NewDoc as generator. To this effect the handler must be capable of interpreting the message: the program modifications appear in bold typeface in the source text of DocumentSkeleton.

	MODULE ColorDriver;
	IMPORT Display;
	TYPE
		ColorMsg* = RECORD (Display.FrameMsg)
			col*: INTEGER
		END;
	VAR Color: INTEGER;

	PROCEDURE NextCol*;
	VAR M: ColorMsg;
	BEGIN
		Color := (Color + 1) MOD 4;
		M.F := NIL; M.col := Color; Display.Broadcast(M)
	END NextCol;

	BEGIN Color := 1
	END ColorDriver.NextCol

The color could also be controlled by a background task by replacing the ColorDriver module by:

	MODULE ColorDriver;
	IMPORT Display, Input, Modules, Oberon;
	TYPE
		ColorMsg* = RECORD (Display.FrameMsg)
			col*: INTEGER
		END;
	VAR Color: INTEGER; task : Oberon.Task;

	PROCEDURE ColorTask(me: Oberon.Task);
	VAR M: ColorMsg;
	BEGIN
		Color := (Color + 1) MOD 4;
		M.F := NIL; M.col := Color; Display.Broadcast(M);
		me.time := Input.Time() + Input.TimeUnit * 3
	END ColorTask;

	PROCEDURE Cleanup;
	BEGIN
		Oberon.Remove(task)
	END Cleanup;

	BEGIN
		Color := 1;
		NEW(task); task.handle := ColorTask; task.safe := TRUE; Oberon.Install(task);
		Modules.InstallTermHandler(Cleanup)
	END ColorDriver.

The background task is immediately activated when a document is opened, because this module is imported and thus automatically loaded. This example also shows how the task can be correctly removed (Cleanup) when a command System.Free ColorDriver is executed.


5.11.10	The camera view design pattern

Camera views are programmed in practically the same way as container gadgets. Here only the differences will be sketched. Camera views have to be type extensions of Gadgets.View and should preferably reference their contents through the obj field in Gadgets.Frame instead of the dsc field typically used for containers. The extension of Gadgets.View is required so that the display masks of the camera view descendants are calculated correctly. For the same reason a special message forwarding strategy, encapsulated in the Gadgets module, has to be used:

	PROCEDURE ToModel(F: Frame; x, y: INTEGER; VAR M: Display.FrameMsg);
		VAR obj: Display.Frame;
	BEGIN
		IF (F.obj # NIL) & (F.obj IS Display.Frame) THEN
			obj := F.obj(Display.Frame);
			M.x := ... ; M.y := ...;
			Gadgets.Send(F, x, y, obj, M)
		END
	END ToModel;

The mask handling for the camera view content can be simplified by not taking the camera view mask into account when updating the mask of the content. Instead, the camera view should create a mask for the content in such a way that the content is completely visible. The Gadgets.MakeMask procedure automatically clips the mask of a gadget to the masks of the camera views through which it is visible.
	An example of a simple camera view gadget can be found in the ViewSkeleton module.

	MODULE ViewSkeleton;	(* jt, 13.12.94 *)
	IMPORT Display, Display3, Fonts, Gadgets, Oberon, Objects;
	TYPE
		Frame* = POINTER TO FrameDesc;
		FrameDesc* = RECORD (Gadgets.ViewDesc)
			(* view is adjusted to model size, no border *)
		END;

	PROCEDURE ToModel (F: Frame; x, y: INTEGER; VAR M: Display.FrameMsg);
		VAR obj: Display.Frame;
	BEGIN
		IF (F.obj # NIL) & (F.obj IS Display.Frame) THEN
			obj := F.obj(Display.Frame);
			M.x := x - obj.X; M.y := y + F.H - (obj.Y + obj.H);
			Gadgets.Send(F, x, y, obj, M)
		END
	END ToModel;

	PROCEDURE Restore (F: Frame; x, y: INTEGER; dlink: Objects.Object);
		VAR R: Display3.Mask; M: Display.DisplayMsg;
	BEGIN
		Gadgets.MakeMask(F, x, y, dlink, R);	(* simplified *)
		IF F.obj = NIL THEN
			Display3.ReplConst(R, Display3.green, x, y, F.W, F.H, Display.replace);
			Display3.String(R, Display3.FG, x + 3, y + 3, Fonts.Default,
								"empty view", Display3.replace)
		ELSE
			M.device := Display.screen; M.id := Display.full; M.F := NIL;
			M.dlink := dlink; M.res := -1; ToModel(F, x, y, M)
		END ;
		IF Gadgets.selected IN F.state THEN
			Display3.FillPattern(R, Display3.blue, Display3.selectpat,
								x, y, x, y, F.W, F.H, Display3.paint)
		END
	END Restore;

	PROCEDURE Adjust (F: Frame; X, Y, W, H: INTEGER);
		VAR MM: Display.ModifyMsg;
	BEGIN
		MM.F := F; MM.mode := Display.display;
		MM.dX := X - F.X; MM.dY := Y - F.Y; MM.dW := W - F.W; MM.dH := H - F.H;
		MM.X := X; MM.Y := Y; MM.W := W; MM.H := H;
		Display.Broadcast(MM)
	END Adjust;

	PROCEDURE Consume (F: Frame; x, y: INTEGER; VAR M: Display.ConsumeMsg);
		VAR f: Objects.Object; CM: Display.ControlMsg;
	BEGIN f := M.obj;
		IF (M.id = Display.drop) & (M.F = F) & (F.obj = NIL) & (f IS Gadgets.Frame) THEN
			WITH f: Gadgets.Frame DO
				f.slink := NIL;
				CM.id := Display.remove; CM.F := f; Display.Broadcast(CM);
				F.obj := f; f.X := 0; f.Y := 0; f.mask := NIL;
				F.state := f.state*{Gadgets.transparent};
				Adjust(F, F.X + M.u, F.Y + F.H - 1 + M.v, f.W, f.H); M.res := 0
			END
		ELSE ToModel(F, x, y, M)
		END;
	END Consume;

	PROCEDURE UpdateMask (F: Frame; x, y: INTEGER; VAR M: Display3.UpdateMaskMsg);
		VAR R: Display3.Mask; O: Display3.OverlapMsg;
	BEGIN
		IF M.F = F.obj THEN
			NEW(R); Display3.Open(R);
			Display3.Add(R, 0, -F.obj(Display.Frame).H+1,
								F.obj(Display.Frame).W, F.obj(Display.Frame).H);
			O.F := F.obj(Display.Frame); O.x := 0; O.y := 0; O.M := R; O.res := -1;
			O.dlink := NIL; ToModel(F, x, y, O); M.res := 0
		ELSIF M.F = F THEN
			NEW(F.mask); Display3.Open(F.mask);
			Display3.Add(F.mask, 0, -F.H+1, F.W, F.H);
			F.mask.x := 0; F.mask.y := 0
		ELSE ToModel(F, x, y, M)
		END
	END UpdateMask;

	PROCEDURE FrameHandler* (F: Objects.Object; VAR M: Objects.ObjMsg);
		VAR x, y, u, v: INTEGER; F0: Frame;
	BEGIN
		WITH F: Frame DO
			IF M IS Objects.AttrMsg THEN
				WITH M: Objects.AttrMsg DO
					IF (M.id = Objects.get) & (M.name = "Gen") THEN
						M.s := "ViewSkeleton.NewFrame"; M.class := Objects.String; M.res := 0
					ELSE Gadgets.framehandle(F, M)
					END
				END
			ELSIF M IS Objects.CopyMsg THEN
				WITH M: Objects.CopyMsg DO
					IF M.stamp = F.stamp THEN M.obj := F.dlink
					ELSE
						NEW(F0); F.stamp := M.stamp; F.dlink := F0;
						Gadgets.CopyFrame(M, F, F0); F0.border := F.border; M.obj := F0
					END
				END
			ELSIF M IS Objects.FileMsg THEN Gadgets.framehandle(F, M)
			ELSIF M IS Objects.BindMsg THEN Gadgets.framehandle(F, M)
			ELSIF M IS Objects.LinkMsg THEN Gadgets.framehandle(F, M)
			ELSIF M IS Objects.FindMsg THEN Gadgets.framehandle(F, M)
			ELSIF M IS Display.FrameMsg THEN
				WITH M: Display.FrameMsg DO
					x := M.x + F.X; y := M.y + F.Y;
					u := M.x; v := M.y; (* save *)
					IF M IS Display.DisplayMsg THEN
						WITH M: Display.DisplayMsg DO
							IF M.device = Display.screen THEN
								IF (M.F = NIL) OR (M.F = F) THEN Restore(F, x, y, M.dlink)
								ELSE ToModel(F, x, y, M)
								END
							ELSIF M.device = Display.printer THEN
							END
						END
					ELSIF M IS Display.ConsumeMsg THEN
						Consume(F, x, y, M(Display.ConsumeMsg))
					ELSIF M IS Gadgets.UpdateMsg THEN
						WITH M: Gadgets.UpdateMsg DO
							IF M.obj = F.obj THEN Restore(F, x, y, M.dlink)
							ELSE ToModel(F, x, y, M)
							END
						END
					ELSIF M IS Oberon.InputMsg THEN
						WITH M: Oberon.InputMsg DO
							IF F.obj # NIL THEN ToModel(F, x, y, M)
							ELSE Gadgets.framehandle(F, M)
							END
						END
					ELSIF M IS Oberon.ControlMsg THEN ToModel(F, x, y, M)
					ELSIF M IS Display.LocateMsg THEN Gadgets.framehandle(F, M)
					ELSIF M IS Display.SelectMsg THEN
						Gadgets.framehandle(F, M) (* should be more elaborate *)
					ELSIF M IS Display.ModifyMsg THEN
						WITH M: Display.ModifyMsg DO
							IF M.F = F THEN Gadgets.framehandle(F, M)
							ELSIF M.F = F.obj THEN
								ToModel(F, x, y, M); Adjust(F, F.X + M.dX, F.Y + M.dY, M.W, M.H)
							ELSE ToModel(F, x, y, M)
							END
						END
					ELSIF M IS Display.ControlMsg THEN
						IF (M(Display.ControlMsg).id = Display.remove) & (M.F = F.obj) THEN
							F.obj := NIL; Gadgets.Update(F)
						END
					ELSIF M IS Display3.OverlapMsg THEN Gadgets.framehandle(F, M);
					ELSIF M IS Display3.UpdateMaskMsg THEN
						UpdateMask(F, x, y, M(Display3.UpdateMaskMsg))
					ELSE ToModel(F, x, y, M)
					END;
					M.x := u; M.y := v (* restore *)
				END
			ELSIF F.obj # NIL THEN F.obj.handle(F.obj, M)
			END
		END
	END FrameHandler;

	PROCEDURE InitFrame* (F: Frame);
	BEGIN F.W := 100; F.H := 100; F.border := 0; F.handle := FrameHandler
	END InitFrame;

	PROCEDURE NewFrame*;
		VAR F: Frame;
	BEGIN NEW(F); InitFrame(F); Objects.NewObj := F;
	END NewFrame;

	END ViewSkeleton.

	Gadgets.Insert ViewSkeleton.NewFrame ~


5.11.11	Further perspectives

This concludes our discussion of gadgets programming. The code of the examples presented is included in the Oberon release:

	- Skeleton.Mod: a simple visual gadget
	- Portraits.Mod: a simple container gadget
	- DocumentSkeleton.Mod: a document gadget containing a Panel
	- ViewSkeleton.Mod: a camera view gadget

	In addition, the source code of existing gadgets, which is also included in this release, constitutes an invaluable reference from where to collect ideas on how to implement Gadgets. Advanced readers might also be interested in understanding the motivations behind some of the design and implementation decisions made during the development of the Gadgets system. For those, the full text of the thesis which emanated from this development [Mar96] is included on the CD-ROM.

