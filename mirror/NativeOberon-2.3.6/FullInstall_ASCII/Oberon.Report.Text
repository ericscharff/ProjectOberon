The Programming Language Oberon-2

H. Mssenbck, N. Wirth
Institut fr Computersysteme, ETH Zrich,
1992-1996


	1  Introduction
	2  Syntax
	3  Vocabulary and Representation
	4  Declarations and Scope Rules
	5  Constant Declarations
	6  Type Declarations
	7  Variable Declarations
	8  Expressions
	9  Statements
	10  Procedure Declarations
	11  Modules

	Appendix A  Definitions of Terms
	Appendix B  Syntax of Oberon
	Appendix C  The Module SYSTEM
	Appendix D  The Oberon Environment




1  Introduction

Oberon is a general-purpose language in the tradition of Pascal and Modula-2. Its most important features are block structure, modularity, separate compilation, static typing with strong type checking (also across module boundaries), and type extension with type-bound procedures.
	Type extension makes Oberon an object-oriented language. An object is a variable of an abstract data type consisting of private data (its state) and procedures that operate on this data. Abstract data types are declared as extensible records. Oberon covers most terms of object-oriented languages by the established vocabulary of imperative languages in order to minimize the number of notions for similar concepts.
	This report is not intended as a programmer's tutorial. It is intentionally kept concise. Its function is to serve as a reference for programmers, implementors, and manual writers. What remains unsaid is mostly left so intentionally, either because it can be derived from stated rules of the language, or because it would require to commit the definition when a general commitment appears as unwise.
	Appendix A defines some terms that are used to express the type checking rules of Oberon. Where they appear in the text, they are written in italics to indicate their special meaning (e.g. the same type).



2  Syntax

An extended Backus-Naur Formalism (EBNF) is used to describe the syntax of Oberon: Alternatives are separated by |. Brackets [ and ] denote optionality of the enclosed expression, and braces { and } denote its repetition (possibly 0 times). Non-terminal symbols start with an upper-case letter (e.g. Statement). Terminal symbols either start with a lower-case letter (e.g. ident), or are written all in upper-case letters (e.g. BEGIN), or are denoted by strings (e.g. ":=").



3  Vocabulary and Representation

The representation of (terminal) symbols in terms of characters is defined using the ASCII set. Symbols are identifiers, numbers, strings, operators, and delimiters. The following lexical rules must be observed: Blanks and line breaks must not occur within symbols (except in comments, and blanks in strings). They are ignored unless they are essential to separate two consecutive symbols. Capital and lower-case letters are considered as distinct.


1) Identifiers are sequences of letters and digits. The first character must be a letter.


ident = letter {letter | digit}.
	
Examples:
	x     Scan     Oberon2     GetSymbol     firstLetter



2) Numbers are (unsigned) integer or real constants. The type of an integer constant is the minimal type to which the constant value belongs (see 6.1). If the constant is specified with the suffix H, the representation is hexadecimal otherwise the representation is decimal. A real number always contains a decimal point. Optionally it may also contain a decimal scale factor. The letter E (or D) means "times ten to the power of". A real number is of type REAL, unless it has a scale factor containing the letter D. In this case it is of type LONGREAL.


number 	= integer | real.
integer 	= digit {digit} | digit {hexDigit} "H".
real 	= digit {digit} "." {digit} [ScaleFactor].
ScaleFactor 	= ("E" | "D") ["+" | "-"] digit {digit}.
hexDigit 	= digit | "A" | "B" | "C" | "D" | "E" | "F".
digit 	= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9".

Examples:
	1991	INTEGER	1991
	0DH 	SHORTINT	13
	12.3	REAL	12.3
	4.567E8 	REAL	456700000
	0.57712566D-6 	LONGREAL	0.00000057712566



3) Character constants are denoted by the ordinal number of the character in hexadecimal notation followed by the letter X.


character  = digit {hexDigit} "X".



4) Strings are sequences of characters enclosed in single (') or double (") quote marks. The opening quote must be the same as the closing quote and must not occur within the string. The number of characters in a string is called its length. A string of length 1 can be used wherever a character constant is allowed and vice versa.


string  = ' " ' {char} ' " ' | " ' " {char} " ' ".
	
Examples:
	"Oberon"     "Don't worry!"     "x"	'hello world'



5. Operators and delimiters are the special characters, character pairs, or reserved words listed below. The reserved words consist exclusively of capital letters and cannot be used as identifiers.


+	:=	ARRAY	IMPORT	RETURN
-	^	BEGIN	IN	THEN
*	=	BY	IS	TO
/	#	CASE	LOOP	TYPE
~	<	CONST	MOD	UNTIL
&	>	DIV	MODULE	VAR
.	<=	DO	NIL	WHILE
,	>=	ELSE	OF	WITH
;	..	ELSIF	OR
|	:	END	POINTER
(	)	EXIT	PROCEDURE
[	]	FOR	RECORD
{	}	IF	REPEAT



6. Comments may be inserted between any two symbols in a program. They are arbitrary character sequences opened by the bracket (* and closed by *). Comments may be nested. They do not affect the meaning of a program.



4  Declarations and Scope Rules

Every identifier occurring in a program must be introduced by a declaration, unless it is a predeclared identifier. Declarations also specify certain permanent properties of an object, such as whether it is a constant, a type, a variable, or a procedure. The identifier is then used to refer to the associated object. 
	The scope of an object x extends textually from the point of its declaration to the end of the block (module, procedure, or record) to which the declaration belongs and hence to which the object is local. It excludes the scopes of equally named objects which are declared in nested blocks. The scope rules are:

1)  No identifier may denote more than one object within a given scope (i.e. no identifier may be declared twice in a block);

2)  An object may only be referenced within its scope;

3)  A type T of the form POINTER TO T1 (see 6.4) can be declared at a point where T1 is still unknown. The declaration of T1 must follow in the same block to which T is local;

4)  Identifiers denoting record fields (see 6.3) or type-bound procedures (see 10.2) are valid in record designators only.

An identifier declared in a module block may be followed by an export mark (" * " or " - ") in its declaration to indicate that it is exported. An identifier x exported by a module M may be used in other modules, if they import M (see Ch.11). The identifier is then denoted as M.x in these modules and is called a qualified identifier. Identifiers marked with " - " in their declaration are read-only in importing modules.


Qualident 	= [ident "."] ident.
IdentDef 	= ident [" * " | " - "].


The following identifiers are predeclared; their meaning is defined in the indicated sections:


ABS	(10.3)	LEN	(10.3)
ASH	(10.3)	LONG	(10.3)
BOOLEAN	(6.1)	LONGINT	(6.1)
CAP	(10.3)	LONGREAL	(6.1)
CHAR	(6.1)	MAX	(10.3)
CHR	(10.3)	MIN	(10.3)
COPY	(10.3)	NEW	(10.3)
DEC	(10.3)	ODD	(10.3)
ENTIER	(10.3)	ORD	(10.3)
EXCL	(10.3)	REAL	(6.1)
FALSE	(6.1)	SET	(6.1)
HALT	(10.3)	SHORT	(10.3)
INC	(10.3)	SHORTINT	(6.1)
INCL	(10.3)	SIZE	(10.3)
INTEGER	(6.1)	TRUE	(6.1)




5  Constant Declarations

A constant declaration associates an identifier with a constant value.


ConstantDeclaration = IdentDef "=" ConstExpression.
ConstExpression 	= Expression.
	
Examples:
	N = 100
	limit = 2*N - 1
	fullSet = {MIN(SET) .. MAX(SET)}


A constant expression is an expression that can be evaluated by a mere textual scan without actually executing the program. Its operands are constants (Ch.8) or predeclared functions (Ch.10.3) that can be evaluated at compile time. 



6  Type Declarations

A data type determines the set of values which variables of that type may assume, and the operators that are applicable. A type declaration associates an identifier with a type. In the case of structured types (arrays and records) it also defines the structure of variables of this type.


TypeDeclaration 	= IdentDef "=" Type.
Type = Qualident | ArrayType | RecordType | PointerType | ProcedureType.
	
Examples:
	Table = ARRAY N OF REAL
	Tree = POINTER TO Node
	Node =  RECORD
		key : INTEGER;
		left, right: Tree
	END
	
	CenterTree = POINTER TO CenterNode
	CenterNode = RECORD (Node)
		width: INTEGER;
		subnode: Tree
	END
	
	Function = PROCEDURE(x: INTEGER): INTEGER



6.1 Basic Types

The basic types are denoted by predeclared identifiers. The associated operators are defined in 8.2 and the predeclared function procedures in 10.3. The values of the given basic types are the following:

1.	BOOLEAN	the truth values TRUE and FALSE
2.	CHAR	the characters of the extended ASCII set (0X .. 0FFX)
3.	SHORTINT	the integers between MIN(SHORTINT) and MAX(SHORTINT)
4.	INTEGER	the integers between MIN(INTEGER) and MAX(INTEGER)
5.	LONGINT	the integers between MIN(LONGINT) and MAX(LONGINT)
6.	REAL	the real numbers between MIN(REAL) and MAX(REAL)
7.	LONGREAL	the real numbers between MIN(LONGREAL) and MAX(LONGREAL)
8.	SET	the sets of integers between 0 and MAX(SET)
9.	PTR	base type of any structured pointer type.

Types 3 to 5 are integer types, types 6 and 7 are real types, and together they are called numeric types. They form a hierarchy; the larger type includes (the values of) the smaller type:

	LONGREAL  >=  REAL  >=  LONGINT  >=  INTEGER  >=  SHORTINT


6.2 Array Types

An array is a structure consisting of a number of elements which are all of the same type, called the element type. The number of elements of an array is called its length. The elements of the array are designated by indices, which are integers between 0 and the length minus 1.


ArrayType 	= ARRAY [Length {"," Length}] OF Type.
Length 	= ConstExpression.
	
Examples:
	ARRAY 10, N OF INTEGER
	ARRAY OF CHAR


A type of the form

	ARRAY L0, L1, ..., Ln OF T

is understood as an abbreviation of

	ARRAY L0 OF
		ARRAY L1 OF
		...
			ARRAY Ln OF T

Arrays declared without length are called open arrays. They are restricted to pointer base types (see 6.4), element types of open array types, and formal parameter types (see 10.1). 


6.3 Record Types

A record type is a structure consisting of a fixed number of elements, called fields, with possibly different types. The record type declaration specifies the name and type of each field. The scope of the field identifiers extends from the point of their declaration to the end of the record type, but they are also visible within designators referring to elements of record variables (see 8.1). If a record type is exported, field identifiers that are to be visible outside the declaring module must be marked. They are called public fields; unmarked elements are called private fields.


RecordType 	= RECORD ["("BaseType")"] FieldList {";" FieldList} END.
BaseType 	= Qualident.
FieldList 	= [IdentList ":" Type ].
	
Examples:
	RECORD
		day, month, year: INTEGER
	END

	RECORD
		name, firstname: ARRAY 32 OF CHAR;
		age: INTEGER;
		salary: REAL
	END


Record types are extensible, i.e. a record type can be declared as an extension of another record type. In the example

	T0 = RECORD x: INTEGER END
	T1 = RECORD (T0) y: REAL END

T1 is a (direct) extension of T0 and T0 is the (direct) base type of T1 (see App. A). An extended type T1 consists of the fields of its base type and of the fields which are declared in T1 (see Ch. 6). All identifiers declared in the extended record must be different from the identifiers declared in its base type record(s).


6.4 Pointer Types

Variables of a pointer type P assume as values pointers to variables of some type T. T is called the pointer base type of P and must be a record or array type. Pointer types inherit the extension relation of their pointer base types: if a type T1 is an extension of T, and P1 is of type POINTER TO T1, then P1 is also an extension of P.
	
PointerType = POINTER TO Type.


If p is a variable of type P = POINTER TO T, a call of the predeclared procedure NEW(p) (see 10.3) allocates a variable of type T in free storage. If T is a record type or an array type with fixed length, the allocation has to be done with NEW(p); if T is an n-dimensional open array type the allocation has to be done with NEW(p, e0, ..., en-1) where T is allocated with lengths given by the expressions e0, ..., en-1. In either case a pointer to the allocated variable is assigned to p. p is of type P. The referenced  variable p^ (pronounced as p-referenced) is of type T.
	Any pointer variable may assume the value NIL, which points to no variable at all. All pointer variables inherit the extension relation of the basetype PTR and are initialized to NIL.


6.5 Procedure Types

Variables of a procedure type T have a procedure (or NIL) as value. If a procedure P is assigned to a variable of type T, the formal parameter lists (see Ch. 10.1) of P and T must match (see App. A). P must not be a predeclared or type-bound procedure nor may it be local to another procedure.


ProcedureType = PROCEDURE [FormalParameters].




7  Variable declarations

Variable declarations introduce variables by defining an identifier and a data type for them.


VariableDeclaration = IdentList ":" Type.

Examples:
	i, j, k: INTEGER
	x, y: REAL
	p, q: BOOLEAN
	s: SET
	F: Function
	a: ARRAY 100 OF REAL
	w: ARRAY 16 OF RECORD
		name: ARRAY 32 OF CHAR;
		count: INTEGER
	END
	t, c: Tree


Record and pointer variables have both a static type (the type with which they are declared - simply called their type) and a dynamic type (the type they assume at run time). For pointers and variable parameters of record type the dynamic type may be an extension of their static type. The static type determines which fields of a record are accessible. The dynamic type is used to call type-bound procedures (see 10.2).



8  Expressions

Expressions are constructs denoting rules of computation whereby constants and current values of variables are combined to compute other values by the application of operators and function procedures. Expressions consist of operands and operators. Parentheses may be used to express specific associations of operators and operands.


8.1 Operands

With the exception of set constructors and literal constants (numbers, character constants, or strings), operands are denoted by designators. A designator consists of an identifier referring to a constant, variable, or procedure. This identifier may possibly be qualified by a module identifier (see Ch. 4 and 11) and may be followed by selectors if the designated object is an element of a structure.


Designator  = Qualident {"." ident | "[" ExpressionList "]" | "^" | "(" Qualident ")"}.
ExpressionList  = Expression {"," Expression}.
	
Examples:
	i	(INTEGER)
	a[i]	(REAL)
	w[3].name[i]	(CHAR)
	t.left.right	(Tree)
	t(CenterTree).subnode	(Tree)


If a designates an array, then a[e] denotes that element of a whose index is the current value of the expression e. The type of e must be an integer type. A designator of the form a[e0, e1, ..., en] stands for a[e0][e1]...[en]. If r designates a record, then r.f denotes the field f of r or the procedure f bound to the dynamic type of r (Ch. 10.2). If p designates a pointer, p^ denotes the variable which is referenced by p. The designators p^.f and p^[e] may be abbreviated as p.f and p[e], i.e. record and array selectors imply dereferencing. If a or r are read-only, then also a[e] and r.f are read-only. 
	A type guard v(T) asserts that the dynamic type of v is T (or an extension of T), i.e. program execution is aborted, if the dynamic type of v is not T (or an extension of T). Within the designator, v is then regarded as having the static type T. The guard is applicable, if

	1.  v is a variable parameter of record type or v is a pointer, and if
	2.  T is an extension of the static type of v

If the designated object is a constant or a variable, then the designator refers to its current value. If it is a procedure, the designator refers to that procedure unless it is followed by a (possibly empty) parameter list in which case it implies an activation of that procedure and stands for the value resulting from its execution. The actual parameters must correspond to the formal parameters as in proper procedure calls (see 10.1).


8.2 Operators

Four classes of operators with different precedences (binding strengths) are syntactically distinguished in expressions. The operator ~ has the highest precedence, followed by multiplication operators, addition operators, and relations. Operators of the same precedence associate from left to right. For example, x-y-z stands for (x-y)-z.


Expression 	= 	SimpleExpression [Relation SimpleExpression].
SimpleExpression	= 	["+" | "-"] Term {AddOperator Term}.
Term 	= 	Factor {MulOperator Factor}.
Factor 	= 	Designator [ActualParameters] | 
	    	number | character | string | NIL | Set | "(" Expression ")" | "~" Factor.
Set 	= 	"{" [Element {"," Element}] "}".
Element 	= 	Expression [".." Expression].
ActualParameters 	= 	"(" [ExpressionList] ")".
Relation 	= 	"=" | "#" | "<" | "<=" | ">" | ">=" | IN | IS.
AddOperator 	= 	"+" | "-" | OR.
MulOperator 	= 	"*" | "/" | DIV | MOD | "&".


The available operators are listed in the following tables. Some operators are applicable to operands of various types, denoting different operations. In these cases, the actual operation is identified by the type of the operands. The operands must be expression compatible with respect to the operator (see App.A).


8.2.1 Logical operators

OR	logical disjunction 	p OR q	  "if p then TRUE, else q"
&	logical conjunction 	p & q	  "if p then q, else FALSE"
~	negation 	~ p	  "not p"

These operators apply to BOOLEAN operands and yield a BOOLEAN result.


8.2.2 Arithmetic operators

+	sum
-	difference
*	product
/	real quotient
DIV	integer quotient
MOD	modulus

The operators +, -, *, and / apply to operands of numeric types. The type of the result is the type of that operand which includes the type of the other operand, except for division (/), where the result is the smallest real type which includes both operand types. When used as monadic operators, - denotes sign inversion and + denotes the identity operation. The operators DIV and MOD apply to integer operands only. They are related by the following formulas defined for any x and positive divisors y:

x = (x DIV y) * y + (x MOD y)
0 <= (x MOD y) < y

Examples:
x	y	x DIV y	x MOD y
5	3	1	2
-5	3	-2	1


8.2.3 Set Operators

+	union
-	difference (x - y = x * (-y))
*	intersection
/	symmetric set difference (x / y = (x-y) + (y-x))

Set operators apply to operands of type SET and yield a result of type SET. The monadic minus sign denotes the complement of x, i.e. -x denotes the set of integers between 0 and MAX(SET) which are not elements of x.
A set constructor defines the value of a set by listing its elements between curly brackets. The elements must be integers in the range 0..MAX(SET). A range a..b denotes all integers in the interval [a, b].


8.2.4 Relations

=	equal
#	unequal
<	less
<=	less or equal
>	greater
>=	greater or equal
IN	set membership
IS	type test

Relations yield a BOOLEAN result. The relations =, #, <, <=, >, and >= apply to the numeric types, CHAR, (open) character arrays, and strings. The relations = and # also apply to BOOLEAN and SET, as well as to pointer and procedure types (including the value NIL). x IN s stands for "x is an element of s". x must be of an integer type, and s of type SET. v IS T stands for "the dynamic type of v is T (or an extension of T)" and is called a type test. It is applicable if

1.  v is a variable parameter of record type or v is a pointer, and if
2.  T is an extension of the static type of v


Examples of expressions (refer to examples in Ch.7):
	1991	INTEGER
	i DIV 3	INTEGER
	~p OR q	BOOLEAN
	(i+j) * (i-j)	INTEGER
	s - {8, 9, 13}	SET
	i + x	REAL
	a[i+j] * a[i-j]	REAL
	(0<=i) & (i<100)	BOOLEAN
	t.key = 0	BOOLEAN
	k IN {i..j-1}	BOOLEAN
	w[i].name <= "John"	BOOLEAN
	t IS CenterTree	BOOLEAN





9  Statements

Statements denote actions. There are elementary and structured statements. Elementary statements are not composed of any parts that are themselves statements. They are the assignment, the procedure call, the return, and the exit statement. Structured statements are composed of parts that are themselves statements. They are used to express sequencing and conditional, selective, and repetitive execution. A statement may also be empty, in which case it denotes no action. The empty statement is included in order to relax punctuation rules in statement sequences.


Statement =
		[ Assignment | ProcedureCall | IfStatement | CaseStatement | WhileStatement | RepeatStatement |
		ForStatement | LoopStatement | WithStatement | EXIT | RETURN [Expression] ].



9.1 Assignments

Assignments replace the current value of a variable by a new value specified by an expression. The expression must be assignment compatible with the variable (see App. A). The assignment operator is written as ":=" and pronounced as becomes.


Assignment = Designator ":=" Expression.
	
Examples (refer to examples in Ch. 7):
	i := 0
	p := i = j
	x := i + 1
	k := log2(i+j)
	F := log2		(* see 10.1 *)
	s := {2, 3, 5, 7, 11, 13}
	a[i] := (x+y) * (x-y)
	t.key := i
	w[i+1].name := "John"
	t := c


If an expression e of type Te is assigned to a variable v of type Tv, the following happens:

1) If Tv and Te are record types, only those fields of Te are assigned which also belong to Tv (projection); the dynamic type of v  must be the same as the static type of v and  is not changed by the assignment;

2)  If Tv and Te are pointer types, the dynamic type of v becomes the dynamic type of e;

3) If Tv is ARRAY n OF CHAR and e is a string of length m<n, v[i] becomes ei for i = 0..m-1 and v[m] becomes 0X.


9.2 Procedure Calls

A procedure call activates a procedure. It may contain a list of actual parameters which replace the corresponding formal parameters defined in the procedure declaration (see Ch. 10). The correspondence is established by the positions of the parameters in the actual and formal parameter lists. There are two kinds of parameters: variable and value parameters.
	If a formal parameter is a variable parameter, the corresponding actual parameter must be a designator denoting a variable. If it denotes an element of a structured variable, the component selectors are evaluated when the formal/actual parameter substitution takes place, i.e. before the execution of the procedure. If a formal parameter is a value parameter, the corresponding actual parameter must be an expression. This expression is evaluated before the procedure activation, and the resulting value is assigned to the formal parameter (see also 10.1).


ProcedureCall = Designator [ActualParameters].
	
Examples:
	WriteInt(i*2+1)	(* see 10.1 *)
	INC(w[k].count)
	t.Insert("John")	(* see 11 *)


To keep the language type-safe, a formal variable parameter of type PTR requests the actual parameter to be of type PTR too.


9.3 Statement Sequences

Statement sequences denote the sequence of actions specified by the component statements which are separated by semicolons.


StatementSequence = Statement {";" Statement}.



9.4 If Statements


IfStatement = 
	IF Expression THEN StatementSequence
	{ELSIF Expression THEN StatementSequence}
	[ELSE StatementSequence]
	END.
	
Example:
	IF (ch >= "A") & (ch <= "Z") THEN ReadIdentifier
	ELSIF (ch >= "0") & (ch <= "9") THEN ReadNumber
	ELSIF (ch = " ' ") OR (ch = ' " ') THEN ReadString
	ELSE SpecialCharacter
	END

	
If statements specify the conditional execution of guarded statement sequences. The Boolean expression preceding a statement sequence is called its guard. The guards are evaluated in sequence of occurrence, until one evaluates to TRUE, whereafter its associated statement sequence is executed. If no guard is satisfied, the statement sequence following the symbol ELSE is executed, if there is one.


9.5 Case Statements

Case statements specify the selection and execution of a statement sequence according to the value of an expression. First the case expression is evaluated, then that statement sequence is executed whose case label list contains the obtained value. The case expression must either be of an integer type that includes the types of all case labels, or both the case expression and the case labels must be of type CHAR. Case labels are constants, and no value must occur more than once. If the value of the expression does not occur as a label of any case, the statement sequence following the symbol ELSE is selected, if there is one, otherwise the program is aborted.


CaseStatement 	= CASE Expression OF Case {"|" Case} [ELSE StatementSequence] END.
Case 	= [CaseLabelList ":" StatementSequence].
CaseLabelList 	= CaseLabels {"," CaseLabels}.
CaseLabels 	= ConstExpression [".." ConstExpression].
	
Example:
	CASE ch OF
	"A" .. "Z": ReadIdentifier 
	| "0" .. "9": ReadNumber 
	| " ' ", ' " ': ReadString
	ELSE SpecialCharacter
	END



9.6 While Statements

While statements specify the repeated execution of a statement sequence while the Boolean expression (its guard) yields TRUE. The guard is checked before every execution of the statement sequence.


WhileStatement = WHILE Expression DO StatementSequence END.
	
Examples:
	WHILE i > 0 DO i := i DIV 2; k := k + 1 END
	WHILE (t # NIL) & (t.key # i) DO t := t.left END




9.7 Repeat Statements

A repeat statement specifies the repeated execution of a statement sequence until a condition specified by a Boolean expression is satisfied. The statement sequence is executed at least once.


RepeatStatement = REPEAT StatementSequence UNTIL Expression.


9.8 For Statements

A for statement specifies the repeated execution of a statement sequence for a fixed number of times while a progression of values is assigned to an integer variable called the control variable of the for statement.


ForStatement = FOR ident ":=" Expression TO Expression [BY ConstExpression] DO StatementSequence END.
	
Examples:
	FOR i := 0 TO 79 DO k := k + a[i] END
	FOR i := 79 TO 1 BY -1 DO a[i] := a[i-1] END


The statement

	FOR v := low TO high BY step DO statements END

is equivalent to

v := low; temp := high;
IF step > 0 THEN
	WHILE v <= temp DO statements; v := v + step END
ELSE
	WHILE v >= temp DO statements; v := v + step END
END

low must be assignment compatible with v (see App. A), high must be expression compatible (i.e. comparable) with v, and step must be a nonzero constant expression of an integer type. If step is not specified, it is assumed to be 1.


9.9 Loop Statements

A loop statement specifies the repeated execution of a statement sequence. It is terminated upon execution of an exit statement within that sequence (see 9.10).


LoopStatement = LOOP StatementSequence END.
	
Example:
	LOOP
		ReadInt(i);
		IF i < 0 THEN EXIT END;
		WriteInt(i)
	END	


Loop statements are useful to express repetitions with several exit points or cases where the exit condition is in the middle of the repeated statement sequence.


9.10 Return and Exit Statements

A return statement indicates the termination of a procedure. It is denoted by the symbol RETURN, followed by an expression if the procedure is a function procedure. The type of the expression must be assignment compatible (see App. A) with the result type specified in the procedure heading (see Ch.10).
	Function procedures require the presence of a return statement indicating the result value. In proper procedures, a return statement is implied by the end of the procedure body. Any explicit return statement therefore appears as an additional (probably exceptional) termination point.
	An exit statement is denoted by the symbol EXIT. It specifies termination of the enclosing loop statement and continuation with the statement following that loop statement. Exit statements are contextually, although not syntactically associated with the loop statement which contains them.


9.11 With Statements

With statements execute a statement sequence depending on the result of a type test and apply a type guard to every occurrence of the tested variable within this statement sequence.


WithStatement 	= 	WITH Guard DO StatementSequence {"|" Guard DO StatementSequence}
			[ELSE StatementSequence] END.
Guard	= 	Qualident ":" Qualident.
	
Example:
	WITH t: CenterTree DO i := t.width; c := t.subnode END


If v is a variable parameter of record type or a pointer variable, and if it is of a static type T0, the statement

	WITH v: T1 DO S1 | v: T2 DO S2 ELSE S3 END

has the following meaning: if the dynamic type of v is T1, then the statement sequence S1 is executed where v is regarded as if it had the static type T1; else if the dynamic type of v is T2, then S2 is executed where v is regarded as if it had the static type T2; else S3 is executed. T1 and T2 must be extensions of T0. If no type test is satisfied and if an else clause is missing the program is aborted.



10  Procedure Declarations

A procedure declaration consists of a procedure heading and a procedure body. The heading specifies the procedure identifier and the formal parameters. For type-bound procedures it also specifies the receiver parameter. The body contains declarations and statements. The procedure identifier is repeated at the end of the procedure declaration.
	There are two kinds of procedures: proper procedures and function procedures. The latter are activated by a function designator as a constituent of an expression and yield a result that is an operand of the expression. Proper procedures are activated by a procedure call. A procedure is a function procedure if its formal parameters specify a result type. The body of a function procedure must contain a return statement which defines its result.
	All constants, variables, types, and procedures declared within a procedure body are local to the procedure. Since procedures may be declared as local objects too, procedure declarations may be nested. The call of a procedure within its declaration implies recursive activation.
	In addition to its formal parameters and locally declared objects, the objects declared in the environment of the procedure are also visible in the procedure (with the exception of those objects that have the same name as an object declared locally).


ProcedureDeclaration	= 	ProcedureHeading ";" ProcedureBody ident.
ProcedureHeading 	= 	PROCEDURE [Receiver] IdentDef [FormalParameters].
ProcedureBody 	= 	DeclarationSequence [BEGIN StatementSequence] END.
DeclarationSequence 	= 	{CONST {ConstantDeclaration ";"} | TYPE {TypeDeclaration ";"} | VAR 		{VariableDeclaration ";"} }
		{ProcedureDeclaration ";" | ForwardDeclaration ";"}.
ForwardDeclaration 	= 	PROCEDURE " ^ " [Receiver] IdentDef [FormalParameters].


If a procedure declaration specifies a receiver parameter, the procedure is considered to be bound to a type (see 10.2). A forward declaration serves to allow forward references to a procedure whose actual declaration appears later in the text. The formal parameter lists of the forward declaration and the actual declaration must match (see App. A).


10.1 Formal Parameters

Formal parameters are identifiers declared in the formal parameter list of a procedure. They correspond to actual parameters specified in the procedure call. The correspondence between formal and actual parameters is established when the procedure is called. There are two kinds of parameters, value and variable parameters, indicated in the formal parameter list by the absence or presence of the keyword VAR. Value parameters are local variables to which the value of the corresponding actual parameter is assigned as an initial value. Variable parameters correspond to actual parameters that are variables, and they stand for these variables. The scope of a formal parameter extends from its declaration to the end of the procedure block in which it is declared. A function procedure without parameters must have an empty parameter list. It must be called by a function designator whose actual parameter list is empty too. The result type of a procedure can be neither a record nor an array.


FormalParameters	= "(" [FPSection {";" FPSection}] ")" [":" Qualident].
FPSection 	= [VAR] ident {"," ident} ":" Type.
	
Examples:
	PROCEDURE ReadInt(VAR x: INTEGER);
		VAR i: INTEGER; ch: CHAR;
	BEGIN i := 0; Read(ch);
		WHILE ("0" <= ch) & (ch <= "9") DO
			i := 10*i + (ORD(ch)-ORD("0")); Read(ch)
		END;
		x := i
	END ReadInt

	PROCEDURE WriteInt(x: INTEGER); (*0 <= x <100000*)
		VAR i: INTEGER; buf: ARRAY 5 OF INTEGER;
	BEGIN i := 0;
		REPEAT buf[i] := x MOD 10; x := x DIV 10; INC(i) UNTIL x = 0;
		REPEAT DEC(i); Write(CHR(buf[i] + ORD("0"))) UNTIL i = 0
	END WriteInt

	PROCEDURE WriteString(s: ARRAY OF CHAR);
		VAR i: INTEGER;
	BEGIN i := 0;
		WHILE (i < LEN(s)) & (s[i] # 0X) DO Write(s[i]); INC(i) END
	END WriteString;

	PROCEDURE log2(x: INTEGER): INTEGER;
		VAR y: INTEGER; (*assume x>0*)
	BEGIN
		y := 0; WHILE x > 1 DO x := x DIV 2; INC(y) END;
		RETURN y
	END log2;


Let Tf be the type of a formal parameter f (not an open array) and Ta the type of the corresponding actual parameter a. For variable parameters, Ta must be the same as Tf, or Tf must be a record type and Ta an extension of Tf. For value parameters, a must be assignment compatible with f (see App. A).
	If Tf is an open array , then a must be array compatible with f (see App. A). The lengths of f are taken from a.


10.2 Type-Bound Procedures

Globally declared procedures may be associated with a record type declared in the same module. The procedures are said to be bound to the record type. The binding is expressed by the type of the receiver in the heading of a procedure declaration.  The receiver may be either a variable parameter of record type T or a value parameter of type POINTER TO T (where T is a record type). The procedure is bound to the type T and is considered local to it.


ProcedureHeading	= 	PROCEDURE [Receiver] IdentDef [FormalParameters].
Receiver 	= 	"(" [VAR] ident ":" ident ")".
	
Examples:
	PROCEDURE (t: Tree) Insert (node: Tree);
		VAR p, father: Tree;
	BEGIN p := t;
		REPEAT father := p;
			IF node.key = p.key THEN RETURN END;
			IF node.key < p.key THEN p := p.left ELSE p := p.right END
		UNTIL p = NIL;
		IF node.key < father.key THEN father.left := node ELSE father.right := node END;
		node.left := NIL; node.right := NIL
	END Insert;

	PROCEDURE (t: CenterTree) Insert (node: Tree);  (*redefinition*)
	BEGIN
		WriteInt(node(CenterTree).width);
		t.Insert^ (node)  (* calls the Insert procedure bound to Tree *)
	END Insert;


If a procedure P is bound to a type T0, it is implicitly also bound to any type T1 which is an extension of T0. However, a procedure P ' (with the same name as P) may be explicitly bound to T1 in which case it overrides the binding of P. P ' is considered a redefinition of P for T1. The formal parameters of P and P ' must match (see App. A). If P and T1 are exported (see Chapter 4) P ' must be exported too.
	If v is a designator and P is a type-bound procedure, then v.P denotes that procedure P which is bound to the dynamic type of v (dynamic binding). Note, that this may be a different procedure than the one bound to the static type of v. v is passed to P's receiver according to the parameter passing rules specified in Chapter 10.1.
	If r is a receiver parameter declared with type T, r.P^ denotes the (redefined) procedure P bound to the base type of T.
In a forward declaration of a type-bound procedure the receiver parameter must be of the same type as in the actual procedure declaration. The formal parameter lists of both declarations must match (App.A).

10.3 Predeclared procedures

The following table lists the predeclared procedures. Some are generic procedures, i.e. they apply to several types of operands. v stands for a variable, x and n for expressions, and T for a type.

Function procedures


Name	Argument type	Result type	Function

ABS(x)	numeric type	type of x	absolute value
ASH(x, n)	x, n: integer type	LONGINT	arithmetic shift (x * 2n)
CAP(x)	CHAR	CHAR	x is letter: corresponding capital letter
CHR(x)	integer type	CHAR	character with ordinal number x
ENTIER(x)	real type	LONGINT	largest integer not greater than x
LEN(v, n)	v: array; n: integer const.	LONGINT	length of v in dimension n (first dimension = 0)
LEN(v)	v: array	LONGINT	equivalent to LEN(v, 0)
LONG(x)	SHORTINT	INTEGER	identity
	INTEGER	LONGINT
	REAL	LONGREAL
MAX(T)	T = basic type	T	maximum value of type T
	T = SET	INTEGER	maximum element of a set
MIN(T)	T = basic type	T	minimum value of type T
	T = SET	INTEGER	0
ODD(x)	integer type	BOOLEAN	x MOD 2 = 1
ORD(x)	CHAR	INTEGER	ordinal number of x
SHORT(x)	LONGINT	INTEGER	identity
	INTEGER	SHORTINT	identity
	LONGREAL	REAL	identity (truncation possible)
SIZE(T)	any type	integer type	number of bytes required by T


Proper procedures


Name	Argument types	Function

ASSERT(x)	x: Boolean expression	terminate program execution if not x
ASSERT(x, n)	x: Boolean expression; n: integer constant	terminate program execution if not x
COPY(x, v)	x: character array, string; v: character array	v := x
DEC(v)	integer type	v := v - 1
DEC(v, n)	v, n: integer type	v := v - n
EXCL(v, x)	v: SET; x: integer type	v := v - {x}
HALT(x)	integer constant	terminate program execution
INC(v)	integer type	v := v + 1
INC(v, n)	v, n: integer type	v := v + n
INCL(v, x)	v: SET; x: integer type	v := v + {x}
NEW(v)	pointer to record or fixed array	allocate v ^
NEW(v, x0, ..., xn) v: pointer to open array; xi: integer type	allocate v ^ with lengths x0.. xn


COPY allows the assignment between (open) character arrays with different types. If necessary, the source is shortened to the target length minus one. The target is always terminated by the character 0X. In ASSERT(x, n) and HALT(x), the interpretation of x is left to the underlying system implementation.



11  Modules

A module is a collection of declarations of constants, types, variables, and procedures, together with a sequence of statements for the purpose of assigning initial values to the variables. A module constitutes a text that is compilable as a unit.


Module 	= MODULE ident ";" [ImportList] DeclarationSequence 
	    [BEGIN StatementSequence] END ident ".".
ImportList 	= IMPORT Import {"," Import} ";".
Import 	= [ident ":="] ident.

Example:

MODULE Trees; 	(* exports: Tree, Node, Insert, Search, Write, Init *)
	IMPORT Texts, Oberon;	(* exports read-only: Node.name *)

	TYPE
		Tree* = POINTER TO Node;
		Node* = RECORD
			name-: POINTER TO ARRAY OF CHAR;
			left, right: Tree
		END;

	VAR w: Texts.Writer;

	PROCEDURE (t: Tree) Insert* (name: ARRAY OF CHAR);
		VAR p, father: Tree;
	BEGIN p := t;
		REPEAT father := p;
			IF name = p.name^ THEN RETURN END;
			IF name < p.name^ THEN p := p.left ELSE p := p.right END
		UNTIL p = NIL;
		NEW(p); p.left := NIL; p.right := NIL; NEW(p.name, LEN(name)+1); COPY(name, p.name^);
		IF name < father.name^ THEN father.left := p ELSE father.right := p END
	END Insert;

	PROCEDURE (t: Tree) Search* (name: ARRAY OF CHAR): Tree;
		VAR p: Tree;
	BEGIN p := t;
		WHILE (p # NIL) & (name # p.name^) DO
			IF name < p.name^ THEN p := p.left ELSE p := p.right END
		END;
		RETURN p
	END Search;
	PROCEDURE (t: Tree) Write*;
	BEGIN
		IF t.left # NIL THEN t.left.Write END;
		Texts.WriteString(w, t.name^); Texts.WriteLn(w); Texts.Append(Oberon.Log, w.buf);
		IF t.right # NIL THEN t.right.Write END
	END Write;

	PROCEDURE Init* (VAR t: Tree);
		VAR t: Tree;
	BEGIN NEW(t.name, 1); t.name[0] := 0X; t.left := NIL; t.right := NIL
	END Init;
BEGIN Texts.OpenWriter(w)
END Trees.


The import list specifies the names of the imported modules. If a module A is imported by a module M and A exports an identifier x, then x is referred to as A.x within M. If A is imported as B := A, the object x must be referenced as B.x. This allows short alias names in qualified identifiers. Identifiers that are to be exported (i.e. that are to be visible in client modules) must be marked by an export mark in their declaration (see Chapter 4).
	The statement sequence following the symbol BEGIN is executed when the module is added to a system (loaded), which is done after the imported modules have been loaded. It follows that cyclic import of modules is illegal. Individual (parameterless and exported) procedures can be activated from the system, and these procedures serve as commands (see Appendix D1).



Appendix A: Definition of Terms


Integer types	SHORTINT, INTEGER, LONGINT
Real types	REAL, LONGREAL
Numeric types	integer types, real types


Same types

Two variables a and b with types Ta and Tb are of the same type if
1)  Ta and Tb are both denoted by the same type identifier, or
2)  Ta is declared to equal Tb in a type declaration of the form Ta = Tb, or
3)   a and b appear in the same identifier list in a variable, record field, or formal parameter declaration and are not open arrays.


Equal types

Two types Ta and Tb are equal if
1)  Ta and Tb are the same type,  or
2)  Ta and Tb are open array types with equal element types, or
3)  Ta and Tb are procedure types whose formal parameter lists match.


Type inclusion

Numeric types include (the values of) smaller numeric types according to the following hierarchy:

	LONGREAL >= REAL >= LONGINT >= INTEGER >= SHORTINT


Type extension (base type)

Given a type declaration Tb = RECORD (Ta) ... END, Tb is a direct extension of Ta, and Ta is a direct base type of Tb. A type Tb is an extension of a type Ta (Ta is a base type of Tb) if
1)  Ta and Tb are the same types, or
2)  Tb is a direct extension of an extension of Ta.
If Pa = POINTER TO Ta and Pb = POINTER TO Tb, Pb is an extension of Pa (Pa is a base type of Pb) if Tb is an extension of Ta.


Assignment compatible

An expression e of type Te is assignment compatible with a variable v of type Tv if one of the following conditions hold:
1)  Te and Tv are the same type;
2)  Te and Tv are numeric types and Tv includes Te;
3)  Te and Tv are record types and Te is an extension of Tv and the dynamic type of v is Tv ;
4)  Te and Tv are pointer types and Te is an extension of Tv;
5)  Tv is a pointer or a procedure type and e is NIL;
6)  Tv is ARRAY n OF CHAR, e is a string constant with m characters, and m < n;
7)  Tv is a procedure type and e is the name of a procedure whose formal parameters match those of Tv.


Array compatible

An actual parameter a of type Ta is array compatible with a formal parameter f of type Tf if
1)  Tf and Ta are the same type, or
2)  Tf is an open array, Ta is any array, and their element types are array compatible, or
3)  Tf is ARRAY OF CHAR and a is a string.


Expression compatible

For a given operator, the types of its operands are expression compatible if they conform to the following table (which shows also the result type of the expression). Type T1 must be an extension of type T0:


operator 	first operand	second operand 	result type
+ - *	numeric	numeric	smallest numeric type including both operands
/	numeric	numeric	smallest real type including both operands
+ - * /	SET	SET	SET
DIV MOD	integer	integer	smallest integer type including both operands
OR & ~	BOOLEAN	BOOLEAN	BOOLEAN
= # < <= > >=	numeric	numeric	BOOLEAN
	CHAR	CHAR	BOOLEAN
	character array, string	character array, string	BOOLEAN
= #	BOOLEAN	BOOLEAN	BOOLEAN
	SET	SET	BOOLEAN
	NIL, pointer type T0 or T1	NIL, pointer type T0 or T1	BOOLEAN
	procedure type T, NIL	procedure type T, NIL	BOOLEAN
IN	integer	SET	BOOLEAN
IS	type T0	type T1	BOOLEAN



Matching formal parameter lists

Two formal parameter lists match if
1)  they have the same number of parameters, and
2)  they have either the same function result type or none, and
3)  parameters at corresponding positions have equal types, and
4)  parameters at corresponding positions are both either value or variable parameters.



Appendix B: Syntax of Oberon

Module 	= 	MODULE ident ";" [ImportList] DeclSeq  [BEGIN StatementSeq] END ident ".".
ImportList 	= 	IMPORT [ident ":="] ident {"," [ident ":="] ident} ";".
DeclSeq 	= 	{ CONST {ConstDecl ";" } | TYPE {TypeDecl ";"} | VAR {VarDecl ";"}} {ProcDecl ";" | ForwardDecl ";"}.
ConstDecl	=	 IdentDef "=" ConstExpr.
TypeDecl	=	 IdentDef "=" Type.
VarDecl	=	 IdentList ":" Type.
ProcDecl 	= 	PROCEDURE [Receiver] IdentDef [FormalPars] ";" DeclSeq [BEGIN StatementSeq] END ident.
ForwardDecl	= 	PROCEDURE "^" [Receiver] IdentDef [FormalPars].
FormalPars 	= 	"(" [FPSection {";" FPSection}] ")" [":" Qualident].
FPSection 	= 	[VAR] ident {"," ident} ":" Type.
Receiver	=	 "(" [VAR] ident ":" ident ")".
Type 	= 	Qualident
	|	 ARRAY [ConstExpr {"," ConstExpr}] OF Type 
	|	 RECORD ["("Qualident")"] FieldList {";" FieldList} END
	|	 POINTER TO Type
	|	 PROCEDURE [FormalPars].
FieldList 	= 	[IdentList ":" Type].
StatementSeq	= 	Statement {";" Statement}.
Statement 	=	[  Designator ":=" Expr 
	|	  Designator ["(" [ExprList] ")"] 
	|	  IF Expr THEN StatementSeq {ELSIF Expr THEN StatementSeq} [ELSE StatementSeq] END 
	|	  CASE Expr OF Case {"|" Case} [ELSE StatementSeq] END 
	|	  WHILE Expr DO StatementSeq END 
	|	  REPEAT StatementSeq UNTIL Expr 
	|	  FOR ident ":=" Expr TO Expr [BY ConstExpr] DO StatementSeq END 
	|	  LOOP StatementSeq END
	|	  WITH Guard DO StatementSeq {"|" Guard DO StatementSeq} [ELSE StatementSeq] END
	|	  EXIT 
	|	  RETURN [Expr]
		  ].
Case 	= 	[CaseLabels {"," CaseLabels} ":" StatementSeq].
CaseLabels 	= 	ConstExpr [".." ConstExpr].
Guard	=	 Qualident ":" Qualident.
ConstExpr	=	 Expr.
Expr 	= 	SimpleExpr [Relation SimpleExpr].
SimpleExpr	= 	["+" | "-"] Term {AddOp Term}.
Term 	= 	Factor {MulOp Factor}.
Factor 	= 	Designator ["(" [ExprList] ")"] | number | character | string | NIL | Set | "(" Expr ")" | " ~ " Factor.
Set	=	 "{" [Element {"," Element}] "}".
Element 	= 	Expr [".." Expr].
Relation 	= 	"=" | "#" | "<" | "<=" | ">" | ">=" | IN | IS.
AddOp 	= 	"+" | "-" | OR.
MulOp 	= 	" * " | "/" | DIV | MOD | "&".
Designator 	= 	Qualident {"." ident | "[" ExprList "]" | " ^ " | "(" Qualident ")"}.
ExprList 	= 	Expr {"," Expr}.
IdentList 	= 	IdentDef {"," IdentDef}.
Qualident 	= 	[ident "."] ident.
IdentDef 	= 	ident [" * " | "-"].



Appendix C: The Module SYSTEM

The module SYSTEM contains certain types and procedures that are necessary to implement low-level operations particular to a given computer and/or implementation. These include for example facilities for accessing devices that are controlled by the computer, and facilities to break the type compatibility rules otherwise imposed by the language definition. It is strongly recommended to restrict their use to specific modules (called low-level modules). The following specifications hold for the implementation of Oberon on the Ceres computer.
	Module SYSTEM exports a type BYTE with the following characteristics: Variables of type CHAR or SHORTINT can be assigned to variables of type BYTE. If a formal variable parameter is of type ARRAY OF BYTE then the corresponding actual parameter may be of any type.
	Another type exported by module SYSTEM is the type PTR. Variables of any pointer type may be assigned to variables of type PTR. If a formal variable parameter is of type PTR, the actual parameter may be of any pointer type.
	The procedures contained in module SYSTEM are listed in the following tables. Most of them correspond to single instructions compiled as in-line code. For details, the reader is referred to the processor manual. v stands for a variable, x, y, a, and n for expressions, and T for a type.

Function procedures


Name	Argument types	Result type	Function

ADR(v)	any	LONGINT	address of variable v
BIT(a, n)	a: LONGINT	BOOLEAN	bit n of Mem[a]
	n: integer
CC(n)	integer constant	BOOLEAN	condition n (0 <= n <= 15)
LSH(x, n)	x: integer, CHAR, BYTE	type of x	logical shift
	n: integer
ROT(x, n)	x: integer, CHAR, BYTE	type of x	rotation
	n: integer
VAL(T, x)	T, x: any type	T	x interpreted as of type T


Proper procedures


Name	Argument types	Function

GET(a, v)	a: LONGINT; v: any basic type,	v := Mem[a]
	pointer, procedure type
PUT(a, x)	a: LONGINT; x: any basic type,	Mem[a] := x
	pointer, procedure type
GETREG(n, v)	n: integer constant; v: any basic type,	v := Register n
	pointer, procedure type
PUTREG(n, x)	n: integer constant; x: any basic type,	Register n := v
	pointer, procedure type
MOVE(a0, a1, n)	a0, a1: LONGINT; n: integer	Mem[a1.. a1+n-1] := Mem[a0.. a0+n-1]
NEW(v, n)	v: any pointer; n: integer	allocate storage block of n bytes
		assign its address to v




Appendix D: The Oberon Environment

Oberon programs usually run in an environment that provides command activation, garbage collection, dynamic loading of modules, and certain run time data structures. Although not part of the language, this environment contributes to the power of Oberon and is to some degree implied by the language definition. Appendix D describes the essential features of a typical Oberon environment and provides implementation hints. More details can be found in [1], [2], and [3].


D1  Commands

A command is any parameterless procedure P that is exported from a module M. It is denoted by M.P and can be activated under this name from the shell of the operating system. In Oberon, a user invokes commands instead of programs or modules. This gives him a finer grain of control and allows modules with multiple entry points. When a command M.P is invoked, the module M is dynamically loaded unless it is already in memory (see D2) and the procedure P is executed. When P terminates, M remains loaded. All global variables and data structures that can be reached from global pointer variables in M retain their values. When P (or another command of M) is invoked again, it may continue to use these values.
	The following module demonstrates the use of commands. It implements an abstract data structure Counter that encapsulates a counter variable and provides commands to increment and print its value.

MODULE Counter;
	IMPORT Texts, Oberon;

	VAR
		counter: LONGINT;
		w: Texts.Writer;

	PROCEDURE Add*;   (* takes a numeric argument from the command line *)
		VAR s: Texts.Scanner;
	BEGIN 
		Texts.OpenScanner(s, Oberon.Par.text, Oberon.Par.pos);
		Texts.Scan(s);
		IF s.class = Texts.Int THEN INC(counter, s.i) END
	END Add;

	PROCEDURE Write*;
	BEGIN
		Texts.WriteInt(w, counter, 5); Texts.WriteLn(w);
		Texts.Append(Oberon.Log, w.buf)
	END Write;

BEGIN counter := 0; Texts.OpenWriter(w)
END Counter.

The user may execute the following two commands:

Counter.Add   n 	adds the value n to the variable counter
Counter.Write 	writes the current value of counter to the screen

Since commands are parameterless they have to get their arguments from the operating system. In general, commands are free to take arguments from everywhere (e.g. from the text following the command, from the most recent selection, or from a marked viewer). The command Add uses a scanner (a data type provided by the Oberon system) to read the value that follows it on the command line.
	When Counter.Add is invoked for the first time, the module Counter is loaded and its body is executed. Every call of Counter.Add n increments the variable counter by n. Every call of Counter.Write writes the current value of counter to the screen.
	Since a module remains loaded after the execution of its commands, there must be an explicit way to unload it (e.g. when the user wants to substitute the loaded version by a recompiled version.) The Oberon system provides a command to do that.


D2  Dynamic Loading of Modules

A loaded module may invoke a command of a still unloaded module by specifying its name as a string. The specified module is then dynamically loaded and the designated command is executed. Dynamic loading allows the user to start a program as a small set of basic modules and to extend it by adding further modules at run time as the need becomes evident.
	A module M0 may cause the dynamic loading of a module M1 without importing it. M1 may of course import and use M0, but M0 need not know about the existence of M1. M1 can be a module that is designed and implemented long after M0.


D3  Garbage Collection

In Oberon, the predeclared procedure NEW is used to allocate data blocks in free memory. There is, however, no way to explicitly dispose an allocated block. Rather, the Oberon environment uses a garbage collector to find the blocks that are not used any more and to make them available for allocation again. A block is in use as long as it can be reached from a global pointer variable via a pointer chain. Cutting this chain (e.g., setting a pointer to NIL) makes the block collectable. 
	A garbage collector frees a programmer from the non-trivial task of deallocating data structures correctly and thus helps to avoid errors. However, it requires information about dynamic data at run time (see D5).


D4  Browser

The interface of a module (the declaration of the exported objects) is extracted from the module by a so-called browser which is a separate tool of the Oberon environment. For example, the browser produces the following interface of the module Trees from Ch. 11.

DEFINITION Trees; 
	TYPE
		Tree = POINTER TO Node;
		Node = RECORD
			name: POINTER TO ARRAY OF CHAR;
			PROCEDURE (t: Tree) Insert (name: ARRAY OF CHAR);
			PROCEDURE (t: Tree) Search (name: ARRAY OF CHAR): Tree;
			PROCEDURE (t: Tree) Write;
		END;
	PROCEDURE Init (VAR t: Tree);
END Trees.

For a record type, the browser also collects all procedures bound to this type and shows their declaration in the record type declaration. 


D5  Run Time Data Structures

Certain information about records has to be available at run time: The dynamic type of records is needed for type tests and type guards. A table with the addresses of the procedures bound to a record is needed for calling them using dynamic binding. Finally, the garbage collector needs information about the location of pointers in dynamically allocated records. All that information is stored in so-called type descriptors of which there is one for every record type at run time. The following paragraphs show a possible implementation of type descriptors.
	The dynamic type of a record corresponds to the address of its type descriptor. For dynamically allocated records this address is stored in a so-called type tag which precedes the actual record data and which is invisible for the programmer. If t is a variable of type CenterTree (see example in Ch. 6) Figure D5.1 shows one possible implementation of the run time data structures.



Fig. D5.1  A variable t of type CenterTree, the record t^ it points to, and its type descriptor

Since both the table of procedure addresses and the table of pointer offsets must have a fixed offset from the type descriptor address, and since both may grow when the type is extended and further procedures and pointers are added, the tables are located at the opposite ends of the type descriptor and grow in different directions.
	A type-bound procedure t.P is called as t^.tag^.ProcTab[IndexP]. The procedure table index of every type-bound procedure is known at compile time. A type test v IS T is translated into v^.tag^.BaseTypes[ExtensionLevelT] = TypeDescrAdrT. Both the extension level of a record type and the address of its type descriptor are known at compile time. For example, the extension level of Node is 0 (it has no base type), and the extension level of CenterNode is 1.


[1]  	N.Wirth, J.Gutknecht: 
	The Oberon System. Software Practice and Experience 19, 9, Sept. 1989
[2]  	M.Reiser: 
	The Oberon System. User Guide and Programming Manual. Addison-Wesley, 1991
[3]	C.Pfister, B.Heeb, J.Templ: 
	Oberon Technical Notes. Report 156, ETH Zrich, March 1991


