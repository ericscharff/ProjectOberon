<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML Level 2.0 2//EN">
<!-- Generated by Text2HTMLGIF (afi, ejz)-->
<HTML>
<HEAD>
<META NAME="Author" CONTENT="Andre Fischer">
<TITLE>Oberon - Programming new gadgets</TITLE>
</HEAD>
<BODY><H1><CENTER>Oberon - Programming new gadgets</CENTER></H1><HR>
<CENTER><B>[ Text | <A HREF="GadgetsProg.Contents.html">Contents</A> | <A HREF="GadgetsProg.Index.html">Index</A> | <A HREF="Big.Index.html">Master index</A>]</B></CENTER><BR>
<BR>
<H1>
<A NAME="0"></A>Objective</H1>
Supply enough information on gadgets programming to enable you to extend Oberon System 3 with new exciting applications.
<P>Estimated time: 90 minutes.
<P><HR>
<H1>
<A NAME="Intro"></A>Introduction</H1>
The Gadgets system builds on the basic Oberon System 3 release by adding special modules and conventions for programming user interfaces. In essence, it introduces a new type of object called a gadget. Gadgets are user interface elements that the user may combine at run-time to build user interfaces. They obey strict protocols allowing them to be embedded in many different applications. The central module is called Gadgets that provides the base classes for the system. The <CALL CMD="Browser.ShowDef Gadgets"><FONT COLOR=FF0000>Gadgets</FONT></CALL> module depends on further modules that provide clipping operations (<CALL CMD="Browser.ShowDef Display3"><FONT COLOR=FF0000>Display3</FONT></CALL> and <CALL CMD="Browser.ShowDef Printer3"><FONT COLOR=FF0000>Printer3</FONT></CALL>), a module to manage attributes (<CALL CMD="Browser.ShowDef Attributes"><FONT COLOR=FF0000>Attributes</FONT></CALL>), and a module for special effects (<CALL CMD="Browser.ShowDef Effects"><FONT COLOR=FF0000>Effects</FONT></CALL>). On top of these modules a hierarchy of modules, each of which implements a new gadget type, exists. Many of these modules are provided standard with Oberon System 3.
<P><HR>
<H1>
<A NAME="Prog"></A>Programming a new gadget type</H1>
Learning how to program gadgets is best done by reading the source code of simple, but fully working examples.
<P>
<A NAME="1"></A>-&nbsp; &nbsp; <CALL CMD="Desktops.OpenDoc Skeleton.Mod"><FONT COLOR=FF0000>Skeleton.Mod</FONT></CALL> is an example of how to program a <A HREF="GadgetsIntro.html#VisualGadget">visual gadget</A>. It implements a small colored block that can be moved, resized, copied, printed and colored.
<P>
<A NAME="2"></A>-&nbsp; &nbsp; <CALL CMD="Desktops.OpenDoc Complex.Mod"><FONT COLOR=FF0000>Complex.Mod</FONT></CALL> is an example of how to program a <A HREF="GadgetsIntro.html#ModelGadget">model gadget</A>. It implements a model gadget for complex numbers.
<P>
<A NAME="3"></A>-&nbsp; &nbsp; <CALL CMD="Desktops.OpenDoc DocumentSkeleton.Mod"><FONT COLOR=FF0000>DocumentSkeleton.Mod</FONT></CALL> is an example of how to program a <A HREF="GadgetsIntro.html#Docum">document gadget</A>. It implements a document that consists of a <A HREF="GadgetsUse.html#Panel">panel</A>, only the color of which is stored.
<P>Each of these three examples can be used as a basis for creating a new, custom and application oriented gadget type: a visual, a model and a document gadget.
<P>When programming a new gadget, you will need the following:
<P>1 -&nbsp; &nbsp; A new type for the new gadget, usually created by extending a existing "base" type. Here is a skeleton for such an extended type declaration:
<P>&nbsp; &nbsp; TYPE
<BR>&nbsp; &nbsp; &nbsp; &nbsp; MyGadget* = POINTER TO MyGadgetDesc;
<BR>&nbsp; &nbsp; &nbsp; &nbsp; MyGadgetDesc* = RECORD (BaseType)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* additional (private) fields *)
<BR>&nbsp; &nbsp; END;
<P>The base type might be for example
<BR>&nbsp; &nbsp; 
<A NAME="4"></A>Gadgets.FrameDesc for a visual gadget
<BR>&nbsp; &nbsp; 
<A NAME="5"></A>Gadgets.ObjDesc for a model gadget
<BR>&nbsp; &nbsp; 
<A NAME="6"></A>Documents.DocumentDesc for a document gadget.
<P>When extending an existing gadget the record type of that gadget is taken as base type. To ensure that the gadget is extensible, both the record and pointer types should be exported.
<P>2 -&nbsp; &nbsp; A <A HREF="#Handler">message handler</A>.
<P>3 -&nbsp; &nbsp; A <A HREF="#NewProc">New procedure</A>.
<P>
<H2>
<A NAME="NewProc"></A>The New procedure</H2>
Creating a new instance of a gadget is like everything else in the Oberon system, done via a command. A module M contains a procedure P whose task is to dynamically allocate a new instance of a certain object type. This is called the object's New procedure. Executing the New procedure M.P (this is often refered to as generator string) causes a new instance of that object type to be created. The new object instance is initialized to a default state and is ready to accept messages (i.e. it is totally functional).
<P>The following is a typical New procedure:
<BR>
<PRE>
   PROCEDURE New*;
      VAR F: MyGadget;
   BEGIN
      NEW(F);
      (* assign message handler *)
      F.handle := MyHandler;
      (* initialize private and inherited fields of F,
         e.g. F.W, F.H for a visual gadget*)
      ...
      (* "export" the newly created gadget *)
      Objects.NewObj := F
   END New;
</PRE>
<BR>
<H2>
<A NAME="Handler"></A>The message handler</H2>
<I>Handler</I> is a standard Oberon message handler type for class <I>Object</I> and message base type <I>ObjMsg </I>(see <CALL CMD="Browser.ShowDef Objects"><FONT COLOR=FF0000>Objects</FONT></CALL>):
<P>Handler = PROCEDURE (obj: Objects.Object; VAR M: Objects.ObjMsg);
<P>In a realistic object-oriented environment, messages are rarely handled completely by the first recipient. Usually, they are passed through a complex network of objects. Thus a handler for a given gadget only handles messages which should be handled differently than in the base type. It passes all other messages on to the handler of the base type (e.g. <I>Gadgets.framehandle</I> for a visual gadget).
<P>
<A NAME="7"></A>There are two important message classes in Gadgets:
<P>
<A NAME="8"></A>-&nbsp; &nbsp; Messages derived from <I>Display.FrameMsg</I>: The frame messages in the <CALL CMD="Browser.ShowDef Display"><FONT COLOR=FF0000>Display</FONT></CALL> module play a central role in interframe communication. These build a communications protocol allowing frames to communicate with each other without knowing about each other's internal working. The latter is crucial if foreign or yet unknown objects are to be integrated into the system and applications need to exchange objects with each other. The <I>FrameMsg</I> is defined as follows:
<BR>
<PRE>
   FrameMsg = RECORD (Objects.ObjMsg)
      F: Frame; (* target frame *)
      x, y, res: INTEGER
   END;
</PRE>
<BR>F plays a central role in the <I>FrameMsg</I>. It determines the 
<A NAME="9"></A>destination, or 
<A NAME="10"></A>target frame of a message. Often the destination frame of a message is unknown. This happens for example when model update messages are broadcast, in which case the F field is set to NIL.
<P>-   Messages not derived from <I>Display.FrameMsg</I>: These messages typically can be sent directly to the receiver object, by calling its handler (<I>obj.handle(obj, msg)</I>). E.g. <I>Objects.AttrMsg</I>
<P>A typical message handler looks like the following:
<BR>
<PRE>
   PROCEDURE MyHandler*(F: Objects.Object; VAR M: Objects.ObjMsg);
   BEGIN
      WITH F: MyGadget DO
         IF M IS Display.FrameMsg THEN
         (* only for visual gadgets - not for model gadgets *)
            WITH M: Display.FrameMsg DO
               IF (M.F = NIL) OR (M.F = F) THEN
                  (* handle messages derived from Display.FrameMsg here:
                     Display.DisplayMsg, Display.ModifyMsg, Display.PrintMsg,
                     Display.SelectMsg, Display.ConsumMsg,
                     Oberon.InputMsg, Oberon.ControlMsg, ... *)
               END
            END
         ELSIF Objects.AttrMsg THEN
            (* get, set and enumerate attributes *)
         ELSIF Objects.FileMsg THEN
            (* load and store of the gadget *)
         ELSIF Objects.CopyMsg THEN
            (* making a copy of the gadget *)
         ELSE (* unknown msg, framehandler might know it *)
            Gadgets.framehandle(F, M)
         END
      END
   END MyHandler;
</PRE><B>
<BR>Remarks:</B>
<P>- When a message is handled only partially or is not handled at all, then the handler of the base type should be called.
<BR>- To ensure that the gadget can later be extended the <I>FrameHandler</I> should be exported.
<BR>- Model gadgets should ignore messages of the <I>Display.FrameMsg</I> family.
<P><HR>
<H1>
<A NAME="11"></A>Messages derived from Display.FrameMsg</H1>

<H2>
<A NAME="12"></A>Display.DisplayMsg</H2>
The <I>DisplayMsg</I> broadcasts a redraw request to a single or all frames. It is defined as follows:
<BR>
<PRE>
   DisplayMsg = RECORD (Display.FrameMsg)
      id: INTEGER; (* frame, area *)
      u, v, w, h: INTEGER
   END;
</PRE>
<BR>When the destination (<I>F</I>) is NIL, all frames are implied. When <I>id</I> is set to <I>Display.area</I>, the area <I>u, v, w, h</I> inside the destination frame should be redrawn. These coordinates are relative to the upper-left corner of the destination gadget (thus v is normally negative).
<P>
<A NAME="13"></A>&nbsp; &nbsp; A special display mask data structure (<I>Display3.Mask</I>) is used to indicate which areas of a gadget are visible. It is specified as a set of non-overlapping rectangles. Drawing primitives are issued through this mask, which has the effect of clipping them to only the visible areas of the gadget.
<P>Handling the Display.DisplayMsg therefore might look as follows:
<BR>
<PRE>
   IF (M.F = NIL) OR (M.F = F) THEN (* message addressed to this frame *)
      (* calculate display coordinates *)
      x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H;
      IF M IS Display.DisplayMsg THEN
         WITH M: Display.DisplayMsg DO
            IF (M.id = Display.frame) OR (M.F = NIL) THEN
               Gadgets.MakeMask(F, x, y, M.dlink, R);
               RestoreFrame(F, R, x, y, w, h)
            ELSIF M.id = Display.area THEN
               Gadgets.MakeMask(F, x, y, M.dlink, R);
               Display3.AdjustMask(R, x + M.u, y + h - 1 + M.v, M.w, M.h);
               RestoreFrame(F, R, x, y, w, h)
            END
         END
      ELSIF ...
</PRE><B>
<BR>Remarks:</B>
<P>- Gadgets are usually rectangular, their size being described by <I>F.W</I> and <I>F.H</I>. <I>x</I>, <I>y</I> are the coordinates of the lower-left corner of the rectangle.
<BR>- Normally the drawing routines of the <CALL CMD="Browser.ShowDef Display3"><FONT COLOR=FF0000>Display3</FONT></CALL> module are used to draw a gadget.
<P>
<H2>
<A NAME="14"></A>Display.PrintMsg</H2>
This is a request to a frame to print itself. It is defined as follows:
<BR>
<PRE>
   PrintMsg = RECORD (Display.FrameMsg)
      id: INTEGER; (* contents, view *)
      pageno: INTEGER
   END;
</PRE>
<BR>A whole tree of gadgets is implied when the destination is NIL. When the <I>id</I> is set to <I>view</I>, the frame has to print itself in the form it looks on the display. When the <I>id</I> is set to <I>contents</I> it should print its complete contents (for example a text that it may be displaying). By convention, the <I>x, y</I> coordinates indicate the absolute printer coordinates of the lower-left corner of the frame. The frame may assume that the printer driver has been initialized already.
<P>Printing can also be done with clipping masks. All the primitives available for display masks (<CALL CMD="Browser.ShowDef Display3"><FONT COLOR=FF0000>Display3</FONT></CALL>), are also available for printing (<CALL CMD="Browser.ShowDef Printer3"><FONT COLOR=FF0000>Printer3</FONT></CALL>). One major difference is that printing masks are stored using printer coordinates. Just like for display masks, a special routine is provided to calculate the print mask of a gadget (<I>Gadgets.MakePrinterMask</I>).
<P>
<H2>
<A NAME="15"></A>Oberon.InputMsg</H2>
This message sends mouse and keyboard input to frames. It is defined as follows:
<BR>
<PRE>
   InputMsg = RECORD (Display.FrameMsg)
      id: INTEGER; (* track, consume *)
      keys: SET;
      X, Y: INTEGER;
      ch: CHAR;
      fnt: Fonts.Font;
      col, voff: SHORTINT
   END;
</PRE>
<BR>
<H3>
<A NAME="16"></A>Tracking the mouse</H3>
When the Oberon event loop senses a mouse movement or that a mouse button has been pressed, it sends a <I>track message</I> (<I>id = Oberon.track</I>) to the affected viewer. The gadget can do whatever it pleases, when it receives a <I>track message</I>. However if possible it should abide by the <A HREF="GadgetsIntro.html#MouseKey">Oberon conventions</A>.
<P>Normally, gadgets have a control border in which the gadgets respond to mouse combinations for resize, move, delete and copy. These mouse combinations are handled by <I>Gadgets.framehandle</I>, so the mouse has to be tracked only inside the working area of the gadgets. <I>Gadgets.InActiveArea</I> checks whether or not the mouse is inside the working area.
<P>Mouse clicks are normally recorded in a tracking loop. In this loop, the mouse driver is read directly and interclicks are recorded. The loop terminates when all three buttons are up again.
<P>Thus mouse tracking may be programmed as follows:
<BR>
<PRE>
   PROCEDURE MyHandler*(F: Objects.Object; VAR M: Objects.ObjMsg);
      ...
      ELSIF M IS Oberon.InputMsg THEN
         WITH M: Oberon.InputMsg DO
            IF (M.id = Oberon.Track) &amp; Gadgets.InActiveArea(F, M) THEN
               TrackMouse(F, M.X, M.Y, M.keys)
      ...
   END MyHandler;

   PROCEDURE TrackMouse(F: MyGadget; VAR X, Y: INTEGER; VAR keysum: SET);
      VAR keys: SET;
   BEGIN
      keys := keysum;
      WHILE keys # {} DO
         Effects.TrackMouse(keys, X, Y, Effects.Arrow);
         keysum := keysum+keys
      END;
      IF keysum = Effects.middle THEN
         (* execute F *)
      ELSIF ...
   END TrackMouse;
</PRE>
<BR>
<H3>
<A NAME="ProgCaret"></A>Programming a caret</H3>
When a keyboard key is pressed, a <I>consume message</I> (<I>id = Oberon.consume)</I> is broadcast. However since the Oberon event loop does not know in which frame the <A HREF="Mouse.html#Insertion">caret</A> is currently set, the recipient of the message is unknown (<I>F = NIL</I>). Only the frame containing the caret should consume the character.
<P>A gadget implementing a caret typically has a BOOLEAN field indicating whether or not the caret is set. Thus the definition for MyGadgetDesc may look as follows:
<BR>
<PRE>
   MyGadgetDesc* = RECORD (Gadgets.Frame)
      caret: BOOLEAN;
      (* other data *)
   END
</PRE>
<BR>The <I>caret</I> field is initialized to FALSE in the <A HREF="#NewProc">New procedure</A>. The handling of the caret could then be implemented as follows:
<BR>
<PRE>
   PROCEDURE MyHandler*(F: Objects.Object; VAR M: Objects.ObjMsg);
      VAR x, y, w, h: INTEGER;
   BEGIN
      WITH F: MyGadget DO
         IF M IS Display.FrameMsg THEN
         (* Display.FrameMsg messages *)
            WITH M: Display.FrameMsg DO
               IF (M.F = NIL) OR (M.F = F) THEN
                  (* calculate display coordinates *)
                  x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H;
                  IF M IS Display.DisplayMsg THEN
                  ...
                  ELSIF M IS Oberon.InputMsg THEN
                     WITH M: Oberon.InputMsg DO
                        IF M.id = Oberon.track THEN
                           IF (M.keys = {Effects.left}) &amp; Gadgets.InActiveArea(F, M) THEN
                              IF ~F.caret THEN
                                 Oberon.Defocus();
                                 F.caret := TRUE
                              END;
                              SetCaret(F, x, y)
                           ...
                           END
                        ELSIF (M.id = Oberon.consume) &amp; F.caret THEN
                           ConsumeChar(F, M.ch);
                           M.res := 0
                        ...
                        END
                     END
                  ELSIF M IS Oberon.ControlMsg THEN
                     WITH M: Oberon.ControlMsg DO
                        IF M.id IN {Oberon.defocus, Oberon.neutralize} THEN
                           IF F.caret THEN
                              F.caret := FALSE;
                              RemoveCaret(F)
                           END
                        ...
                        END
                     END
                  ...
                  END
               END (* IF (M.F = NIL) OR (M.F = F) *)
            END (* WITH M: Display.FrameMsg *)
         (* other messages *)
         END
      END
   END MyHandler;
</PRE>
<BR>
<H2>
<A NAME="17"></A>Oberon.ControlMsg</H2>
This message changes the state of a gadget. It is defined as follows:
<BR>
<PRE>
   ControlMsg = RECORD (Display.FrameMsg)
      id: INTEGER; (* defocus, neutralize, mark *)
      X, Y: INTEGER
   END;
</PRE>
<BR>When the destination (<I>F</I>) is NIL, all frames are implied. When <I>id</I> is set to <I>Oberon.defocus</I>, then the gadget should remove its caret. If <I>id</I> is set to <I>Oberon.neutralize</I>, then the gadget should remove all marks it contains (caret and selection). See <A HREF="#ProgCaret">Programming a caret</A> for an example of how this message is used.
<P><HR>
<H1>
<A NAME="18"></A>Objects messages</H1>
The messages of the <CALL CMD="Browser.ShowDef Objects"><FONT COLOR=FF0000>Objects</FONT></CALL> module are common to all gadgets.
<P>
<H2>
<A NAME="AttrMsg"></A>Objects.AttrMsg</H2>
In Oberon System 3, object <A HREF="GadgetsOberon.html#AttrMsg">attribute management</A> is done strictly by sending <I>Objects.AttrMsg</I> messages to objects.
<P>Typically, for our case study example, you would handle these messages as follows:
<BR>
<PRE>
   PROCEDURE MyHandler*(F: Objects.Object; VAR M: Objects.ObjMsg);
      ...
      ELSIF M IS Objects.AttrMsg THEN THEN
         WITH M: Objects.AttrMsg DO
            IF M.id = Objects.get THEN
            <IMG ALT="Cool Oberon Object " SRC="images/GadgetsProg1.gif" OBJECT="GadgetsProgObjs.0">
               IF M.name = "Gen" THEN
                  M.class := Objects.String;
                  M.s := "MyGadget.New");
                  M.res := 0
               ELSIF M.name = "Color" THEN
                  M.class := Objects.Int;
                  M.i := F.mycol;
                  M.res := 0
               ELSE Gadgets.framehandle(F, M)
               END
            ELSIF M.id = Objects.set THEN
               IF M.name = "Color" THEN
               <IMG ALT="Cool Oberon Object " SRC="images/GadgetsProg2.gif" OBJECT="GadgetsProgObjs.4">
                  IF M.class = Objects.Int THEN
                     F.mycol := SHORT(M.i);
                     M.res := 0
                  ELSIF M.class = Objects.String THEN   (2a)
                     Attributes.StrToInt(M.s, M.i);
                     F.mycol := SHORT(M.i);
                     M.res := 0
                  (*   ELSE   ignore *)                     (2b)
                  END
               ELSE Gadgets.framehandle(F, M)
               END
            ELSIF M.id = Objects.enum THEN      (3)
               M.Enum("Color");
               Gadgets.framehandle(F, M)
            END
         END
      ...
   END MyHandler;
</PRE><B>
<BR>Comments:</B>
<P>The object must only handle the attributes that have been added to the base type. The other attributes are processed by the base type handler.
<P>(1) <I>id=Objects.get</I>, return the value of a named attribute. Each object should as a minimum handle the "Gen" attribute, i.e. return the <A HREF="#NewProc">New procedure</A> string.
<P>(2) <I>id=Objects.set</I>, change the value of a named attribute.
<P>(3) <I>id=Objects.enum</I>, enumerate each attribute by calling <I>M.Enum</I>(extended attribute) repeatedly.
<P>
<H2>
<A NAME="19"></A>Objects.FileMsg</H2>
The purpose of <I>FileMsg</I> messages is to load and store objects from and to a sequential file.
<BR>
<PRE>
   FileMsg = RECORD (ObjMsg)
    id: INTEGER; (* id = load, store *)
    len: LONGINT;
    R: Files.Rider
   END;
</PRE>
<BR>Typically, for our case study example, you would handle these messages as follows:
<BR>
<PRE>
   PROCEDURE MyHandler*(F: Objects.Object; VAR M: Objects.ObjMsg);
      ...
      ELSIF M IS Objects.FileMsg THEN
         WITH M: Objects.FileMsg DO
            IF M.id = Objects.store THEN         (1)
               Files.WriteInt(M.R, F.mycol)
            ELSIF M.id = Objects.load THEN      (2)
               Files.ReadInt(M.R, F.mycol)
            END;
            Gadgets.framehandle(F, M)
         END
      ...
   END MyHandler;
</PRE><B>
<BR>Comments:</B>
<P>The object must only handle the attributes that have been added to the base type. The other attributes are processed by the base type handler.
<P>(1) <I>id=Objects.load</I>, the object is requested to store its data to the file specified by the rider <I>M.R</I>.
<BR>(2) <I>id=Objects.store,</I> then the object is requested to load its data from the file specified by the rider <I>M.R.</I>
<P>To keep loading and storing of objects portable among the different Oberon platforms, use the procedures of the <CALL CMD="Browser.ShowDef Files"><FONT COLOR=FF0000>Files</FONT></CALL> module which read and write the different Oberon basic types (e.g. WriteInt, WriteString, ...).
<P>
<H2>
<A NAME="20"></A>Objects.CopyMsg</H2>
Messages of type CopyMsg are used to create an exact copy of a given object.
<BR>
<PRE>
   CopyMsg = RECORD (ObjMsg)
      id: INTEGER; (* id = shallow | deep *)
      obj: Object
   END;
</PRE>
<BR>We distinguish between <I>shallow</I> and <I>deep</I> copies. When a shallow copy has to be created, as many references to original components as possible are left unresolved, whereas in the case of a deep copy, all references are resolved by recursively creating copies of the components. Note that, in both cases, the copy message is at least passed through a part the entire data structure representing the original object.
<P>Objects.CopyMsg:
<BR>
<PRE>
   PROCEDURE MyHandler*(F: Objects.Object; VAR M: Objects.ObjMsg);
      VAR F1: Frame;
      ...
      ELSIF M IS Objects.CopyMsg THEN
         WITH M: Objects.CopyMsg DO
            IF M.stamp = F.stamp THEN M.obj := F.dlink
               (* Copy message arrives again *)
            ELSE
               (* First time copy message arrives *)
               NEW(F1);
               F.stamp := M.stamp;   (1)
               F.dlink := F1;
               (* Copy private data *)
               F1.mycol := F.mycol;
               ...
               (* Copy data of base type *)
               Gadgets.CopyFrame(M, F, F1);
               M.obj := F1
            END
         END
      ...
   END MyHandler;
</PRE><B>
<BR>Comments:</B>
<P>(1) The same copy message may arrive more then once. The time stamp field is thus used to detect if a copy of the object has already been made.
<P><HR>
<H1>
<A NAME="21"></A>Programming a new document type</H1>

<H2>
<A NAME="22"></A>Load and store a document</H2>
Documents need not to handle messages of the type <I>Objects.FileMsg</I>. Loading and storing of documents is done by the two procedure variable fields <I>Load</I> and <I>Store</I> of its base type (<I>Documents.Document</I>).
<BR>Thus the New procedure for a document looks as follows:
<BR>
<PRE>
   PROCEDURE NewDoc*;
      VAR D: Documents.Document;
   BEGIN
      NEW(D);
      (* assign procedures *)
      D.Load := Load;
      D.Store := Store;
      D.handle := DocHandler;
      D.W := 250; D.H := 200;
      Objects.NewObj := D
   END NewDoc;
</PRE>
<BR>Where Load is defined as follows:
<BR>
<PRE>
   PROCEDURE Load(D: Documents.Document);
      VAR
         obj: Objects.Object;
         tag, x, y, w, h: INTEGER;
         name: ARRAY 64 OF CHAR;
         F: Files.File; R: Files.Rider;
   BEGIN
      (* create a child gadget for the document *)
      obj := Gadgets.CreateObject("Panels.NewPanel");
      WITH obj: Gadgets.Frame DO
         x := 0; y := 0; w := 250; h := 200;
         F := Files.Old(D.name);
         IF F # NIL THEN
            Files.Set(R, F, 0);
            Files.ReadInt(R, tag);
            IF tag = Documents.Id THEN
               Files.ReadString(R, name);
               Files.ReadInt(R, x); Files.ReadInt(R, y);
               Files.ReadInt(R, w); Files.ReadInt(R, h);
               (* read data specific to this document type *)
               ...
            ELSE
               (* not a document header,
               create an empty child (obj), D.name := &lt;new doc> *)
            END
         ELSE
            (* create an empty child (obj), D.name := &lt;new doc> *) 
         END;
         D.X := x; D.Y := y; D.W := w; D.H := h;
         Documents.Init(D, obj)
      END
   END Load;
</PRE><B>
<BR>Remarks:</B>
<P>- All document files have a header consisting of tag, name, x, y, w and h.
<BR>- The child gadget needs not to be a panel, any gadget can be used.
<P>Where Store is defined as follows:
<BR>
<PRE>
   PROCEDURE Store(D: Documents.Document);
      VAR
         obj: Gadgets.Frame;
         F: Files.File;
         R: Files.Rider;
   BEGIN
      (* get the child gadget *)
      obj := D.dsc(Gadgets.Frame);
      F := Files.New(D.name);
      Files.Set(R, F, 0);
      (* write the document header *)
      Files.WriteInt(R, Documents.Id);
      Files.WriteString(R, &lt;gen string of this document type>);
      Files.WriteInt(R, D.X); Files.WriteInt(R, D.Y);
      Files.WriteInt(R, D.W); Files.WriteInt(R, D.H);
      (* write data specific to this document type *)
      ...
      Files.Register(F)
   END Store;
</PRE>
<BR>
<H2>
<A NAME="23"></A>Special attributes of a document</H2>
Compared to all other gadgets, documents have three additional read-only attributes (see <A HREF="#AttrMsg">Objects.AttrMsg</A>):
<P>
<A NAME="24"></A>-&nbsp; &nbsp; Menu: String attribute which specifies the contents of the <A HREF="GadgetsIntro.html#DocMenuBar">menu bar</A>. The syntax for this string is:
<BR>
<PRE>
   menu = { command [ "[" caption "]" ] " " }.
   command = moduleName "." commandName.
   caption = string.
</PRE>
<BR>
<A NAME="25"></A>-&nbsp; &nbsp; Icon: String attribute which specifies the icon to be used, when the document is iconized with <A HREF="GadgetsIntro.html#DeskMake">Desktops.MakeIcons *</A> . The string gives the full name of a picture in the <CALL CMD="Desktops.OpenDoc Icons.Lib"><FONT COLOR=FF0000>Icons.Lib</FONT></CALL>.
<P>
<A NAME="26"></A>-&nbsp; &nbsp; Adaptive: Boolean attribute which specifies whether a document should dynamically change its size, when opened as Oberon viewer.
<BR>
<PRE>
   PROCEDURE DocHandler(D: Objects.Object; VAR M: Objects.ObjMsg);
   BEGIN
      WITH D: Documents.Document DO
         IF M IS Objects.AttrMsg THEN
            WITH M: Objects.AttrMsg DO
               IF M.id = Objects.get THEN
                  IF M.name = "Gen" THEN
                     M.class := Objects.String;
                     M.s := &lt;gen string of this document type>; M.res := 0
                  ELSIF M.name = "Adaptive" THEN
                     M.class := Objects.Bool; M.b := TRUE; M.res := 0
                  ELSIF M.name = "Icon" THEN
                     M.class := Objects.String; M.s := "Icons.Tool"; M.res := 0
                  ELSIF M.name = "Menu" THEN
                     M.class := Objects.String;
                     M.s := "Desktops.StoreDoc[Store]"; M.res := 0
                  ELSE Documents.Handler(D, M)
                  END
               ELSE Documents.Handler(D, M)
               END
            END
         ...
         ELSE Documents.Handler(D, M)
         END
      END
   END DocHandler;
</PRE>
<BR>
<H2>
<A NAME="27"></A>Displaying a document</H2>
Normally there is no need to explicitly handle the <I>Display.DisplayMsg</I> and <I>Display.ModifyMsg</I> messages. <I>Documents.Handler</I> is responsible for delegating these messages to the menu bar and the child gadgets. However, if e.g. the size of the document is limited to a minimal or maximal size, the <I>Display.ModifyMsg</I> message may be changed before calling <I>Documents.Handler</I>.
<BR>
<HR>
<BR>Revised on July 23, 1996<BR>Installed on 14 Feb 1997<HR></BODY>
</HTML>

