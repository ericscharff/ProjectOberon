<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML Level 2.0 2//EN">
<!-- Generated by Text2HTMLGIF (afi, ejz)-->
<HTML>
<HEAD>
<META NAME="Author" CONTENT="Andre Fischer">
<TITLE>Browser and Watson User's Guide</TITLE>
</HEAD>
<BODY><H1><CENTER>Browser and Watson User's Guide</CENTER></H1><HR>
<CENTER><B>[ Text | <A HREF="Watson.Contents.html">Contents</A> | <A HREF="Watson.Index.html">Index</A> | <A HREF="Big.Index.html">Master index</A>]</B></CENTER><BR>
<BR>
<H1>
<A NAME="0"></A>Tutorial objective</H1>
Learn how to obtain module information using the browser or the even smarter browser Watson and its companion panel Watson.Panel. Also learn to create definition modules documenting your own system extensions.
<P>Estimated time: 20 minutes.
<P><HR>
<H1>
<A NAME="1"></A>Definition module</H1>
A <I>definition module</I> describes a module interface and is a summary of the complete module. It contains the declaration of the exported names which may be used by other modules. It also known as the <I>public view</I> of the module and its advantage is its textual compactness. With this clearly defined module interface, a module can be used without knowledge of how it is implemented. Also, at construction time a module can be defined without knowledge of how it will be used in the future.
<P>In Oberon, it is not necessary to write down the definition of a module: the browser and Watson are two software development tools that take care of extracting the necessary information from the module. In the following, it will be explained wherefrom the information is collected.
<P><HR>
<H1>
<A NAME="2"></A>Introducing the browser</H1>

<BR>The primary tool for retrieving a module definition is the browser. Look for example at the <I>definition module</I> of the compiler: <FONT COLOR=FF0000>Browser.ShowDef Compiler</FONT>.<HR>
<H1>
<A NAME="3"></A>Using the browser</H1>

<BR>The browser exports only two commands which are documented in the <CALL CMD="Desktops.OpenDoc Browser.Tool"><FONT COLOR=FF0000>Browser.Tool</FONT></CALL> and are described below.The browser for the OMEGA version exports only the command "Browser.ShowDef".
<P>
<H2>
<A NAME="browserO"></A>Show module definition - Browser.ShowDef</H2>
<B>Browser.ShowDef (modName | ^) [\[d][e]]</B> opens a document viewer named "modName.Def" displaying the definition of the named module. Only the first name part in <B>modName</B> is used. The definition is constructed using the symbol information contained in the compiled object file <B>modName</B>.Obj or respectively in the symbol file <B>modName</B>.Sym. The options are:
<BR>
<UL>
<BR>
<LI><B>d</B>: show <B>d</B>etailed information, that is: record size and offset of fields in records, entry number of exported variables and procedures.
<LI><B>e</B>: <B>e</B>xpand base types (recursive application of the browser)</UL>
<BR>Examples:
<BR>&nbsp; &nbsp; &nbsp; &nbsp; Browser.ShowDef Outlines.Tool - (* only the first name part is used. *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; Browser.ShowDef Outlines.Obj\d
<BR>&nbsp; &nbsp; &nbsp; &nbsp; Browser.ShowDef Outlines\e
<BR>&nbsp; &nbsp; &nbsp; &nbsp; Browser.ShowDef Outlines\de
<P>
<H2>
<A NAME="4"></A>Show object definition - Browser.ShowObj (not in OMEGA)</H2>
<B>Browser.ShowObj (modName.objName | ^) [\[d][e]]</B> opens a document viewer named "modName.objName" displaying the definition of a specific object <B>objName</B> in the module <B>modName</B> (only the first name part is used). The options are the same and the definition is constructed in the same manner as for Browser.ShowDef.
<P>Example: Browser.ShowObj Display.Frame\d 
<P><HR>
<H1>
<A NAME="5"></A>Introducing Watson</H1>
Watson uses a special strategy for extracting a module definition from various information sources: definition file, module file or marked module text, symbol information, object file, and although not in direct relation, tutorial document. The search strategy is defined by the <A HREF="#search">Search order</A> but it can also be modified on demand. Watson is in essence a "smart" browser with extended capabilities making it indispensable in complex software development projects.
<P>Some of its extra capabilities are:
<BR>
<OL>
<BR>
<LI>The module definition can be constructed from the (source) module text. In that case, Watson extracts three additional information elements from the text and includes them in the definition text:
<OL>
<LI>exported comments of the form (** any comment *)
<LI>references to tutorials in the form of interspersed comments like:&nbsp; &nbsp; (*L Tutorial.Label *)
<LI>the pre- or the post-conditions and their trap number found in ASSERT statements. The ASSERT statement text must adhere to the following convention:&nbsp; &nbsp; 100 &lt;= trap &lt; 110 : pre-condition&nbsp; &nbsp; 120 &lt;= trap &lt; 130 : post-conditionNote that Watson removes the export marks (*) but not the read-only marks (-).</OL>
<P>
<LI>The definition text is a hypertext with hyperlinks of different meanings indicated in different colors:
<OL>
<LI>Imported modules appear in <B>red</B>. Such a hyperlink displays a module definition.
<LI>Types and constants appear in <B>blue</B>. Such a hyperlink displays an object definition or moves to the location of its definition in the current definition text.
<LI>Tutorial or document names appear in <B>green</B>. Such a hyperlink opens a tutorial at a defined point, where an explanatory text is provided.</OL>
<P>
<LI>The definition module may be a HTML text which can be viewed with any commercially available Web browser or with the Oberon Web browser. In that case hovewer, all hypertext links will appear in the same color.</OL>
<BR>
<H2>
<A NAME="6"></A>Sample module</H2>
MODULE Items;    (** PS <IMG ALT="Cool Oberon Object " SRC="images/Watson1.gif" OBJECT="WatsonObjs.0"> *)
<BR>&nbsp; &nbsp; IMPORT Obj := Objects, Texts;
<P>CONST
<BR>&nbsp; &nbsp; &nbsp; &nbsp; (** Maximum number of items in array *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; MaxItems* = 12;
<BR>&nbsp; &nbsp; &nbsp; &nbsp; (** Name size *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; NameLen = 32;
<BR>&nbsp; &nbsp; TYPE
<BR>&nbsp; &nbsp; &nbsp; &nbsp; Name* = ARRAY NameLen OF CHAR;
<P>&nbsp; &nbsp; &nbsp; &nbsp; (*L Watson.HELPITEM *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; (** Item is an object with a name and a color *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; Item* = POINTER TO ItemDesc;
<BR>&nbsp; &nbsp; &nbsp; &nbsp; ItemDesc* = RECORD (Obj.ObjDesc)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name-: Name; (** Name of the item *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col: INTEGER
<BR>&nbsp; &nbsp; &nbsp; &nbsp; END;
<BR>&nbsp; &nbsp; VAR
<BR>&nbsp; &nbsp; &nbsp; &nbsp; items-: ARRAY MaxItems OF Item; (** Array of items - Read-only *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; defaultCol*: INTEGER; (** Default color of an item *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; W: Texts.Writer; (* A writer *)
<P>&nbsp; &nbsp; (** Get the color of a given item *)
<BR>&nbsp; &nbsp; PROCEDURE GetColor*(item: Item; VAR col: INTEGER);
<BR>&nbsp; &nbsp; BEGIN
<BR>&nbsp; &nbsp; &nbsp; &nbsp; ASSERT(item # NIL, 100);
<BR>&nbsp; &nbsp; &nbsp; &nbsp; col := item.col
<BR>&nbsp; &nbsp; END GetColor;
<P>&nbsp; &nbsp; (** Create an item *)
<BR>&nbsp; &nbsp; PROCEDURE MakeItem*(VAR item: Item; name: Name; col:INTEGER);
<BR>&nbsp; &nbsp; BEGIN
<BR>&nbsp; &nbsp; &nbsp; &nbsp; NEW(item); item.col := col;
<BR>&nbsp; &nbsp; &nbsp; &nbsp; COPY(name, item.name);
<BR>&nbsp; &nbsp; &nbsp; &nbsp; ASSERT(item # NIL, 120)
<BR>&nbsp; &nbsp; END MakeItem;
<P>&nbsp; &nbsp; (** Insert an item in the array *)
<BR>&nbsp; &nbsp; PROCEDURE InsertItem*(item: Item);
<BR>&nbsp; &nbsp; &nbsp; &nbsp; VAR i: INTEGER;
<BR>&nbsp; &nbsp; BEGIN
<BR>&nbsp; &nbsp; &nbsp; &nbsp; ASSERT(item # NIL, 101);
<BR>&nbsp; &nbsp; &nbsp; &nbsp; i := 0;
<BR>&nbsp; &nbsp; &nbsp; &nbsp; LOOP
<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IF i = MaxItems THEN EXIT END;
<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IF items[i] = NIL THEN items[i] := item; EXIT END;
<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INC(i)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; END
<BR>&nbsp; &nbsp; END InsertItem;
<P>&nbsp; &nbsp; (** Delete an item in the array *)
<BR>&nbsp; &nbsp; PROCEDURE DeleteItem*(itemNr: INTEGER);
<BR>&nbsp; &nbsp; BEGIN
<BR>&nbsp; &nbsp; &nbsp; &nbsp; ASSERT((0 &lt;= itemNr) &amp; (itemNr &lt; MaxItems), 100);
<BR>&nbsp; &nbsp; &nbsp; &nbsp; items[itemNr] := NIL
<BR>&nbsp; &nbsp; END DeleteItem;
<P>BEGIN
<BR>&nbsp; &nbsp; Texts.OpenWriter(W); defaultCol := 15
<BR>END Items.
<P>Select the module text and copy it into a new empty viewer which you may name "Items.Mod" for instance. Compile the module with:
<P>&nbsp; &nbsp; <CALL CMD="Builder.Compile /s Items.Mod"><FONT COLOR=FF0000>Builder.Compile /s Items.Mod</FONT></CALL> and show the definition of Items with:
<P>&nbsp; &nbsp; <CALL CMD="Watson.ShowDef Items"><FONT COLOR=FF0000>Watson.ShowDef Items</FONT></CALL>
<P>Here is the definition text which an Oberon user will obtain. It is reproduced below to the attention of those who are browsing the tutorial on the Web.
<P>
<BR>&nbsp; &nbsp; DEFINITION Items; (* PS <IMG ALT="Cool Oberon Object " SRC="images/Watson2.gif" OBJECT="WatsonObjs.1"> *)
<P>&nbsp; &nbsp; IMPORT <FONT COLOR=FF0000>Objects</FONT><IMG ALT="Cool Oberon Object " SRC="images/Watson3.gif" OBJECT="WatsonObjs.2"></FONT>;
<P>&nbsp; &nbsp; CONST
<BR>&nbsp; &nbsp; &nbsp; &nbsp; (* Maximum number of items in array *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; MaxItems<IMG ALT="Cool Oberon Object " SRC="images/Watson4.gif" OBJECT="WatsonObjs.3"> = 12;
<BR>&nbsp; &nbsp; &nbsp; &nbsp; (* Name size *)
<P>&nbsp; &nbsp; TYPE
<BR>&nbsp; &nbsp; &nbsp; &nbsp; Name<IMG ALT="Cool Oberon Object " SRC="images/Watson5.gif" OBJECT="WatsonObjs.4"> = ARRAY 32 OF CHAR;
<P>&nbsp; &nbsp; &nbsp; &nbsp; (* Item is an object with a name and a color *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; <FONT COLOR=00FF33>Item</FONT><IMG ALT="Cool Oberon Object " SRC="images/Watson6.gif" OBJECT="WatsonObjs.5"></FONT> = POINTER TO ItemDesc</FONT><IMG ALT="Cool Oberon Object " SRC="images/Watson7.gif" OBJECT="WatsonObjs.6">;
<BR>&nbsp; &nbsp; &nbsp; &nbsp; ItemDesc = RECORD( Objects.ObjDesc&nbsp; &nbsp;  ) 
<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name-: Name</FONT><IMG ALT="Cool Oberon Object " SRC="images/Watson8.gif" OBJECT="WatsonObjs.7">; (* Name of the item *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; END;
<P>&nbsp; &nbsp; VAR
<BR>&nbsp; &nbsp; &nbsp; &nbsp; items<IMG ALT="Cool Oberon Object " SRC="images/Watson9.gif" OBJECT="WatsonObjs.8">-: ARRAY MaxItems</FONT><IMG ALT="Cool Oberon Object " SRC="images/Watson10.gif" OBJECT="WatsonObjs.9"> OF Item</FONT><IMG ALT="Cool Oberon Object " SRC="images/Watson11.gif" OBJECT="WatsonObjs.10">; (* Array of items - Read-only *)
<BR>&nbsp; &nbsp; &nbsp; &nbsp; defaultCol<IMG ALT="Cool Oberon Object " SRC="images/Watson12.gif" OBJECT="WatsonObjs.11">: INTEGER; (* Default color of an item *)
<P>&nbsp; &nbsp; (* Get the color of a given item *)
<BR>&nbsp; &nbsp; PROCEDURE GetColor<IMG ALT="Cool Oberon Object " SRC="images/Watson13.gif" OBJECT="WatsonObjs.12"> (item: Item</FONT><IMG ALT="Cool Oberon Object " SRC="images/Watson14.gif" OBJECT="WatsonObjs.13">; VAR col: INTEGER);<I></I>
<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>(* precondition (100):</I> item # NIL<I> *)</I>
<P>&nbsp; &nbsp; (* Create an item *)
<BR>&nbsp; &nbsp; PROCEDURE MakeItem<IMG ALT="Cool Oberon Object " SRC="images/Watson15.gif" OBJECT="WatsonObjs.14"> (VAR item: Item</FONT><IMG ALT="Cool Oberon Object " SRC="images/Watson16.gif" OBJECT="WatsonObjs.15">; name: Name</FONT><IMG ALT="Cool Oberon Object " SRC="images/Watson17.gif" OBJECT="WatsonObjs.16">; col: INTEGER);<I></I>
<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>(* postcondition (120):</I> item # NIL<I> *)</I>
<P>&nbsp; &nbsp; (* Insert an item in the array *)
<BR>&nbsp; &nbsp; PROCEDURE InsertItem<IMG ALT="Cool Oberon Object " SRC="images/Watson18.gif" OBJECT="WatsonObjs.17"> (item: Item</FONT><IMG ALT="Cool Oberon Object " SRC="images/Watson19.gif" OBJECT="WatsonObjs.18">);<I></I>
<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>(* precondition (101):</I> item # NIL<I> *)</I>
<P>&nbsp; &nbsp; (* Delete an item in the array *)
<BR>&nbsp; &nbsp; PROCEDURE DeleteItem<IMG ALT="Cool Oberon Object " SRC="images/Watson20.gif" OBJECT="WatsonObjs.19"> (itemNr: INTEGER);<I></I>
<BR>&nbsp; &nbsp; &nbsp; &nbsp; <I>(* precondition (100):</I> (0 &lt;= itemNr) &amp; (itemNr &lt; MaxItems)<I> *)</I>
<P>END Items.
<P>Clicking on the green spot causes this document to open here:
<BR>
<A NAME="HELPITEM"></A><B>Meaning of "Item"</B>
<P>Item is a simple object with a name and a color attribute. It has no real function or purpose but is nevertheless a realistic example.
<P><HR>
<H1>
<A NAME="7"></A>Using the Watson panel</H1>

<BR>Open the Watson panel with:&nbsp; &nbsp; &nbsp; &nbsp; <FONT COLOR=FF0000>Desktops.OpenDoc Watson.Panel</FONT>
<P>This graphical user interface features a number of command buttons, controlled by the settings in the Setup iconizer, and by check boxes appearing in the lower part.
<P>
<H2>
<A NAME="8"></A>Setting the options with Setup</H2>
To adjust the settings to your preferences, click on the little square at the left top of the iconizer to flip it. Enter the appropriate values in the various fields as described hereafter. When the settings are adequate, click the [Save settings] button, and click on the little square of the iconizer to return it to its original position. 
<A NAME="9"></A>These settings are saved in the Watson library <B>Watson.Lib</B>.
<P>
<A NAME="search"></A><B>Search order:</B> This text field contains a string of up to five capital letters which determines the order, from left to right, in which the various information sources are consulted for creating a definition text. Each source is represented by a capital letter with the following meaning:
<P><B>D:</B> an existing <B>d</B>efinition text is used. The definition text is searched in a definition module (.Def) or in the archive specified in the text field "Def Archive". The name of a definition module must have the suffix ".Def" - see <A HREF="#MAKEDEFS">Make definitions</A>.<B>
<BR>M:</B> the text of a <B>m</B>odule is used to create the definition module. The text may be contained in a module file or in a marked viewer.<B>
<BR>S:</B> the symbol information in a <B>s</B>ymbol file (.Sym) or respectively in an object file is used to create the definition text.<B>
<BR>C:</B> the information in an object file is used to create the definition text. Only the definition of commands will appear in this case. It is equivalent to what is obtained with a System.ShowCommands command.<B>
<BR>T:</B> a <B>t</B>utorial associated with a module is opened. The association between module and tutorial is defined in "Tutorial Links".
<P>Files are searched <B>only</B> in the current directory. If the field is empty, Watson uses the default order "DMSCT", the order in which the information sources were described above. Note that this order offers the best possible search strategy and that, at each missing step the amount of information Watson supplies is diminished. However, the order may be changed and information sources not explicitely specified are ignored. The set order can also be overwritten with the <I>Select Source</I> radio-buttons.
<BR>
<A NAME="10"></A>
<A NAME="11"></A>
<BR>
<A NAME="archive"></A><B>Def Archive:</B> This text field contains the name of the <A HREF="Compress.html#compress">archive</A> (file) containing the definition texts. The module definitions of the Oberon system are delivered in the archive "Definitions.Arc". This file may be extended with the definitions of custom developed modules. Alternatively, new separate archives may be constructed, but only one such archive can be searched. The archive must be found in the current search path (see OBERON.INI)
<P><B>Mod file name:</B> This text field may contain a module name filter of the form <B>[prefix] [* [postfix]]</B> in which Watson will replace the asterisk by the name specified in the Watson command. If only a prefix is specified, Watson assumes a module name obtained by the concatenation of three parts: <B>prefix name .Mod</B> . In both cases, If the system cannot open a file with that name, it will further attempt to open a file named <B>name .Mod</B> .
<P><B>Application:</B> A number of Oberon modules are platform dependent: that is for instance the case for Win.Display.Mod. Watson can produce the definition module of almost any module on a Windows platform if the text field contains "Win." or "Win.*.Mod".
<P><B>Examples:</B> Assuming that the name appearing in the Watson command is "Sample":
<BR>
<PRE>
    Win.*.Mod2   =>   Win.Sample.Mod2
    Win.*        =>   Win.Sample
    Win.         =>   Win.Sample.Mod
    *.Mod3       =>   Sample.Mod3
    *            =>   Sample
    empty string =>   Sample.Mod
</PRE><B>
<BR>Tutorial Links:</B> This text gadget defines the association between modules and tutorials. Each text line contains a name pair with at the left a module name and at the right a tutorial name or a two-part qualified name of the form: tutorial.label . The label, which must be exported by the tutorial, identifies where to open the tutorial. The file name of a tutorial must have the suffix ".html".
<P><B>Example:</B>
<BR>
<PRE>
    Watson    Watson
    Items     Watson.HELPITEM
</PRE>
<BR>
<H2>
<A NAME="select"></A>Select Source</H2>
When the radio-button "Auto" is selected (this is the default setting), the information sources search order applies, but you can temporarily overwrite this order with one of the remaining radio-buttons. If that is the case, the information source corresponding to the selected radio-button is then searched first, while the remaining sources specified in the search order follow in order.
<P><B>Example:</B>
<BR>Given the default order "DMSCT", selecting "Sym" results in the new order "SDMCT".
<P>
<H2>
<A NAME="12"></A>Formatting Options</H2>
When a module text in a marked viewer or in a <B>.Mod</B> file is used to create a definition text, the created text may be formatted in three different forms:
<BR>
<UL>
<BR>
<LI>without alteration to the source module text,
<LI>with all text appearing in Syntax10 font: <I>Syntax10 font only</I> is checked (command option <B>p</B>). This option overwrites the <I>Comments in italic</I> one.
<LI>with comments in italic: <I>Comments in italic</I> is checked (command option <B>i</B>),</UL>
<BR>Note that these options are ignored, if a <B>.Def</B> file is exploited first, e.g. when the searching sequence is DMSCT.
<P>
<H2>
<A NAME="13"></A>Symbol file Options</H2>
When symbol information extracted from a symbol file or an object file is used to create a definition text, the created text may offer three different information contents:
<BR>
<UL>
<BR>
<LI>without addition,
<LI>with all details: <I>Show all details</I> is checked (command option <B>d</B>),
<LI>with extended base types information: <I>Extend base type</I> is checked (command option <B>x</B>).</UL>
<BR>Note that these options are ignored, if a <B>.Def</B> or a <B>.Mod</B> file is exploited first, that is, the default search order must start with <B>S</B> or the check box <B>Sym</B> must be checked.
<P>These options are the same as those of the <A HREF="#browserO">browser</A> commands, that is <B>\d</B> and <B>\x</B> respectively.
<P>
<H2>
<A NAME="14"></A>Command buttons for showing information</H2>
Note that feedback information appears in the Oberon log, indicating from which source Watson obtained the information for constructing the module definition.
<P>Each of the buttons hides a command which is described in the subsequent chapter.
<P><B>[Show Def ^]</B> <A HREF="#SHOWDEF">Watson.ShowDef ^</A>.
<P><B>[Show Obj ^]</B> <A HREF="#SHOWOBJ">Watson.ShowObj ^</A>.
<P><B>[Show Def *]</B> <A HREF="#SHOWDEF">Watson.ShowDef *</A>.
<P><B>[Show Imp ^]</B> <A HREF="#SHOWIMPORTS">Watson.ShowImports ^</A>.
<P><B>[Show Exp ^]</B> <A HREF="#SHOWEXPORTS">Watson.ShowExports ^</A>.
<P><B>[Check ^]</B> <A HREF="#CHECK">Watson.Check ^</A>.
<P><HR>
<H1>
<A NAME="15"></A>Watson commands</H1>

<BR>Note that feedback information appears in the Oberon log, indicating from which source Watson obtained the information for constructing the module definition.
<H2>
<A NAME="SHOWDEF"></A>Show module definition - Watson.ShowDef</H2>
<B>Watson.ShowDef [\options] (module | * | ^)</B> opens a viewer named "module.Def" displaying the definition of the named module. The name must be an Oberon name, of which only the first part of a qualified multipart name is used. Watson attempts to open the information sources in a specified search order and reports on the outcome of the search: if the requested information is found, the name of the source is listed in the Oberon log, otherwise an error message "no information about ... available" appears.
<P>If the information source is the marked viewer (*), this marked text must be a valid Oberon program text. If it is not, the location of the error is listed in the log. 
<P>If the information source is a tutorial (T), it is opened as specified in "Tutorial Links".
<P>The <B>options</B> belong to three different categories:
<BR>
<OL>
<BR>
<LI>the information sources identified by the capital letters <B>D</B>, <B>M</B>, <B>S</B>, <B>C</B>, <B>T</B> in the desired order. This order takes precedence over the <A HREF="#search">search order</A> defined in the setup. Not all sources must be explicitely named - the remaining positions will be taken over from the setup.&nbsp; &nbsp; &nbsp; &nbsp; Search order in Setup: DMSCT&nbsp; &nbsp; &nbsp; &nbsp; Command parameter: \MS&nbsp; &nbsp; &nbsp; &nbsp; Resulting search order: MSDCT
<LI>the formatting options: <B>d</B> and <B>x</B>.
<LI>the symbol file options: <B>i</B> and <B>p</B></OL><B>
<BR>Exercise:</B> Create a definition module for the sample program "Items.Mod" first. Then make sure that the text gadget of the "Tutorial Links" contains a line
<BR>&nbsp; &nbsp; <B>Items&nbsp; &nbsp; Watson.HELPITEM</B>
<P>and try this: <CALL CMD="Watson.ShowDef \T Items"><FONT COLOR=FF0000>Watson.ShowDef \T Items</FONT></CALL>
<P>
<H2>
<A NAME="SHOWOBJ"></A>Show object definition - Watson.ShowObj</H2>
<B>Watson.ShowObj [\options] (module.object | ^)</B> opens a viewer named "module.Def" displaying the definition of the selected object in the selected module. The parameter must contain a two-part qualified name of the form <B>module.object</B>, where <B>object</B> is the name of an object exported by <B>module</B>. If that object is not found, the entire module definition is displayed.
<P>The <B>options</B> are the same as for Watson.ShowDef.
<P>
<H2>
<A NAME="MAKEDEFS"></A>Make definitions - Watson.MakeDefs</H2>
<B>Watson.MakeDefs [\c] ({modName} (~ | ^) | *)</B> creates a definition module (.Def) for each module file (.Mod) in the list. The module files must be found in the current directory. If the option <B>\c</B> is used, HTML document files (*.Def.html) are created instead.<B>
<BR>Caution</B>: If a matching definition or HTML file already exists, it is overwritten.
<P>Try this: <CALL CMD="Watson.MakeDefs Items.Mod ~"><FONT COLOR=FF0000>Watson.MakeDefs Items.Mod ~</FONT></CALL>
<P>Such a definition module may be added to an archive of definitions at any time, if it is of some importance to your installation.
<P>
<H2>
<A NAME="CONVERTDEFS"></A>Convert definitions to HTML text- Watson.ConvertDefs</H2>
<B>Watson.ConvertDefs {defName}~ | ^</B> converts each definition module (.Def) named in the list into a HTML document file (*.Def.html). The definition modules to convert must be found in the current directory or in the archive file specified in the Watson panel settings.<B>
<BR>Caution</B>: If a matching HTML file already exists, it is overwritten.
<P>Try this: <CALL CMD="Watson.ConvertDefs Items.Def Watson.Def ~"><FONT COLOR=FF0000>Watson.ConvertDefs Items.Def Watson.Def ~</FONT></CALL>
<P>
<H2>
<A NAME="SHOWIMPORTS"></A>Show imports (OMEGA only) - Watson.ShowImports</H2>
<B>Watson.ShowImports [\options] (module | ^)</B> opens a viewer named "module.Imp" displaying a map of all the modules imported by the named module, and of all the exported objects in those modules which are effectively imported. This "uses what?" request may take some time to complete. Only the first part of a qualified multipart module name is used.
<P>
<H2>
<A NAME="SHOWEXPORTS"></A>Show exports (OMEGA only) - Watson.ShowExports</H2>
<B>Watson.ShowExports [\options] (module | ^)</B> opens a viewer named "module.Def" displaying the definition of the named module, in the same fashion as <B>[Show Def ^]</B>, but the objects exported by the selected module which are effectively used in other modules are shown in green. When such a green spot is clicked with the middle mouse key, it shows a list of modules using the object. Selecting one of the module with the mouse cursor and releasing the mouse key, opens the module. This "where used?" request is only valuable when a module is effectively used by other modules. This request may take some time to complete. Only the first part of a qualified multipart module name is used.
<P>
<H2>
<A NAME="CHECK"></A>Check module consistency (OMEGA only) - Watson.Check</H2>
<B>Watson.Check {module[*]} | ^ | all</B> opens a viewer named "Check.Out" telling if the named modules can be loaded or not. If not, a message is displayed in the log. The objective is to check the consistency of the named modules or of all modules. Only the first part of qualified multipart names is used.
<BR>
<HR>
<BR>Revised, 11 Dec 1996<BR>Installed on 14 Feb 1997<HR></BODY>
</HTML>

